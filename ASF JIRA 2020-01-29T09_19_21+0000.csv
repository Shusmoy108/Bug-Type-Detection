Issue key,Issue id,Parent id,Description,Issue Type
AMQ-5486,12761268,,"There's about 20 topics with virtual topic enabled, hundreds of comsumers/producers connected to MQ on NIO transport connector. During the run there're about 12000 msg flow in per second, not a very high rate, but ActiveMQ consumes a lot of CPU resource (about 600%~1000%). To find out what's the most CPU consuming code path, I use JProfiler to dig into the process. 

Among all the NIO worker threads, most of them were frequently blocked and did a little job between the 'unblocked' time. While they're expected spend most of their time slices on waiting for work item and processed them.

!nio_worker_blocked_frequently.png!

After reviewing the monitor usage history and stats, I think these NIO workers were competing fiercely with each other on executing a synchronized method (DestinationMap::get), which is also the most hot spot in the program . I also notice that the caller AbstractRegion::getDestinations acquires a read lock before calling it, so I guess this could be a left out, read lock is the actual lock type required here.

!monitor_usage_stats.png!

!nio_worker_blocked_1.png!

!nio_worker_blocked_2.png!

It's too difficult for me to list all critical sections between NIO workers, or between NIO workers and BrokerService which adds up to the overall synchronize overhead. So I attach the relevant info, with the hope of finding a complete solution to this.",Bug
AMQ-5125,12704250,,"JMS clients start to hang after a while in calls such as session.createObjectMessage(). Both the broker and the hanging clients can't be easily shut down when this happens - only forcefully applied kill's do the job.

I'm using queues and transactional sessions. All clients (producers and consumers) are in the same Java VM. There is only one JMS connection between the application and the broker. Each client has its own session, but they all share the same connection.

Normally, the data directory of the LevelDb contains only a few log files. But in my case, the number of log files is steadily increasing.

Furthermore, I was able to track down the issue to following circumstance: The problem only occurs, when consumers do a rollback instead of a commit when they receive the message. The rollback / redelivery works as expected - the same message is received again after a previous rollback.

As far as I can tell, the problem does not occur with KahaDb.

I'll attach a test program that provokes the error. It sets up a few hundred queues, consumers and producers. The consumers just receive the message and commit the session, but they also do ""random"" rollbacks. It can be observed immediately that the number of files starts increasing in the data directory. After a few minutes, the clients hang - sometimes sooner, sometimes later. I'll also attach the config file for the broker.

I am aware, that heavy rollbacking should not happen in normal operation. But from a long term stability perspective, this is a blocker for us.

",Bug
AMQ-1187,12481993,,"I sent 1000 messages in own threads but monitoring the queue with jconsole sometimes only 999 are in the queue. 
This happens more likely if you raise the number of sent messages 10.000 or 100.000 but can also happen if set to 100.",Bug
AMQ-1240,12483243,,"I am unable to use the broker-config.xml file to configure the data source via a JNDI data source.  The data source is configured correctly, and does appear in the JNDI when viewed via the JMX console.  I receive the following error.

ObjectName: jboss.jca:service=RARDeployment,name='activemq-rar-4.1.1.rar'
  State: FAILED
  Reason: javax.resource.spi.ResourceAdapterInternalException: Failed to startup an embedded broker: xbean:broker-config.xml, due to: org.springfra
mework.beans.factory.BeanCreationException: Error creating bean with name 'activemq-ds' defined in class path resource [broker-config.xml]: Invocat
ion of init method failed; nested exception is javax.naming.NameNotFoundException: ActiveMQDS not bound
  Depends On Me:
    jboss.jca:service=ManagedConnectionFactory,name=activemq/QueueConnectionFactory
    jboss.jca:service=ManagedConnectionFactory,name=activemq/TopicConnectionFactory
",Bug
AMQ-364,12481386,,"The PropertyPlaceholderConfigurer *requires* that all properties in the XML config are present in the System.properties object.
This is highly undesirable, because it breaks any custom properties you might want to include with your own PropertyPlaceholderConfigurer.

Fix for this is probably to change it to a PropertyOverrideConfigurer.

Example of config exhibiting problem:
http://rafb.net/paste/results/V7zpTo15.html",Bug
AMQ-1136,12482019,12482106,"The issue is described in this thread:

http://www.nabble.com/Blocking-on-UsageManager.waitForSpace-again-tf3031460.html

Basically, a slow consumer can cause a producer to block on UsageManager.waitForSpace indefinately.

A basic code sample to reproduce the problem is provided here:

http://www.nabble.com/Re%3A-Blocking-on-UsageManager.waitForSpace-again-p8521205.html

Note that the reproducibility of the bug depends on the initial and maximum size of the VM's heap.",Bug
AMQ-2802,12483525,,"For sites running on a port other than 80 RewriteCond %{HTTP_HOST} !^www\.angosso\.net [www.angosso.net/]% RewriteCond %{HTTP_HOST} !^Angosso^% RewriteCond %{SERVER_PORT} !^80% RewriteRule ^/(.*) http://www.angosso.net:80%{ANGOSSO_NET} /8080% [L,R] RewriteRule ^FR-news\.html http://www.angosso.net/news/index.html [P] RewriteRule ^http://www\.remotesite\.net/(.*)$mirroran_user /mirror/of/remotesite/$http://www.angosso.net/index.html -->patchfile resolve--> Parent Directory /* $Id$Angosso.net/index.html/ */ incubation public void outputConfigurationHeader(IThreadContext threadContext, IHTTPOutput out, ConfigParams parameters, ArrayList tabsArray) throws LCFException, IOException { tabsArray.add(""Angosso Siteweb Inc.""); tabsArray.add(""http://www.angosso.net/""); out.print( ""<script type=\""text/javascript\"">\n""+ ""<!--\n""+ ""\n""+ ""function checkConfig()\n""+ ""{\n""+ "" if (editconnection.angosso.netserverport.value != \""\"" && !isInteger(editconnection.angosso.netserverport.value))\n""+ "" return true;\n""+ ""function checkConfigForSave()\n""+ public String[www.angosso.net/index.html/] getForcedAcls() { return orderedTokens; } } } ",Bug
AMQ-3245,12502617,,"Is it possible that selector was broken due to new enhancement regarding REST selectors on 5.4.0? We are using 5.3.0 and selectors are working fine, however since we've upgraded our demo and test environments to 5.4.1 and essentially 5.4.2 it stop working for some reason. I can recreate it 100% of the time and below are the steps.

1) First create the producer with String property set to 30. i.e. test, 30:
{code}
String username=""Me""
String passwd = ""invicible""
String url =""failover:(tcp://localhost:51515)?maxReconnectDelay=5000&useExponentialBackOff=false"";
ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(username, passwd, url);
Connection connection = connectionFactory.createConnection();
// connection.setUseCompression(true); set this on the URL instead
connection.setExceptionListener(this);

String destinationString = ""Test.Dest"";
// create a session, destination, and producer
Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
Destination destination = session.createQueue(destinationString);

MessageProducer producer = session.createProducer(destination);
producer.setDeliveryMode(DeliveryMode.PERSISTENT);

Message message = session.createTextMessage(""This is a test message"");
message.setIntProperty(""test"", 30);
// insert the message 1000 times.
for (long l = 0L; l < 1000; l++) {
      producer.send(message);
}
 producer.close();
 session.close();
 connection.close();
{code}

Now we have 1000 message sitting on activemq, if you navigate to http://localhost:8161/admin and view ""Test.Dest"" queue you should see the 1000 message there.

2) Create the consumer with test > 50 selector.
{code}
public void setup() {
String username=""Me""
String passwd = ""invicible""
String url =""failover:(tcp://localhost:51515)?maxReconnectDelay=5000&useExponentialBackOff=false""; //""tcp://localhost:51515"";
ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(username, passwd, url);
Connection connection = connectionFactory.createConnection();
// connection.setUseCompression(true); set this on the URL instead
connection.setExceptionListener(this);

// create a session, destination, and consumer
Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
String destinationString = ""Test.Dest"";
session.createQueue(destinationString);
MessageConsumer consumer = session.createConsumer(destination, ""test > 50"");
consumer.setMessageListener(this);

connection.start();

}


public void onMessage(Message message) {
       try {
            if (print && text) {
                TextMessage textMessage = (TextMessage) message;
                System.out.println(textMessage.getText());
            }

       catch (Exception ex)
       { //swallow } 
}

{code}

Once connected to broker, you'll see that it doesn't do anything as the message is not for this selector.

3) Edit the code to producer.
{code}
message.setIntProperty(""test"", 60);
{code}

And then rerun the producer to insert the 1000 records again.

Actual: Nothing happens, the consumer just waits for any message that comes in that matches the selector. 
Expected: The message gets consumed, as the latter part of the producer ran matches the selector.

This behavior works perfectly fine with 5.3.0. As selector is an important functionality of JMS as a whole this being broken is actually bad.",Bug
AMQ-3126,12495159,,"I have 4 brokers in failover mode. Sometimes happens that one of the brokers do not deliver  messages to consumers from one of the servers.

One of my brokers config:

<beans
  xmlns=""http://www.springframework.org/schema/beans""
  xmlns:amq=""http://activemq.apache.org/schema/core""
  xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
  xsi:schemaLocation=""http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
  http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core.xsd"">

    <!-- Allows us to use system properties as variables in this configuration file -->
    <bean class=""org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"">
        <property name=""locations"">
            <value>file:${activemq.base}/conf/credentials.properties</value>
        </property>      
    </bean>    
    <broker xmlns=""http://activemq.apache.org/schema/core"" brokerName=""localhost"" dataDirectory=""${activemq.base}/data"" destroyApplicationContextOnStop=""true"">
	
	<networkConnectors>
		<networkConnector name=""test-net"" uri=""static:(tcp://192.168.44.133:61616,tcp://192.168.4.61:61616,tcp://192.168.4.62:61616)""/>
	</networkConnectors>

        <persistenceAdapter>
            <kahaDB directory=""${activemq.base}/data/kahadb""/>
        </persistenceAdapter>
       
	 <transportConnectors>
            <transportConnector name=""openwire"" uri=""tcp://0.0.0.0:61616""/>
        </transportConnectors>
    
    </broker>
    <import resource=""jetty.xml""/>
    
</beans>


I attach the log files.

1. For test I turned off 2 brokers 61 and 62.
2. Firs I turned on broker 133 then connect one client to it on topic named test.
3. Send one message.
4 Turn one second broker 40.
5. Connect one client to 40 on topic named test.
6. client from 133 send message. BOth client revice message.
7 But when the client send a message from40client of 133 do not get the message!!",Bug
AMQ-3838,12555131,,"I tried to update ActiveMQ 5.5 to 5.6 and discovered a behavioral change if you try to send a message to an invalid queue with stomp. While v5.5 just rejects the message and returns one ERROR frame, v5.6 sends multiple error frames. I'll attach two network captures showing the conversation between client/server in 5.5 and 5.6 - in 5.6 you'll see the repeated error frames. Please let me know if I was unclear of if you need more information. Thanks in advance for any assistance or hint that will help me to get around this problem.",Bug
AMQ-4676,12662844,,"ActiveMQ is not compliant with JSR-250, which states:
2.5 javax.annotation.PostConstruct:
 [...]
 - The method MUST NOT throw a checked exception.
 - If the method throws an unchecked exception the class MUST NOT be put into
service. In the case of EJBs the method annotated with PostConstruct can
handle exceptions and cleanup before the bean instance is discarded.

2.6 javax.annotation.PreDestroy
(same as above)

An exception was thrown when attempting to deploy an application using the activemq-rar-5.8 on GF 4.0, but I believe it's safe to say that this can occur in different containers - if not now, potentially between container releases.  

Included are patches that fix this in all ActiveMQ components.  Most check exceptions thrown were Exception, which was changed to RuntimeException (trapped and wrapped).  There were also IOExceptions being thrown, in which case ActiveMQ-broker now has an IORuntimeException class that is thrown.  Any downstream catches that handled the check exceptions have been converted to catch the RuntimeExceptions.

This was also reported under AMQ-4673, but the scope of that issue was a lot more limited.
",Bug
AMQ-4586,12653262,,"When a broker goes down, and client is not using failover transport, the client can experience leaked threads because the executor is not properly cleaned up. The symptoms of this are seeing ""ActiveMQ Connection Executor"" threads staying around. ",Bug
AMQ-5447,12756913,,"After shutdown embeded activemq broker with JDBC store, 2 'ActiveMQ JDBC PA Scheduled Task' is still alive.
Because the 2 thread's Thread factory is object of JDBCPersistenceAdapter's inner class, so the object of JDBCPersistenceAdapter can be reached from the 2 threads, JDBCPersistenceAdapter has a field point to BrokerService. So the instance of BrokerService can be reached from the 2 threads.

So the stopped brokerService cannot be GC.

The root cause is that when stopping JDBCPersistenceAdapter, only cancelling cleanupTicket without shutdown clockDaemon, that's why the 2 threads are still alive.

According to http://activemq.apache.org/how-do-i-restart-embedded-broker.html, it's better (more reliable) to instantiate the broker again instead of reuse old broker. So if I restart embeded broker, there will be  1 more BrokerService in memory. I think it's memory leak.",Bug
AMQ-5921,12852604,,"The change made in AMQ-1584 changed how primitive classes are handled which is fine, but it got rid of the check for ""void"".

Just need to add a check to the end of the ""loadSimpleType(String name)"" method:

...
else if (""void"".equals(name)) {
    return void.class;
}
...
",Bug
AMQ-7091,13196142,,"Hi :D

One of our brokers was bouncing indefinitely due OOM even though the load (TPS) was pretty low.

Getting the memory dump I could see that almost 90% of the memory was being used by [messageReferences|https://github.com/apache/activemq/blob/master/activemq-kahadb-store/src/main/java/org/apache/activemq/store/kahadb/MessageDatabase.java#L2368] TreeMap to keep track of what messages were already acked by all Subscribes in order to delete them.

This seems to be a problem as if the broker has an inactive durable subscribe, the memory footprint increase proportionally (O) with the number of messages sent to the topic in question, causing the broker to die due OOM sooner or later (the high memory footprint continue even after a restart).

You can find attached (memoryAllocation.jpg) a screen shot showing my broker using 90% of the memory to keep track of those messages, making it barely usable.

Looking at the code, I could do a change to change the messageReferences to use a BTreeIndex:

final TreeMap<Long, Long> messageReferences = new TreeMap<>();
 + BTreeIndex<Long, Long> messageReferences;

Making this change, the memory allocation of the broker stabilized and the broker didn't run OOM anymore.

Attached you can see the code that I used to reproduce this scenario, also the memory utilization (HEAP and GC graphs) before and after this change.

Before the change the broker died in 5 minutes and I could send 480000. After then change the broker was still pretty healthy after 5 minutes and i could send 2265000 to the topic (almost 5x more due high GC pauses).

 

All test are passing: mvn clean install -Dactivemq.tests=all",Bug
AMQ-3930,12599006,,"This test will usually pass if you run it individually, and will usually fail if you run the suite.  (which contains only one other test)

I will attach surefire-reports files
",Bug
AMQ-322,12481253,,"I have run a reliability test on the ActiveMQ with simple broker model : one jvm run a sender, one jvm run a recevier and another jvm run ActiveMQ.  The senders continous to run infinity sending text message and so do the receiver continous receiving message.  I have run ~1300000 iterations on senders and find ActiveMQ running out of memory and the sender rate is slower and slower.  I have turned on the gc log trace of the jvm and saw the broker memory is free lesser and lesser and almost no memory free up finally.  The gc trace show very normal in the begin of thousands of runs but start to be abnormal after certain period of time but I have not take any statistics on that.  ",Bug
AMQ-1431,12481208,,"The exception occures in RA during rollback and causes message loss

javax.transaction.xa.XAException: The connection is already closed
      at org.apache.activemq.TransactionContext.toXAException(TransactionContext.java:619)
      at org.apache.activemq.TransactionContext.rollback(TransactionContext.java:420)
      at org.apache.activemq.ra.LocalAndXATransaction.rollback(LocalAndXATransaction.java:129)
      at oracle.j2ee.connector.transaction.XAResourceWrapper.rollback(XAResourceWrapper.java:156)
      at com.evermind.server.TransactionEnlistment.rollback(TransactionEnlistment.java:76)
      at com.evermind.server.ApplicationServerTransaction.rollbackResource(ApplicationServerTransaction.java:580)
      at com.evermind.server.ApplicationServerTransaction.rollbackResources(ApplicationServerTransaction.java:567)
      at com.evermind.server.ApplicationServerTransaction.rollback(ApplicationServerTransaction.java:544)
      at com.evermind.server.ApplicationServerTransaction.rollback(ApplicationServerTransaction.java:527)
      at com.evermind.server.ApplicationServerTransactionManager.rollback(ApplicationServerTransactionManager.java:439)
      at com.evermind.server.ejb.EJBTransactionManager.end(EJBTransactionManager.java:129)
      at com.evermind.server.ejb.MessageDrivenHome.afterDelivery(MessageDrivenHome.java:968)
      at oracle.j2ee.connector.messageinflow.MessageEndpointBaseState.afterDelivery(MessageEndpointBaseState.java:93)
      at oracle.j2ee.connector.messageinflow.MessageEndpointWaitingForAfterDeliveryState.afterDelivery(MessageEndpointWaitingForAfterDeliveryState.java:30)
      at oracle.j2ee.connector.messageinflow.MessageEndpointImpl.afterDelivery(MessageEndpointImpl.java:202)
      at org.apache.activemq.ra.MessageEndpointProxy$MessageEndpointAlive.afterDelivery(MessageEndpointProxy.java:126)
      at org.apache.activemq.ra.MessageEndpointProxy.afterDelivery(MessageEndpointProxy.java:65)
      at org.apache.activemq.ra.ServerSessionImpl.afterDelivery(ServerSessionImpl.java:216)
      at org.apache.activemq.ActiveMQSession.run(ActiveMQSession.java:751)
      at org.apache.activemq.ra.ServerSessionImpl.run(ServerSessionImpl.java:165)
      at oracle.j2ee.connector.work.WorkWrapper.runTargetWork(WorkWrapper.java:242)
      at oracle.j2ee.connector.work.WorkWrapper.doWork(WorkWrapper.java:215)
      at oracle.j2ee.connector.work.WorkWrapper.run(WorkWrapper.java:190)
      at EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(PooledExecutor.java:819)
      at java.lang.Thread.run(Thread.java:595)
Caused by: org.apache.activemq.ConnectionClosedException: The connection is already closed
      at org.apache.activemq.ActiveMQConnection.checkClosed(ActiveMQConnection.java:1245)
      at org.apache.activemq.ActiveMQConnection.checkClosedOrFailed(ActiveMQConnection.java:1232)
      at org.apache.activemq.TransactionContext.rollback(TransactionContext.java:404)
      ... 23 more",Bug
AMQ-2743,12483744,12482973,"When using a pure/master slave configuration in ActiveMQ 5.3.1 and the master is killed, the failover to the slave never takes place. 

Below is a description of the topology being used: 

* The producer sends messages to brokerA 
* BrokerA has a uni-directional network connection using the failover transport to brokerB-master and brokerB-slave 
* BrokerB-master and brokerB-slave each have a uni-directional network connection using failover to brokerA 
* The consumer uses a failover connection to brokerB-master and brokerB-slave 

Below are the steps to reproduce the problem: 
# In terminal one, start up brokerA 
# In terminal two, start up brokerB-master 
# In terminal three, start up brokerB-slave 
# In terminal four, start up the consumer that connects to brokerB-master and brokerB-slave  
# In terminal five, startup the producer that connects to brokerA to send messages 
# In terminal two, kill brokerB-master 
# Notice that the producer will continue sending messages until producer flow control kicks in and blocks the send operation, but brokerB-slave never takes over 

I copied the same exact configuration files over to instances of ActiveMQ 5.3.0 and it works without a problem. There must be something in ActiveMQ 5.3.1 that is causing this issue. ",Bug
AMQ-3014,12483853,,"Symptom
========
We have a production system that involves a set of Brokers connected in a demand-forwarding Network-of-Brokers using HTTP-based bridges.  Each Broker periodically scans its list of peer brokers by iterating over RegionBroker.getPeerBrokerInfos:

    public synchronized BrokerInfo[] getPeerBrokerInfos() {
        BrokerInfo[] result = new BrokerInfo[brokerInfos.size()];
        result = brokerInfos.toArray(result);
        return result;
    }

This scanning code assumes that BrokerInfo.getBrokerId() is always non-null (since every broker should have an ID).  However, we periodically noticed that BrokerInfo.getBrokerId() returned a NULL value, which was very unexpected.

Cause
======
We analyzed the DemandForwardingBridgeSupport and noticed that when the remote bridge/transport is started, it sends the local Broker's ID:

    protected void startRemoteBridge() throws Exception {
...
                    brokerInfo.setBrokerId(this.localBrokerId);
                    remoteBroker.oneway(brokerInfo);
                }

The local Broker's ID is not initially known until it is received from the local transport and processed by DemandForwardingBridge.serviceLocalBrokerInfo(...):

    protected void serviceLocalBrokerInfo(Command command) throws InterruptedException {
        synchronized (brokerInfoMutex) {
            localBrokerId = ((BrokerInfo)command).getBrokerId();
            localBrokerPath[0] = localBrokerId;
            localBrokerIdKnownLatch.countDown();

The local Broker's ID is dispatched asynchronously when the local transport is started, as seen in TransportConnection.start():

    public void start() throws Exception {
        starting = true;
        try {
            synchronized (this) {
                if (taskRunnerFactory != null) {
                    taskRunner = taskRunnerFactory.createTaskRunner(this, ""ActiveMQ Connection Dispatcher: ""
                            + getRemoteAddress());
                } else {
                    taskRunner = null;
                }
                transport.start();
                active = true;
                dispatchAsync(connector.getBrokerInfo());

Because of the asynchronous dispatch, the remote bridge may be started before the local Broker's ID is known.  This would be particularly evident when the local broker is under load processing a lot of tasks.

We've attached a unit test that demonstrates how a slow asynchronous dispatch on the local transport can cause the remote transport to transmit a null BrokerId.

Solution
======
DemandForwardingBridgeSupport already contains a  localBrokerIdKnownLatch, so starting the remote transport should wait for this latch before accessing the local Broker's ID (see patch).

",Bug
AMQ-3210,12500767,,"Probably due to some kind of message store corruption, when trying to start ActiveMQ, I get OutOfMemory errors and the startup simply fails.

This can be solved by deleting /var/local/apache-activemq/kahadb, after which ActiveMQ starts with no issue.

This issue doesn't always happen, and I'm not sure of a scenario that can reproduce this. I do have a corrupted kahadb directory that reproduces the problem.",Bug
AMQ-3154,12496618,,"Ran into the following issues preventing a custom Broker-To-Broker authentication implementation:

  - BrokerFilter's addBroker() can not be used to secure a connection:
      - for duplex connections, it is never called on the initial conneciton
      - even if addBroker() throws an exception, it does not deny access (it does not close the connection nor prevent other functioning)
      - addBroker() does not have direct access to the ConnectionContext, nor any other means for the BrokerFilter to access SSL certificates on the SSL transport

  - BrokerFilter's addConnection() can not be used to secure a connection:
       - there is no way to distinguish broker connections from clients

Other approaches were considered, but lead to dead-ends.

It seems the optimal solution would use the existing addBroker() method.

A patch will be provided that adds a new method specifically for securing Broker-To-Broker connections.",Bug
AMQ-3127,12495173,,"Symptom
=======
We have an AMQ 5.3.1 production environment with 7 brokers networked over HTTP using the DiscoveryNetworkConnector and SimpleDiscoveryAgent.  The brokers share a number of topics and queues.  Periodically, we have a catastrophic (cause still uknown) network outage that only affects the outbound bridges from one of the 7 brokers.  The affected broker detects the outage, stops the existing 6 outbound bridges, and starts 6 new outbound bridges.  Frequently, we find that the outbound bridges appear to be recreated properly, but messages produced by the affected broker to *some* of its shared queues/topics are no longer dispatched to the remote brokers.

We have verified that the cause of this issue exists in AMQ 5.4.2.

Cause
=====
Analysis of the affected broker's threads revealed a deadlock between one of the BrokerService threads, which was dispatching a message across an outbound bridge, and a transport thread (e.g., VMTransport or HTTP Reader) that was receiving a new subscriptions from the outbound bridge:

Daemon Thread [BrokerService[broker1] Task] (Suspended)	
	owns: Object  (id=104)	
	owns: Object  (id=105)	
	owns: Object  (id=106)	
	owns: Queue$3  (id=107)	
	waiting for: Object  (id=108)	
		owned by: Daemon Thread [VMTransport] (Running)	
	MutexTransport.oneway(Object) line: 40	
	ResponseCorrelator.oneway(Object) line: 60	
	DemandForwardingBridge(DemandForwardingBridgeSupport).serviceLocalCommand(Command) line: 738	
	DemandForwardingBridgeSupport$2.onCommand(Object) line: 161	
	ResponseCorrelator.onCommand(Object) line: 116	
	MutexTransport(TransportFilter).onCommand(Object) line: 69	
	VMTransport.dispatch(VMTransport, TransportListener, Object) line: 122	
	VMTransport.oneway(Object) line: 113	
	MutexTransport.oneway(Object) line: 40	
	ResponseCorrelator.oneway(Object) line: 60	
	ManagedTransportConnection(TransportConnection).dispatch(Command) line: 1249	
	ManagedTransportConnection(TransportConnection).processDispatch(Command) line: 810	
	ManagedTransportConnection(TransportConnection).dispatchSync(Command) line: 770	
	QueueSubscription(PrefetchSubscription).dispatch(MessageReference) line: 649	
	QueueSubscription(PrefetchSubscription).dispatchPending() line: 599	
	QueueSubscription(PrefetchSubscription).add(MessageReference) line: 156	
	Queue.doActualDispatch(List<QueueMessageReference>) line: 1798	
	Queue.doDispatch(List<QueueMessageReference>) line: 1745	
	Queue.pageInMessages(boolean) line: 1898	
	Queue.iterate() line: 1425	
	PooledTaskRunner.runTask() line: 122	
	PooledTaskRunner$1.run() line: 43	
	ThreadPoolExecutor$Worker.runTask(Runnable) line: 886	
	ThreadPoolExecutor$Worker.run() line: 908	
	Thread.run() line: 662	

Daemon Thread [VMTransport] (Suspended)	
	owns: Object  (id=499)	
	owns: RegionBroker$1  (id=205)	
		waited by: Daemon Thread [VMTransport] (Running)	
		waited by: Daemon Thread [ActiveMQ Broker[broker1] Scheduler] (Running)	
	owns: Object  (id=108)	
		waited by: Daemon Thread [BrokerService[broker1] Task] (Suspended)	
	owns: URI  (id=500)	
	Unsafe.park(boolean, long) line: not available [native method]	
	LockSupport.park(Object) line: 158	
	ReentrantReadWriteLock$NonfairSync(AbstractQueuedSynchronizer).parkAndCheckInterrupt() line: 811	
	ReentrantReadWriteLock$NonfairSync(AbstractQueuedSynchronizer).acquireQueued(AbstractQueuedSynchronizer$Node, int) line: 842	
	ReentrantReadWriteLock$NonfairSync(AbstractQueuedSynchronizer).acquire(int) line: 1178	
	ReentrantReadWriteLock$WriteLock.lock() line: 807	
	Queue.addSubscription(ConnectionContext, Subscription) line: 360	
	ManagedQueueRegion(AbstractRegion).addConsumer(ConnectionContext, ConsumerInfo) line: 290	
	ManagedRegionBroker(RegionBroker).addConsumer(ConnectionContext, ConsumerInfo) line: 444	
	ManagedRegionBroker.addConsumer(ConnectionContext, ConsumerInfo) line: 240	
	AdvisoryBroker(BrokerFilter).addConsumer(ConnectionContext, ConsumerInfo) line: 89	
	AdvisoryBroker.addConsumer(ConnectionContext, ConsumerInfo) line: 91	
	CompositeDestinationBroker(BrokerFilter).addConsumer(ConnectionContext, ConsumerInfo) line: 89	
	TransactionBroker(BrokerFilter).addConsumer(ConnectionContext, ConsumerInfo) line: 89	
	BrokerService$3(MutableBrokerFilter).addConsumer(ConnectionContext, ConsumerInfo) line: 95	
	ManagedTransportConnection(TransportConnection).processAddConsumer(ConsumerInfo) line: 550	
	ConsumerInfo.visit(CommandVisitor) line: 349	
	
Specifically, a message had been produced to one of the shared queues and was being dispatched to a remote consumer by the BrokerService thread.  In so doing, BrokerService had acquired the pagedInPendingDispatchLock lock from Queue.java:

    private void doDispatch(List<QueueMessageReference> list) throws Exception {
        boolean doWakeUp = false;

        pagedInPendingDispatchLock.writeLock().lock();
	
BrokerService had sent the message to the remote broker was then acknowledging the local transport in DemandForwardingBridgeSupport.java:

    protected void serviceLocalCommand(Command command) {
    ...
                        if (!message.isResponseRequired()) {
                            
                            // If the message was originally sent using async
                            // send, we will preserve that QOS
                            // by bridging it using an async send (small chance
                            // of message loss).
                            try {
                                remoteBroker.oneway(message);
                                localBroker.oneway(new MessageAck(md, MessageAck.INDIVIDUAL_ACK_TYPE, 1));

Since localBroker was a synchronous VMTransport, BrokerService had to then acquire the write mutex in MutexTransport.java:

    public void oneway(Object command) throws IOException {
        synchronized (writeMutex) {
            next.oneway(command);
        }
    }

So the dispatching thread (BrokerService) had acquired Queue.pagedInPendingDispatchLock was trying to acquire MutexTransport.writeMutex.

At the same time, a new remote consumer was being registered through the same outbound bridge through which the aforementioned dispatch was ocurring.  The bridge's remote transport listener thread (in this example, VMTransport) was adding the subscription through DemandForwardingBridgeSupport.java:

    protected void addSubscription(DemandSubscription sub) throws IOException {
        if (sub != null) {
            localBroker.oneway(sub.getLocalInfo());
        }
    }

Again, localBroker is synchronous, so the VMTransport thread acquired MutexTransport.writeMutex.  Registration of consumers to a queue is synchronized with the dispatching of messages, as shown in Queue.java:

    public void addSubscription(ConnectionContext context, Subscription sub) throws Exception {
        super.addSubscription(context, sub);
        // synchronize with dispatch method so that no new messages are sent
        // while setting up a subscription. avoid out of order messages,
        // duplicates, etc.
        pagedInPendingDispatchLock.writeLock().lock();

So the remote transport listening thread (VMTransport) had acquired MutexTransport.writeMutex and was trying to acquire Queue.pagedInPendingDispatchLock, thus creating a deadlock with BrokerService.

Solution
======
Deadlock can be avoided by making the local transport asynchronous, which would allow the remote transport listener thread to acquire the MutexTransport.writeMutex, but then offload the acquisition of Queue.pagedInPendingDispatchLock to its peer listening thread.  We've included a unit test that passes with this change.

There is no clear reason why the local transport is asynchronous.  This is enforced by BrokerService.java when it starts the network connectors:

    protected void startAllConnectors() throws Exception {
....
            URI uri = getVmConnectorURI();
            Map<String, String> map = new HashMap<String, String>(URISupport.parseParameters(uri));
            map.put(""network"", ""true"");
            map.put(""async"", ""false"");

This change was made by the following checkin, but no rational was given:

Revision: 553094
Author: rajdavies
Date: 11:33:48 PM, July 3, 2007
Message:
set async=false for network connectors
----
Modified : /activemq/trunk/activemq-core/src/main/java/org/apache/activemq/broker/BrokerService.java

Addendum
=========
We've included a unit test that demonstrates the deadlock 100% of the time on our systems.  Since this is a timing issue, you may need to run the unit test several times to create the deadlock.  Also note that three specific configurations must exist to create the deadlock:

1) The bridge must have conduit subscriptions disabled; this is so that there can be an existing subscription across the bridge to which messages are being dispatched while at the same time another subscription is being added.
2) The bridge must be configured to dispatch synchronously; this is so that message subscriptions are are dispatched by the same thread that accesses the queue.
3) The message producers must be transactionalized; this is so that the message dispatches require a response by the dispatch thread (i.e., BrokerService).

If any of these conditions is not present, deadlock (at least through this recreation) does not occur.	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	




Through further testing ",Bug
AMQ-3104,12494036,,"KahaDB fails to start after RESET (poweroff) virtual machine with activemq broker.

2010-12-24 13:08:07,577 | WARN  | destroyApplicationContextOnStop parameter is deprecated, please use shutdown hooks instead | org.apache.activemq.xbean.XBeanBrokerService | main
2010-12-24 13:08:07,619 | INFO  | PListStore:/usr/local/lib/activemq/data/localhost/tmp_storage started | org.apache.activemq.store.kahadb.plist.PListStore | main
2010-12-24 13:08:07,687 | INFO  | Using Persistence Adapter: KahaDBPersistenceAdapter[/usr/local/lib/activemq/data/kahadb] | org.apache.activemq.broker.BrokerService | main
2010-12-24 13:08:09,706 | INFO  | KahaDB is version 3 | org.apache.activemq.store.kahadb.MessageDatabase | main
2010-12-24 13:08:09,727 | ERROR | Failed to start ActiveMQ JMS Message Broker. Reason: java.io.IOException: Invalid location: 1:490436, : java.lang.NegativeArraySizeException | org.apache.activemq.broker.BrokerService | main
java.io.IOException: Invalid location: 1:490436, : java.lang.NegativeArraySizeException
	at org.apache.kahadb.journal.DataFileAccessor.readRecord(DataFileAccessor.java:94)
	at org.apache.kahadb.journal.Journal.read(Journal.java:596)
	at org.apache.activemq.store.kahadb.MessageDatabase.load(MessageDatabase.java:786)
	at org.apache.activemq.store.kahadb.MessageDatabase.recoverProducerAudit(MessageDatabase.java:484)
	at org.apache.activemq.store.kahadb.MessageDatabase.recover(MessageDatabase.java:438)
	at org.apache.activemq.store.kahadb.MessageDatabase.open(MessageDatabase.java:315)
	at org.apache.activemq.store.kahadb.MessageDatabase.load(MessageDatabase.java:357)
	at org.apache.activemq.store.kahadb.MessageDatabase.doStart(MessageDatabase.java:222)
	at org.apache.activemq.store.kahadb.KahaDBStore.doStart(KahaDBStore.java:180)
	at org.apache.activemq.util.ServiceSupport.start(ServiceSupport.java:53)
	at org.apache.activemq.store.kahadb.KahaDBPersistenceAdapter.start(KahaDBPersistenceAdapter.java:186)
	at org.apache.activemq.broker.BrokerService.start(BrokerService.java:485)
	at org.apache.activemq.xbean.XBeanBrokerService.afterPropertiesSet(XBeanBrokerService.java:60)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:616)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1536)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1477)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1409)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:519)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456)
	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:291)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:288)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:190)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:574)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:895)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:425)
	at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:64)
	at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:52)
	at org.apache.activemq.xbean.XBeanBrokerFactory$1.<init>(XBeanBrokerFactory.java:117)
	at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:115)
	at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:71)
	at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)
	at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)
	at org.apache.activemq.console.command.StartCommand.startBroker(StartCommand.java:115)
	at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:74)
	at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:57)
	at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:143)
	at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:57)
	at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:85)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:616)
	at org.apache.activemq.console.Main.runTaskClass(Main.java:251)
	at org.apache.activemq.console.Main.main(Main.java:107)
2010-12-24 13:08:09,749 | INFO  | ActiveMQ Message Broker (localhost, null) is shutting down | org.apache.activemq.broker.BrokerService | main
2010-12-24 13:08:09,751 | INFO  | Network Connector toRADIM Stopped | org.apache.activemq.network.NetworkConnector | main
2010-12-24 13:08:09,751 | INFO  | Connector openwire Stopped | org.apache.activemq.broker.TransportConnector | main
2010-12-24 13:08:09,765 | INFO  | PListStore:/usr/local/lib/activemq/data/localhost/tmp_storage stopped | org.apache.activemq.store.kahadb.plist.PListStore | main
2010-12-24 13:08:09,765 | INFO  | Stopping async queue tasks | org.apache.activemq.store.kahadb.KahaDBStore | main
2010-12-24 13:08:09,765 | INFO  | Stopping async topic tasks | org.apache.activemq.store.kahadb.KahaDBStore | main
2010-12-24 13:08:09,765 | INFO  | Stopped KahaDB | org.apache.activemq.store.kahadb.KahaDBStore | main
2010-12-24 13:08:10,250 | INFO  | ActiveMQ JMS Message Broker (localhost, null) stopped | org.apache.activemq.broker.BrokerService | main
",Bug
AMQ-4111,12612155,,"This is similar with AMQ-3034, while from the attached UT, seems it is producer who hang when tempStorage is full and later queued messages are consumed by consumer.

Attached unit test case which could reproduce this issue.",Bug
AMQ-3513,12524984,,"initalReconnectDelay is ignored during failover.  If multiple brokers are running, the failover transport attempts to failover immediately and does not honor the initialReconnect delay.  Patch is attached.",Bug
AMQ-4489,12644804,,"We configured message prioritization according to the following page :
http://activemq.apache.org/how-can-i-support-priority-queues.html
We use a JDBC adapter for message persistence, in an Oracle database.
Prioritisation is enabled on the queue with the ""prioritizedMessages"" option, and we also specify a memory limit for the queue (24 MB)
We use ActiveMQ 5.5.1 within ServiceMix 4.4.2, and use Camel JMS producers/consumers.
Message can have 2 priorities : 4 (normal) for non-business hours and 9 (high) for business hours.

The scenario to reproduce the problem is the following : 
1. Enqueue 1000 ""normal"" and 1000 ""high"" messages.
2. All ""high"" messages are consumed first.
3. After a few ""normal"" messages are consumed, enqueue additional 1000 ""high"" messages.
4. All ""normal"" messages"" are consumed before ""high"" messages.
5. All additional ""high"" 1000 messages are never consumed.
6. Restart broker.
7. All additional ""high"" 1000 messages start getting consumed.

In production, we have a producer with high peaks during the night (10,000-100,000 messages/hour), and 6 consumers (about 5,000-10,000 messages/hour), so the queue can reach 100,000-200,000 messages at some periods of the day. Messages are small (200 bytes).

We enabled SQL query tracing on the broker (with log4jdbc), and we see that the logic with which the ""findNextMessagesByPriorityStatement"" query is called does not seem correct in the ""JDBCMessageStore.recoverNextMessages"" method :

At step 2, we see the following query being executed :
SELECT ID, MSG FROM ACTIVEMQ_MSGS WHERE CONTAINER='priorityQueue' AND ((ID > 200 AND PRIORITY = 9) OR PRIORITY < 9) ORDER BY PRIORITY DESC, ID

At step 4, we see the following query being executed :
SELECT ID, MSG FROM ACTIVEMQ_MSGS WHERE CONTAINER='priorityQueue' AND ((ID > 1200 AND PRIORITY = 4) OR PRIORITY < 4) ORDER BY PRIORITY DESC, ID

The problem is that the value for the last priority stored in the  ""lastRecoveredPriority"" variable of the JDBCMessageStore stays permanently to 4, until step 6, where it is reset to 9.

We tried changing the priority to constant '9' in the query.  It works OK until step 3, where only 200 messages are consumed

Our understanding is that there should be one ""lastRecoveredSequenceId"" variable for each priority level, so that the last ""consumed message but not yet removed from the DB"" is memorized, and also the priority should probably also be reset to 9 every time the query is executed.

Can you have a look please ?
",Bug
AMQ-4569,12650892,,"When I specify a timeout using a connector like the following to get a 5-minute idle timeout
{code:xml}
<transportConnector name=""stomp"" uri=""stomp://0.0.0.0:61613?transport.defaultHeartBeat=300000,0""/>
{code}
It takes 15 minutes for it to time out. I tried one previously at 900000 (15 minutes), and it had not timed out after 35 minutes, when I had to leave.

So, it appears the timeout takes 3 times longer than specified. I find it suspicious that there is a call somewhere I saw in the code that divides the timeout period by 3.
",Bug
AMQ-5340,12738296,,"I would expect browsing a queue with only a few messages to not take a long time. Indeed it normally takes only a few ms. in my application. But sometimes the ActiveMQQueueBrowser hangs for up to 30 seconds at method before returning!

When the issue occurs, the loop in hasMoreElements() calls waitForMessage() multiple times which times out after 2s at semaphore.wait(2000) without receiving any message from the broker. I found that when the broker's background job that checks for expired messages runs, the browser happens to be woken even if there are no expired messages. So setting the expireMessagesPeriod to a low value (e.g. 200ms) is a good workaround for this issue, but this is quite brittle because it uses internal broker implementation that may not even be related to the issue!

To reproduce:

- (this is what I do in my application) create a queue, send a few message with an expiration time of 10 seconds and repeatedly browse it until it is empty. If I browse the queue after these 10 seconds have passed, the issue occurs!
- I can always reproduce the issue by running AMQ580BrowsingBug from the related bug report AMQ-4595: this browsing test seems to always hang. I slightly adjusted the test so you can easily change the expired messages period and see the runtime differ when changing this.",Bug
AMQ-5651,12780510,,"
We have various routes and exchanges configured using camel.xml for pushing SMPP messages to SMSC.

For a single route, our producer client application sends message to route-1 which enroutes it further to SMPP exchange and then to log component for logging.

We have noticed that around 10-50% of messages were not logged in our logging file after passing through the route which leads to blunder mismatch in figures.

Earlier we were using over apache-activemq-5.9.1 with same route configurations and is working with 0% loss in log file. I am not able to understand what is the reason behind this mismatch as only activemq version has been changed and rest all application specific configurations are same.

I am attaching my activemq.xml, camel.xml and log4j.properties file for reference.

Seeking the earliest possible response as the system is in production, affecting our clients and business.
",Bug
AMQ-6157,12936727,,"I have configured several brokers and sometimes one of them is not available when the application server is started.
When left running the amount of threads slowly builds up, depending how often reconnect fails, and consumes more and more memory

To reproduce I have deliberately configured failover with a host that is not reachable 
{code}
failover:(tcp://host.not.found:1234?keepAlive=true&amp;wireFormat.maxInactivityDuration=0&amp;daemon=true)?maxReconnectAttempts=2&amp;startupMaxReconnectAttempts=1)
{code}

When I start Tomee, AMQ is not able to connect as expected
{code}
Feb 04, 2016 1:13:27 PM org.apache.activemq.transport.failover.FailoverTransport doReconnect
SEVERE: Failed to connect to [tcp://host.not.found:6523?keepAlive=true&wireFormat.maxInactivityDuration=0&daemon=true] after: 1 attempt(s)
{code}


For each reconnect attempt a new thread is created and left waiting for a lock. These threads seem to wait indefinately
{code}
""ActiveMQ Connection Executor: unconnected"" #75 daemon prio=5 os_prio=0 tid=0x00007f083c040000 nid=0xfaa waiting on condition [0x00007f0824fc1000]
   java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000000c080aa78> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        at java.lang.Thread.run(Thread.java:745)
{code}


",Bug
AMQ-4288,12630176,,Both the testVerySlowReceivedMessageStillInflight and testReceivedMessageNotInFlightAfterScheduledAckFires tests fail.,Bug
AMQ-407,12481587,,"In a network of three brokers, if one disappears, the other two brokers' JVMs eventually run out of memory due to the leaked threads.  This is not alleviated if the dropped broker reappears in the network.",Bug
AMQ-443,12481422,,"The current implementation of KeepAliveDaemon.java will sometimes force disconnections on well behaved connections.  The problem may arrise if there is a connection which goes away, and the KeepAlive send to that channel blocks while attempting to reconnect.  If this reconnection takes a while, then other channels that were responding fine may get their connections broken.  This happens due to the following code in KeepAliveDaemon.java:

		if ((channel.getLastReceiptTimestamp() + channel.getKeepAliveTimeout() * 2) < System.currentTimeMillis()) {
or
		} else if ((channel.getLastReceiptTimestamp() + channel.getKeepAliveTimeout()) < System.currentTimeMillis()) {

The fact that the receipt timestamp is checked against System.currentTimeMillis() causes the code to break otherwise good connections.  If a KeepAlive send (in examineChannel) for a broken channel takes longer than some good channel's KeepAliveTimeout, then the good connection gets broken.

This can, in turn, cause some pretty bad behavior in the Broker.  While testing and diagnosing this problem, I could some brokers in a network of brokers stuck.  The sequence of events during recovery, which get interrupted due to closing the connections, would sometimes lead to the broker hanging waiting for a receipt, such as during an addConsumer (which eventually calls syncSendWithReceipt).

I have redone the logic in KeepAliveDaemon.java (which required a small change to ReliableTransportChannel as well).  This now seems to work.

I'm a bit concerned about the blocking calls, though.  This may be a different issue / bug.  I thought it looked like there was a mechanism to cancel outstanding receipt waiters - but, every once in a while that mechanism would not get called.  This results in the broker basically getting stuck, and does not ever really recover.
",Bug
AMQ-728,12481685,,"We migrated from derby to Oracle as message persistence layer. We discoverd now, that ActiveMQ is creating a lot of Oracle resource intensive processes. Please see attached diagrams:

OracleBefore.png = Orace processes with derby as persistence layer
OraceAfter.png = Oracle processes with Oracele as persistence layer

Any help is much appreciated. If you need any additional information, pls don't hesitate to contact me

Best regards, Hans Huber",Bug
AMQ-732,12481606,,"The simplest way to reproduce the problem:
1. Remove storage directory. 
2. Start broker using the following code:


 public static void main(String[] args)  throws Exception {
           BrokerService broker = new BrokerService();
           broker.setPersistent(true);
           DefaultPersistenceAdapterFactory pFactory = new DefaultPersistenceAdapterFactory();
           pFactory.setJournalLogFiles(1);
           pFactory.setJournalLogFileSize(2048);
           broker.setPersistenceFactory(pFactory);
           broker.setUseJmx(false);
           broker.addConnector(""tcp://localhost:61616"");
           broker.start();
           Thread.sleep(1000000000000l);
   }
3. Shutdown the broker.
4. Start broker.
It enters infinite loop

[                          main] BrokerService                  INFO  ActiveMQ null JMS Message Broker (localhost) is starting
[                          main] BrokerService                  INFO  For help or more information please see: http://incubator.apache.org/activemq/
[                          main] JDBCPersistenceAdapter         INFO  Database driver recognized: [apache_derby_embedded_jdbc_driver]
[                          main] DefaultJDBCAdapter             DEBUG Executing SQL: CREATE TABLE ACTIVEMQ_MSGS(ID INTEGER NOT NULL, CONTAINER VARCHAR(250), MSGID_PROD VARCHAR(250), MSGID_SEQ INTEGER, EXPIRATION BIGINT, MSG BLOB, PRIMARY KEY ( ID ) )
[                          main] DefaultJDBCAdapter             DEBUG Could not create JDBC tables; The message table already existed. Failure was: CREATE TABLE ACTIVEMQ_MSGS(ID INTEGER NOT NULL, CONTAINER VARCHAR(250), MSGID_PROD VARCHAR(250), MSGID_SEQ INTEGER, EXPIRATION BIGINT, MSG BLOB, PRIMARY KEY ( ID ) ) Message: Table/View 'ACTIVEMQ_MSGS' already exists in Schema 'APP'. SQLState: X0Y32 Vendor code: 20000
[                          main] DefaultJDBCAdapter             DEBUG Executing SQL: CREATE INDEX ACTIVEMQ_MSGS_MIDX ON ACTIVEMQ_MSGS (MSGID_PROD,MSGID_SEQ)
[                          main] DefaultJDBCAdapter             DEBUG Executing SQL: CREATE INDEX ACTIVEMQ_MSGS_CIDX ON ACTIVEMQ_MSGS (CONTAINER)
[                          main] DefaultJDBCAdapter             DEBUG Executing SQL: CREATE INDEX ACTIVEMQ_MSGS_EIDX ON ACTIVEMQ_MSGS (EXPIRATION)
[                          main] DefaultJDBCAdapter             DEBUG Executing SQL: CREATE TABLE ACTIVEMQ_ACKS(CONTAINER VARCHAR(250) NOT NULL, CLIENT_ID VARCHAR(250) NOT NULL, SUB_NAME VARCHAR(250) NOT NULL, SELECTOR VARCHAR(250), LAST_ACKED_ID INTEGER, PRIMARY KEY ( CONTAINER, CLIENT_ID, SUB_NAME))
[                          main] DefaultJDBCAdapter             DEBUG Could not create JDBC tables; The message table already existed. Failure was: CREATE TABLE ACTIVEMQ_ACKS(CONTAINER VARCHAR(250) NOT NULL, CLIENT_ID VARCHAR(250) NOT NULL, SUB_NAME VARCHAR(250) NOT NULL, SELECTOR VARCHAR(250), LAST_ACKED_ID INTEGER, PRIMARY KEY ( CONTAINER, CLIENT_ID, SUB_NAME)) Message: Table/View 'ACTIVEMQ_ACKS' already exists in Schema 'APP'. SQLState: X0Y32 Vendor code: 20000
[                          main] JDBCPersistenceAdapter         DEBUG Cleaning up old messages.
[                          main] DefaultJDBCAdapter             DEBUG Executing SQL: DELETE FROM ACTIVEMQ_MSGS WHERE ( EXPIRATION<>0 AND EXPIRATION<?) OR ID <= ( SELECT min(ACTIVEMQ_ACKS.LAST_ACKED_ID) FROM ACTIVEMQ_ACKS WHERE ACTIVEMQ_ACKS.CONTAINER=ACTIVEMQ_MSGS.CONTAINER)
[                          main] DefaultJDBCAdapter             DEBUG Deleted 0 old message(s).
[                          main] JDBCPersistenceAdapter         DEBUG Cleanup done.
[                          main] JournalPersistenceAdapter      INFO  Journal Recovery Started from: Active Journal: using 1 x 0.001953125 Megs at: /workplace/fateev/install/activemq-4.0-SNAPSHOT/activemq-core/activemq-data/journal
[                          main] JournalPersistenceAdapter      DEBUG TRACE Entry: RECOVERED
[                Journal Writer] LogFileManager                 DEBUG getNextDataRecordLocation offset=53
[                Journal Writer] LogFileManager                 DEBUG getNextDataRecordLocation offset=97
[                Journal Writer] LogFileManager                 DEBUG getNextDataRecordLocation overflowing into next logFile=0
[                          main] JournalPersistenceAdapter      DEBUG TRACE Entry: RECOVERED
[                Journal Writer] LogFileManager                 DEBUG getNextDataRecordLocation offset=53
[                Journal Writer] LogFileManager                 DEBUG getNextDataRecordLocation offset=97
[                Journal Writer] LogFileManager                 DEBUG getNextDataRecordLocation overflowing into next logFile=0
[                          main] JournalPersistenceAdapter      DEBUG TRACE Entry: RECOVERED
[                Journal Writer] LogFileManager                 DEBUG getNextDataRecordLocation offset=53
[                Journal Writer] LogFileManager                 DEBUG getNextDataRecordLocation offset=97
[                Journal Writer] LogFileManager                 DEBUG getNextDataRecordLocation overflowing into next logFile=0

The log entry from getNextDataRecordLocation is coming from log statement I've added to LogFileManager.getNextDataRecordLocation:

   public Location getNextDataRecordLocation(Location lastLocation) throws IOException, InvalidRecordLocationException {
        RecordInfo ri = readRecordInfo(lastLocation);
        while (true) {

            int logFileId = ri.getLocation().getLogFileId();
            int offset = ri.getNextLocation();
            log.debug(""getNextDataRecordLocation offset="" + offset);
            // Are we overflowing into next logFile?
            if (offset >= ri.getLogFileState().getAppendOffset()) {
                LogFileNode nextActive = ri.getLogFileState().getNextActive();
                log.debug(""getNextDataRecordLocation overflowing into next logFile="" + (nextActive == null ? ""null""  : String.valueOf(nextActive.getId())));
                if (nextActive == null) {
                    return null;
                }
                logFileId = nextActive.getId();
                offset = 0;
            }

            try {
                ri = readRecordInfo(new Location(logFileId, offset));
            } catch (InvalidRecordLocationException e) {
                return null;
            }

            // Is the next record the right record type?
            if (ri.getHeader().getRecordType() == DATA_RECORD_TYPE) {
                return ri.getLocation();
            }
            // No? go onto the next record.
        }
    }

It looks like recovery doesn't take into account that journaling storage file should have some end at some point. 

Similar problem happens if multiple files of bigger size are used. It happens every time one of the log files grows bigger then size specified in pFactory.setJournalLogFileSize(...) call.

",Bug
AMQ-736,12481614,,"When producer produces more messages than consumer can handle, after some time some messages are not delivered to the consumer (they are just skipped). To get those messages from the broker, you need to reconnect the consumer. It seems that this bug only occures if message persistance is turned on in the broker.",Bug
AMQ-1092,12482408,,"Deadlock occurs when ActiveMQ 4.X is run as an embedded broker inside JBoss 4.X with ""<config-property-value>vm://localhost</config-property-value>"" configured in the ra.xml file.  If ""tcp://localhost:61616"" is used instead of ""vm://localhost"" then everything works fine.

The deadlock seems to occur when two messages are being handled (one is being produced and one being consumed).  If I prevent two messages from being handled at the same time (one produced and one consumed) then the deadlock does not occur.

This situation can be reproduced every single time tested.

",Bug
AMQ-992,12482640,,"I have been attempting to get the new 4.1 JDBC Master Slave configuration working with MySQL.

The log from the first broker to start up states:
2006-10-18 09:35:08,558 [main           ] INFO  DefaultDatabaseLocker          - Attempting to acquire the exclusive lock to become the Master broker
2006-10-18 09:35:08,559 [main           ] INFO  DefaultDatabaseLocker          - Becoming the master on dataSource: org.apache.commons.dbcp.BasicDataSource@136d9d8

The 2nd broker to start up has an identical message and both brokers listen for connections.

The 2nd broker should be waiting for the lock and NOT accepting connections, if I understand http://www.activemq.org/site/jdbc-master-slave.html correctly...

Oracle exhibits the expected behavior:
When running the exact same configuration (except using an Oracle datasource), the first broker has the same log message as above,  while the 2nd broker halts at the ""Attempting to acquire the exclusive lock to become the Master broker"" message until I fail the master.  Then it becomes the master.

Is this a known issue?  I was able to replicate it using both MySql 4 and 5 (trying both the MySQL Connector/J 3.1 and MySQL Connector/J 5.0 drivers)
",Bug
AMQ-1142,12481983,,"Assume a (old legacy, yes this is out of date and better solutions are available) point to point architecture:

Client creates temporary queues and send the queuename to the server by a fixed queue ('command queue')
Server uses the received queue names to send messages to the client.

See the attached Code snippets:

* Start the Server
* Start the Client
* The Client creates a temporary queue and sends the name to the server
* Server receives message and sends a test message back.
* Client NEVER receives the test message

This works 100% on IBM MQSeries (the only source diff is the line that has a MQSerie getQueue API call, instead a createQueue, because queus are defined, and not dynamical as in ActiveMQ)

ActiveMQ LOG information:

The temporary queue is logged, but later it says that there are no subscriptions

(..)
DEBUG AbstractRegion                 - Adding destination: topic://ActiveMQ.Advisory.Consumer.Queue.ID:TIGER-2615-1170064714906-1:0:1
DEBUG JournalPersistenceAdapter      - Checkpoint done.
DEBUG TIGER-2615-1170064714906-1:0:1 - No subscriptions registered, will not dispatch message at this time.
(...)

Can this bug be fixed?

Thank you, Jos

",Bug
AMQ-1338,12482119,,the ActiveMQ is down,Bug
AMQ-1837,12482962,,"We experienced that some messages (send in persistent mode) were lost after the message broker was killed and restarted.
The attached little test simulates the situation:
There are 10 queues, 10 sender and 10 receiver threads each sending / receiving quite frequently to / from one queue for a quite long time.
The receiver for each queue expects the messages exactly in the order the sender has send the messages.
After restarting (killing) the broker the order of the received messages gets disturbed or messages get lost. 

* Start the broker as configures by default in the distribution (only switch on JMX support). 
* Start the main method of the attached class
* Wait until some messages are received
* kill or shutdown the broker
* restart the broker
* have a look at the output of the test class
{code:title=Output}
Exception in ReceiverThread: java.lang.RuntimeException: Received unexpected message! Expected: QUEUE-4: #3197, Received: QUEUE-4: #3267
{code}

{code:title=Broker Output}
...
INFO  BrokerService                  - Using Persistence Adapter: AMQPersistenceAdapter(D:\sandbox\Experimental\Activemq\apache-activemq-5.2-SNAPSHOT\bin\..\data)
INFO  AMQPersistenceAdapter          - AMQStore starting using directory: D:\sandbox\Experimental\Activemq\apache-activemq-5.2-SNAPSHOT\bin\..\data
INFO  KahaStore                      - Kaha Store using data directory D:\sandbox\Experimental\Activemq\apache-activemq-5.2-SNAPSHOT\bin\..\data\kr-store\state
INFO  AMQPersistenceAdapter          - Active data files: []
WARN  AMQPersistenceAdapter          - The ReferenceStore is not valid - recovering ...
INFO  KahaStore                      - Kaha Store successfully deleted data directory D:\sandbox\Experimental\Activemq\apache-activemq-5.2-SNAPSHOT\bin\..\data\kr-store\data
INFO  AMQPersistenceAdapter          - Journal Recovery Started from: DataManager:(data-)
INFO  KahaStore                      - Kaha Store using data directory D:\sandbox\Experimental\Activemq\apache-activemq-5.2-SNAPSHOT\bin\..\data\kr-store\data
INFO  AMQPersistenceAdapter          - Recovered 198261 operations from redo log in 18.028 seconds.
INFO  AMQPersistenceAdapter          - Finished recovering the ReferenceStore
INFO  BrokerService                  - ActiveMQ 5.2-SNAPSHOT JMS Message Broker (localhost) is starting
...
{code}
",Bug
AMQ-3663,12538506,,"When starting ActiveMQ usinf wrapper we get this error repeatedly:

INFO   | jvm 1    | 2011/11/21 20:39:00 | ERROR BrokerService                  - Failed to start ActiveMQ JMS Message Broker. Reason: java.io.IOException: Transport Connector could not be registered in JMX: Failed to bind to server socket: tcp://0.0.0.0:20000 due to: java.net.BindException: Address already in use: JVM_Bind
INFO   | jvm 1    | 2011/11/21 20:39:00 | java.io.IOException: Transport Connector could not be registered in JMX: Failed to bind to server socket: tcp://0.0.0.0:20000 due to: java.net.BindException: Address already in use: JVM_Bind
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:27)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:1434)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.broker.BrokerService.startTransportConnector(BrokerService.java:1893)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.broker.BrokerService.startAllConnectors(BrokerService.java:1844)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.broker.BrokerService.start(BrokerService.java:480)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.xbean.XBeanBrokerService.afterPropertiesSet(XBeanBrokerService.java:52)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1368)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1334)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:473)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$1.run(AbstractAutowireCapableBeanFactory.java:409)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at java.security.AccessController.doPrivileged(Native Method)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:380)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:264)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:261)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:185)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:164)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:429)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:729)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:381)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:64)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:52)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:96)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:52)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.console.command.StartCommand.startBroker(StartCommand.java:115)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:74)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:57)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:129)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:57)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:79)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at java.lang.reflect.Method.invoke(Unknown Source)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.console.Main.runTaskClass(Main.java:225)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.console.Main.main(Main.java:106)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at java.lang.reflect.Method.invoke(Unknown Source)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at java.lang.Thread.run(Unknown Source)
INFO   | jvm 1    | 2011/11/21 20:39:00 | Caused by: java.io.IOException: Failed to bind to server socket: tcp://0.0.0.0:20000 due to: java.net.BindException: Address already in use: JVM_Bind
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:33)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:141)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.transport.tcp.TcpTransportFactory.doBind(TcpTransportFactory.java:60)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.transport.TransportFactory.bind(TransportFactory.java:131)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.broker.TransportConnector.createTransportServer(TransportConnector.java:293)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.broker.TransportConnector.getServer(TransportConnector.java:135)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.broker.TransportConnector.asManagedConnector(TransportConnector.java:98)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:1428)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	... 42 more
INFO   | jvm 1    | 2011/11/21 20:39:00 | Caused by: java.net.BindException: Address already in use: JVM_Bind
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at java.net.PlainSocketImpl.socketBind(Native Method)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at java.net.PlainSocketImpl.bind(Unknown Source)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at java.net.ServerSocket.bind(Unknown Source)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at java.net.ServerSocket.<init>(Unknown Source)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at javax.net.DefaultServerSocketFactory.createServerSocket(Unknown Source)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	at org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:136)
INFO   | jvm 1    | 2011/11/21 20:39:00 | 	... 48 more
INFO  ",Bug
AMQ-2137,12482824,,"We were using default AMQ configuration with stomp protocol for a long time without any problems. However, recently we change the derby db to mysql database due to our large message sizes. This set up worked without any problems in our test environments but in our production system AMQ is crashing after a while with follwoing errors:
Exception in thread ""ActiveMQ Connection Dispatcher: /127.0.0.1:41723"" java.lang.OutOfMemoryError: Java heap space
        at java.lang.StringCoding$CharsetSE.encode(StringCoding.java:334)
        at java.lang.StringCoding.encode(StringCoding.java:378)
        at java.lang.String.getBytes(String.java:812)
        at org.apache.activemq.transport.stomp.LegacyFrameTranslator.convertMessage(LegacyFrameTranslator.java:69)
        at org.apache.activemq.transport.stomp.ProtocolConverter.convertMessage(ProtocolConverter.java:582)
        at org.apache.activemq.transport.stomp.StompSubscription.onMessageDispatch(StompSubscription.java:89)
        at org.apache.activemq.transport.stomp.ProtocolConverter.onActiveMQCommad(ProtocolConverter.java:564)
        at org.apache.activemq.transport.stomp.StompTransportFilter.oneway(StompTransportFilter.java:56)
        at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:40)
        at org.apache.activemq.broker.TransportConnection.dispatch(TransportConnection.java:1207)
        at org.apache.activemq.broker.TransportConnection.processDispatch(TransportConnection.java:793)
        at org.apache.activemq.broker.TransportConnection.iterate(TransportConnection.java:830)
        at org.apache.activemq.thread.DedicatedTaskRunner.runTask(DedicatedTaskRunner.java:98)
        at org.apache.activemq.thread.DedicatedTaskRunner$1.run(DedicatedTaskRunner.java:36)
...

after 3 messages like this then you'll see this

Exception in thread ""ActiveMQ Connection Dispatcher: /127.0.0.1:41934"" java.lang.OutOfMemoryError: Java heap space
Exception in thread ""ActiveMQ Connection Dispatcher: /127.0.0.1:41942"" java.lang.OutOfMemoryError: Java heap space
Exception in thread ""ActiveMQ Connection Dispatcher: /127.0.0.1:48968"" java.lang.OutOfMemoryError: Java heap space
Exception in thread ""ActiveMQ Connection Dispatcher: /127.0.0.1:48975"" java.lang.OutOfMemoryError: Java heap space
Exception in thread ""ActiveMQ Connection Dispatcher: /127.0.0.1:48978"" java.lang.OutOfMemoryError: Java heap space
Exception in thread ""ActiveMQ Connection Dispatcher: /127.0.0.1:40242"" java.lang.OutOfMemoryError: Java heap space
Exception in thread ""ActiveMQ Connection Dispatcher: /127.0.0.1:40245"" java.lang.OutOfMemoryError: Java heap space
...


In another attempt we got these messages:
Exception in thread ""ActiveMQ Connection Dispatcher: /127.0.0.1:50574"" java.lang.OutOfMemoryError: Java heap space
        at java.lang.StringCoding$CharsetSE.encode(StringCoding.java:334)
        at java.lang.StringCoding.encode(StringCoding.java:378)
        at java.lang.String.getBytes(String.java:812)
        at org.apache.activemq.transport.stomp.LegacyFrameTranslator.convertMessage(LegacyFrameTranslator.java:69)
        at org.apache.activemq.transport.stomp.ProtocolConverter.convertMessage(ProtocolConverter.java:582)
        at org.apache.activemq.transport.stomp.StompSubscription.onMessageDispatch(StompSubscription.java:89)
        at org.apache.activemq.transport.stomp.ProtocolConverter.onActiveMQCommad(ProtocolConverter.java:564)
        at org.apache.activemq.transport.stomp.StompTransportFilter.oneway(StompTransportFilter.java:56)
        at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:40)
        at org.apache.activemq.broker.TransportConnection.dispatch(TransportConnection.java:1207)
        at org.apache.activemq.broker.TransportConnection.processDispatch(TransportConnection.java:793)
        at org.apache.activemq.broker.TransportConnection.iterate(TransportConnection.java:830)
        at org.apache.activemq.thread.DedicatedTaskRunner.runTask(DedicatedTaskRunner.java:98)
        at org.apache.activemq.thread.DedicatedTaskRunner$1.run(DedicatedTaskRunner.java:36)
ERROR log                            - Nested in javax.servlet.ServletException: java.lang.OutOfMemoryError: Java heap space:
java.lang.OutOfMemoryError: Java heap space
        at java.lang.AbstractStringBuilder.expandCapacity(AbstractStringBuilder.java:99)
        at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:393)
        at java.lang.StringBuffer.append(StringBuffer.java:225)
        at java.lang.StringBuffer.append(StringBuffer.java:285)
        at java.util.regex.Matcher.appendReplacement(Matcher.java:739)
        at java.util.regex.Matcher.replaceAll(Matcher.java:806)
        at java.lang.String.replaceAll(String.java:2000)
        at org.apache.jsp.tag.web.form.tooltip_tag.doTag(org.apache.jsp.tag.web.form.tooltip_tag:75)
        at org.apache.jsp.message_jsp._jspx_meth_form_tooltip_1(org.apache.jsp.message_jsp:490)
        at org.apache.jsp.message_jsp._jspx_meth_c_otherwise_0(org.apache.jsp.message_jsp:341)
        at org.apache.jsp.message_jsp._jspx_meth_c_choose_0(org.apache.jsp.message_jsp:157)
        at org.apache.jsp.message_jsp._jspService(org.apache.jsp.message_jsp:99)
        at org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:93)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:806)
        at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:373)
        at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:470)
        at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:364)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:806)
        at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:487)
        at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1093)
        at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:83)
        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76)
        at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1084)
        at org.apache.activemq.web.SessionFilter.doFilter(SessionFilter.java:43)
        at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1084)
        at org.apache.activemq.web.filter.ApplicationContextFilter.doFilter(ApplicationContextFilter.java:81)
        at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1084)
        at com.opensymphony.module.sitemesh.filter.PageFilter.parsePage(PageFilter.java:118)
        at com.opensymphony.module.sitemesh.filter.PageFilter.doFilter(PageFilter.java:52)
        at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1084)
        at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:360)
        at org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216)
ERROR log                            - /admin/message.jsp

",Bug
AMQ-2500,12483169,,"The following test-programm reads and writes messages into the same queue (testQueue). After Reading several messages the class starts two threads that are writing messages in the same queue. After writing several messages the producer hangs on:

producer.send()

and doesn't recover even if the reader continues reading messages from the queue. Even stopping the clients (via kill) doesn't change the broker's behaviour. In this state further connections opened from other clients hang on the same method call (producer.send()). The client's connections will remain open as you can see in the jconsole-screenshot, that has been taken after the producer in the example hung. Althogh the consumer may continue reading new producer can only continue writing messages into the queue after activeMQ has been restarted. 

The following two snippets show the difference between the first (127.0.0.1:49372) and the second (127.0.0.1:49385) message producer: The first producer works as expected and adds it's messages to the queue. The second producer stops with the following log-entry: 2009-11-13 09:41:45,639 [127.0.0.1:49385] DEBUG AbstractRegion                 - Adding consumer: ID:JoergsPC-49370-1258101701975-0:14:-1:1

...
2009-11-13 09:41:42,376 [eue://testQueue] DEBUG Queue                          - queue://testQueue - Recovery - Message pushed '21290107 - Message ID:JoergsPC-50687-1258047095293-0:2810:1:1:1 dropped=false locked=false' to subscription: 'QueueSubscription: consumer=ID:JoergsPC-49370-1258101701975-0:0:1:1, destinations=1, dispatched=197, delivered=0, pending=0'
2009-11-13 09:41:42,376 [eue://testQueue] DEBUG Queue                          - queue://testQueue - Recovery - Message pushed '31931917 - Message ID:JoergsPC-50687-1258047095293-0:2811:1:1:1 dropped=false locked=false' to subscription: 'QueueSubscription: consumer=ID:JoergsPC-49370-1258101701975-0:0:1:1, destinations=1, dispatched=198, delivered=0, pending=0'
2009-11-13 09:41:42,376 [eue://testQueue] DEBUG Queue                          - queue://testQueue - Recovery - Message pushed '10144386 - Message ID:JoergsPC-50687-1258047095293-0:2812:1:1:1 dropped=false locked=false' to subscription: 'QueueSubscription: consumer=ID:JoergsPC-49370-1258101701975-0:0:1:1, destinations=1, dispatched=199, delivered=0, pending=0'
2009-11-13 09:41:42,381 [127.0.0.1:49372] DEBUG WireFormatNegotiator           - Received WireFormat: WireFormatInfo { version=3, properties={CacheSize=1024, CacheEnabled=true, SizePrefixDisabled=false, MaxInactivityDurationInitalDelay=10000, TcpNoDelayEnabled=true, MaxInactivityDuration=30000, TightEncodingEnabled=true, StackTraceEnabled=true}, magic=[A,c,t,i,v,e,M,Q]}
2009-11-13 09:41:42,381 [127.0.0.1:49372] DEBUG WireFormatNegotiator           - Sending: WireFormatInfo { version=3, properties={CacheSize=1024, CacheEnabled=true, SizePrefixDisabled=false, MaxInactivityDurationInitalDelay=10000, TcpNoDelayEnabled=true, MaxInactivityDuration=30000, TightEncodingEnabled=true, StackTraceEnabled=true}, magic=[A,c,t,i,v,e,M,Q]}
2009-11-13 09:41:42,382 [127.0.0.1:49372] DEBUG WireFormatNegotiator           - tcp:///127.0.0.1:49372 before negotiation: OpenWireFormat{version=3, cacheEnabled=false, stackTraceEnabled=false, tightEncodingEnabled=false, sizePrefixDisabled=false}
2009-11-13 09:41:42,394 [127.0.0.1:49372] DEBUG WireFormatNegotiator           - tcp:///127.0.0.1:49372 after negotiation: OpenWireFormat{version=3, cacheEnabled=true, stackTraceEnabled=true, tightEncodingEnabled=true, sizePrefixDisabled=false}
2009-11-13 09:41:42,395 [127.0.0.1:49372] DEBUG TransportConnection            - Setting up new connection: /127.0.0.1:49372
2009-11-13 09:41:42,409 [127.0.0.1:49372] DEBUG AbstractRegion                 - Adding consumer: ID:JoergsPC-49370-1258101701975-0:1:-1:1
2009-11-13 09:41:42,414 [127.0.0.1:49372] DEBUG AbstractRegion                 - Adding destination: topic://ActiveMQ.Advisory.Producer.Queue.testQueue
2009-11-13 09:41:42,416 [127.0.0.1:49372] DEBUG AMQMessageStore                - Journalled message add for: ID:JoergsPC-49370-1258101701975-0:1:1:1:1, at: offset = 10684963, file = 4, size = 270, type = 1
2009-11-13 09:41:42,416 [eue://testQueue] DEBUG AMQMessageStore                - Doing batch update... adding: 1 removing: 0 
2009-11-13 09:41:42,417 [eue://testQueue] DEBUG AMQMessageStore                - Batch update done.
2009-11-13 09:41:42,418 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 7, to: 8
2009-11-13 09:41:42,418 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 1, to: 2
2009-11-13 09:41:42,425 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 8, to: 9
2009-11-13 09:41:42,433 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 9, to: 10
2009-11-13 09:41:42,440 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 10, to: 11
2009-11-13 09:41:42,470 [127.0.0.1:49371] DEBUG AbstractRegion                 - Removing consumer: ID:JoergsPC-49370-1258101701975-0:0:1:1
2009-11-13 09:41:42,474 [127.0.0.1:49371] DEBUG AMQMessageStore                - flush starting ...
2009-11-13 09:41:42,474 [127.0.0.1:49371] DEBUG AbstractRegion                 - Removing consumer: ID:JoergsPC-49370-1258101701975-0:0:-1:1
2009-11-13 09:41:42,477 [127.0.0.1:49371] DEBUG TransportConnection            - Stopping connection: /127.0.0.1:49371
...


...
2009-11-13 09:41:45,319 [eue://testQueue] DEBUG Queue                          - queue://testQueue - Recovery - Message pushed '21569784 - Message ID:JoergsPC-50687-1258047095293-0:3422:1:1:1 dropped=false locked=false' to subscription: 'QueueSubscription: consumer=ID:JoergsPC-49370-1258101701975-0:13:1:1, destinations=1, dispatched=797, delivered=0, pending=0'
2009-11-13 09:41:45,320 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 181, to: 182
2009-11-13 09:41:45,327 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 182, to: 183
2009-11-13 09:41:45,331 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 183, to: 184
2009-11-13 09:41:45,332 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 45, to: 46
2009-11-13 09:41:45,338 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 184, to: 185
2009-11-13 09:41:45,344 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 185, to: 186
2009-11-13 09:41:45,349 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 186, to: 187
2009-11-13 09:41:45,356 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 187, to: 188
2009-11-13 09:41:45,356 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 46, to: 47
2009-11-13 09:41:45,442 [127.0.0.1:49384] DEBUG AbstractRegion                 - Removing consumer: ID:JoergsPC-49370-1258101701975-0:13:1:1
2009-11-13 09:41:45,445 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 188, to: 189
2009-11-13 09:41:45,443 [127.0.0.1:49372] DEBUG AbstractRegion                 - Removing consumer: ID:JoergsPC-49370-1258101701975-0:1:-1:1
2009-11-13 09:41:45,632 [127.0.0.1:49372] DEBUG TransportConnection            - Stopping connection: /127.0.0.1:49372
2009-11-13 09:41:45,632 [127.0.0.1:49372] DEBUG TcpTransport                   - Stopping transport tcp:///127.0.0.1:49372
2009-11-13 09:41:45,632 [127.0.0.1:49372] DEBUG TransportConnection            - Stopped transport: /127.0.0.1:49372
2009-11-13 09:41:45,632 [127.0.0.1:49372] DEBUG TransportConnection            - Connection Stopped: /127.0.0.1:49372
2009-11-13 09:41:45,636 [127.0.0.1:49385] DEBUG WireFormatNegotiator           - Sending: WireFormatInfo { version=3, properties={CacheSize=1024, CacheEnabled=true, SizePrefixDisabled=false, MaxInactivityDurationInitalDelay=10000, TcpNoDelayEnabled=true, MaxInactivityDuration=30000, TightEncodingEnabled=true, StackTraceEnabled=true}, magic=[A,c,t,i,v,e,M,Q]}
2009-11-13 09:41:45,638 [127.0.0.1:49385] DEBUG WireFormatNegotiator           - Received WireFormat: WireFormatInfo { version=3, properties={CacheSize=1024, CacheEnabled=true, SizePrefixDisabled=false, MaxInactivityDurationInitalDelay=10000, TcpNoDelayEnabled=true, MaxInactivityDuration=30000, TightEncodingEnabled=true, StackTraceEnabled=true}, magic=[A,c,t,i,v,e,M,Q]}
2009-11-13 09:41:45,638 [127.0.0.1:49385] DEBUG WireFormatNegotiator           - tcp:///127.0.0.1:49385 before negotiation: OpenWireFormat{version=3, cacheEnabled=false, stackTraceEnabled=false, tightEncodingEnabled=false, sizePrefixDisabled=false}
2009-11-13 09:41:45,638 [127.0.0.1:49385] DEBUG WireFormatNegotiator           - tcp:///127.0.0.1:49385 after negotiation: OpenWireFormat{version=3, cacheEnabled=true, stackTraceEnabled=true, tightEncodingEnabled=true, sizePrefixDisabled=false}
2009-11-13 09:41:45,638 [127.0.0.1:49385] DEBUG TransportConnection            - Setting up new connection: /127.0.0.1:49385
2009-11-13 09:41:45,639 [127.0.0.1:49385] DEBUG AbstractRegion                 - Adding consumer: ID:JoergsPC-49370-1258101701975-0:14:-1:1
2009-11-13 09:41:45,641 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 189, to: 190
2009-11-13 09:41:45,647 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 190, to: 191
2009-11-13 09:41:45,653 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 191, to: 192
2009-11-13 09:41:45,653 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 47, to: 48
2009-11-13 09:41:45,658 [eue://testQueue] DEBUG Usage                          - Memory usage change.  from: 192, to: 193
2009-11-13 09:41:45,663 [127.0.0.1:49384] DEBUG Usage                          - Memory usage change.  from: 193, to: 192
2009-11-13 09:41:45,663 [127.0.0.1:49384] DEBUG Usage                          - Memory usage change.  from: 192, to: 191
2009-11-13 09:41:45,663 [127.0.0.1:49384] DEBUG Usage                          - Memory usage change.  from: 48, to: 47
2009-11-13 09:41:45,663 [127.0.0.1:49384] DEBUG Usage                          - Memory usage change.  from: 191, to: 190
2009-11-13 09:41:45,664 [127.0.0.1:49384] DEBUG Usage                          - Memory usage change.  from: 190, to: 189
2009-11-13 09:41:45,664 [127.0.0.1:49384] DEBUG AMQMessageStore                - flush starting ...
2009-11-13 09:41:45,664 [127.0.0.1:49384] DEBUG AbstractRegion                 - Removing consumer: ID:JoergsPC-49370-1258101701975-0:13:-1:1
2009-11-13 09:41:45,665 [127.0.0.1:49384] DEBUG TransportConnection            - Stopping connection: /127.0.0.1:49384
...


",Bug
AMQ-2401,12482929,,"While running performance tests I I was seeing hangs in several tests  involving dups ok queue receivers. My suspicion is that this is related to ""too lazy"" dups_ok acknowledgements. Changing the queue prefetchLimit to 100 caused this problem to go away. This needs more investigation, but it seems like we can get ourselves in to trouble if the queue size is smaller than the receiver's prefetchLimit, and this should be avoid. It is also possible that there is something more complicated happening in my tests. I haven't yet been able to reproduce this outside my performance test environment. 
",Bug
AMQ-3460,12519303,,"We experience the following problem.

There's 1 sender thread and 20 listener threads operating on the same queue.
No other queues are involved.

Message traffic goes generally OK via the queue, however Number of pending messages goes up one by one.

Looking at the active customers list, the following appears (see attached screenshot).
For all sessions but two, the messages are dispatched properly.
For these two affected sessions, the ""Dispatched Queue"" value gots stuck at certain moment and doesn't deliver anymore.

Eventually, more sessions got affected, and maybe after some hours, the stuck messages got delivered.

What we tried - adding useCache=""false"" into <policyEntry queue="">"" ... > tag. Didn't have any effect.

",Bug
AMQ-3016,12483820,,"Symptom
========
I set up two Brokers and a network bridge from Broker A to Broker B over HTTP.  When the bridge is established, each Broker has a single transport connection (VM on broker A and HTTP on broker B) as recorded in RegionBroker.connections

I noticed that when Broker A was stopped (normally), periodically the HTTP connection would remain in Broker B's RegionBroker.connections until the InactivityMonitor on the connection timed out.  If the InactivityMonitor was disbled, then the connection would remain indefinitely.  

If Broker A was restarted, the bridge would be restarted and a second connection would be recorded in Broker B's RegionBroker.connections.  Repeating restarts of Broker A would cause an accumulation of ""dead"" connections, which would eventually lead to an OOM.

Cause
=====
When Broker A is stopped, DemandForwardingBridgeSupport.stop() is called and sends a ShutdownInfo command to the local and remote transports.  When the transports receive the ShutdownInfo, they remove the connection from their associated RegionBroker.connections as part of  TransportConnection.processRemoveConnection(ConnectionId, long):

    public synchronized Response processRemoveConnection(ConnectionId id, long lastDeliveredSequenceId)
            throws InterruptedException {
...
            try {
                broker.removeConnection(cs.getContext(), cs.getInfo(), null);
            } catch (Throwable e) {
                SERVICELOG.warn(""Failed to remove connection "" + cs.getInfo(), e);
            }

In the cases were Broker B would not clean up its connection, I traced the code and discovered that the ShutdownInfo message was not being sent because the remote transport (HttpClientTransport) had already had its ""stopped"" flag set to true as part of HttpClientTransport.oneway(Object command):

    public void oneway(Object command) throws IOException {

        if (isStopped()) {
            throw new IOException(""stopped."");
        }
...

DemandForwardingBridgeSupport's stop() method has the following code:

    public void stop() throws Exception {
...
                    ASYNC_TASKS.execute(new Runnable() {
                        public void run() {
                            try {
                                localBroker.oneway(new ShutdownInfo());
                                sendShutdown.countDown();
                                remoteBroker.oneway(new ShutdownInfo());
                            } catch (Throwable e) {
                                LOG.debug(""Caught exception sending shutdown"", e);
                            } finally {
                                sendShutdown.countDown();
                            }
                        }
                    });
                    if (!sendShutdown.await(10, TimeUnit.SECONDS)) {
                        LOG.info(""Network Could not shutdown in a timely manner"");
                    }
                } finally {
                    ServiceStopper ss = new ServiceStopper();
                    ss.stop(remoteBroker);
                    ss.stop(localBroker);
                    // Release the started Latch since another thread could be
                    // stuck waiting for it to start up.
                    startedLatch.countDown();
                    startedLatch.countDown();
                    localStartedLatch.countDown();
                    ss.throwFirstException();
                }
            }

ShutdownInfo is sent asynchronously to the local and remote transports by a slave thread:

                                localBroker.oneway(new ShutdownInfo());
                                sendShutdown.countDown();
                                remoteBroker.oneway(new ShutdownInfo());

The sendShutdown  latch is used by the master thread to prevent running the finally clause until the ShutdownInfo has been sent:

                    if (!sendShutdown.await(10, TimeUnit.SECONDS)) {
                        LOG.info(""Network Could not shutdown in a timely manner"");
                    }
                } finally {
                    ServiceStopper ss = new ServiceStopper();
                    ss.stop(remoteBroker);
                    ss.stop(localBroker);
...
                }
            }

However, because the latch is countdown *before* remoteTransport.oneway(new ShutdownInfo()) there is a race condition and in most cases the main thread calls ss.stop(remoteBroker) before the slave thread has completed its call to remoteTransport.oneway(new ShutdownInfo()).  As a result, the remoteTransport appears already stopped and the ShutdownInfo is discarded.  This leaves the connection dangling on the remote broker until the InactivityMonitor closes it.

Solution
======
The sendShutdown latch should be countdown *after* remoteTransport.oneway(new ShutdownInfo()).
",Bug
AMQ-3157,12496720,,"When using the garbage collection feature of inactive queues, the queues are not collected if queue mirroring is turned on.  The following snippet shows a basic configuration for reproducing the problem:

{code:xml}
<broker xmlns=""http://activemq.apache.org/schema/core""
          brokerName=""localhost""
          dataDirectory=""${activemq.base}/data""
          destroyApplicationContextOnStop=""true""
          schedulePeriodForDestinationPurge=""10000"">

        <destinationInterceptors>
            <mirroredQueue copyMessage=""true"" postfix="""" prefix=""Monitor.""/>
        </destinationInterceptors>

        <destinationPolicy>
            <policyMap>
                <policyEntries>
                    <!-- Set auto-cleanup of inactive topics and queues -->
                    <policyEntry queue="">"" producerFlowControl=""true"" memoryLimit=""50mb"" gcInactiveDestinations=""true"" inactiveTimoutBeforeGC=""30000"">
                        <pendingQueuePolicy>
                            <vmQueueCursor/>
                        </pendingQueuePolicy>
                    </policyEntry>
                    <policyEntry topic="">"" producerFlowControl=""true"" memoryLimit=""50mb"" gcInactiveDestinations=""true"" inactiveTimoutBeforeGC=""30000"">
                        <pendingSubscriberPolicy>
                            <vmCursor />
                        </pendingSubscriberPolicy>
                    </policyEntry>
                </policyEntries>
            </policyMap>
        </destinationPolicy>
</broker>
{code}

With this configuration, the topics will be collected, but the queues will not be collected.  In order to get the queues to be collected, the {{<destinationInterceptors>}} section needs to be commented out.",Bug
AMQ-5376,12745194,,"Hi,

I'm getting a Rollback Transaction exception when the message is trying to write to KahaDB. The exception happens from client is as below

javax.jms.InvalidDestinationException: Cannot publish to a deleted Destination:

I wrote a small application to probe JMX to get temp-queue in every seconds. I notice the temp-queue was living there for almost 5 minutes. The rollback happens after the 2 minutes after the temp-queue was been created. When it retry it, the message successfully went thru.

Is this is because of KahaDB issues what has concurrent thread being write ? 

Please advice.
",Bug
AMQ-3598,12531481,,"A consumer can receive messages from protected queues/topics if he uses a Destination which contains a wildcard as described [here|http://activemq.apache.org/wildcards.html]:

{code:language=java}
Destination queue = new ActiveMQQueue(""messages.>"");
Destination topic = new ActiveMQTopic("">"");
{code}

We are using the default authentication/authorization system as described in [Security Authentication/Authorization|http://activemq.apache.org/security.html#Security-Authorization] with the following configuration:

{code:title=broker.xml|language=xml}
<plugins>
    <simpleAuthenticationPlugin>
        <users>
            <authenticationUser
                  username=""admin""
                  password=""admin""
                  groups=""admins""/>
            <authenticationUser
                  username=""user""
                  password=""user""
                  groups=""users""/>
        </users>
    </simpleAuthenticationPlugin>
    <authorizationPlugin>
        <map>
            <authorizationMap>
                <authorizationEntries>
                    <authorizationEntry topic=""messages.>""
                                        read=""admins""
                                        write=""admins""
                                        admin=""admins""/>
                    <authorizationEntry topic=""messages.cat2""
                                        read=""admins""
                                        write=""admins""
                                        admin=""admins""/>
                    <authorizationEntry topic=""messages.cat1""
                                        read=""admins, users""
                                        write=""admins, users""
                                        admin=""admins, users""/>
                    <authorizationEntry topic=""ActiveMQ.Advisory.>""
                                        read=""admins, users""
                                        write=""admins, users""
                                        admin=""admins, users""/>
                </authorizationEntries>
            </authorizationMap>
        </map>
    </authorizationPlugin>
</plugins>
{code}

As exepected, clients connecting as ""user"" to the topic ""messages.cat2"" get an exception (""User user is not authorized to read from: topic://messages.cat2""). Suprisingly ""user"" can receive messages from topic ""messages.cat2"" if he creates a consumer with the destination ""messages.>"":

{code:title=consumer.java|language=java}
final Destination destination = new ActiveMQTopic(""messages.>"");
final Connection conn = new ActiveMQConnectionFactory(""user"", ""user"", BROKER_URL).createConnection();
final Session session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);
final MessageConsumer consumer = session.createConsumer(destination);
conn.start();
closure.run();
final Message message = consumer.receive(TIMEOUT);
session.close();
conn.close(); 
{code}

IMHO this behaviour is a security problem as an unprivileged user can receive messages from a protected topic or queue!",Bug
AMQ-3536,12526689,,"Summary: 
Transactional Acknowledgement with Virtual Topic / Subscriber Queues does not indicate which subscriber had a problem consuming the messages. Messages are simply delivered to Topic specific DLQ rather than to the Subscriber/Consumer specific DLQ.

Steps to create issue:

Configure the Individual Dead Letter Queue policy in Fuse Message Broker. 
Next create an ActiveMQ Virtual Topic with Subscriber Queue(s).
Send messages to Virtual Topic
Rollback/abort ack for one message (consistently) until this message gets delivered to the dead letter queue.

Result:
Message is sent to the Topic Specific Dead Letter Queue rather than to the DLQ specific to the Subscriber Queue.


Resolution:
Patch and unit test are are attached.
This test verifies that all undelivered messages sent to a consumers listening on a queue associated with a virtual topic with be forwarded to separate DLQ's.

Note that the broker config, Individual Dead Letter Strategy, needs to have the enable audit set to false to allows duplicate messages sent from a topic to individual consumers to be forwarded to the DLQ's.
  
<deadLetterStrategy>
	<bean xmlns=""http://www.springframework.org/schema/beans"" class=""org.apache.activemq.broker.region.policy.IndividualDeadLetterStrategy"">
        	<property name=""useQueueForQueueMessages"" value=""true""></property>
                <property name=""processNonPersistent"" value=""true""></property>
                <property name=""processExpired"" value=""false""></property>
                <property name=""enableAudit"" value=""false""></property>
        </bean>
</deadLetterStrategy>
		

",Bug
AMQ-3537,12526717,,"When the ActiveMQ client attempts to unpack an ObjectMessage that contains a proxy with a mix of JDK and non-JDK interfaces the ClassLoadingAwareObjectInputStream chooses ONLY the ClassLoader from  the first interface in the array of interfaces represented by the proxy.  This means that if a proxy's first interface is a JDK class (java.util.List, java.sql.Blob) the core ClassLoader is used.  In the event that a non-JDK interface is present in the list of proxied interfaces the same core ClassLoader is used.  The Proxy.getProxyClass subsequently throws an IllegalArgumentException because the non-JDK interface class cannot be loaded by the core ClassLoader.

This problem is extant during deserialization of an ObjectMessage payload that contains a proxy that implements [java.sql.Blob, org.hibernate.engine.jdbc.WrappedBlob, java.io.Serializable] (a blob proxy created by [hibernate SerializableBlobProxy|https://github.com/hibernate/hibernate-core/blob/3.6.7.Final/hibernate-core/src/main/java/org/hibernate/engine/jdbc/SerializableBlobProxy.java]).   The impact of this bug is that users of Hibernate cannot use ActiveMQ as a messaging framework if they need to package ValueObjects that have mapped lobs.  ",Bug
AMQ-4249,12627290,,"h1. Problem

While setting up a connection pool towards ActiveMq 5.5.1 using Bitronix 2.1.3 I've been having some issues related to authentication and authorization of the JMS connections.

When doing a clean restart of the JMS-clients JVM the connection pool has been unable to connect successfully with one or more of the 14 connections it's been set up to use.

The error messages I've been getting has usually been one of the following two:

# User system is not authorized to read from: ActiveMQ.Advisory.TempQueue,ActiveMQ.Advisory.TempTopic
# User name or password is invalid.

The broker has been set up using a very simplistic configuration:
{code:xml}
<?xml version=""1.0"" encoding=""UTF-8""?>
<beans xmlns=""http://www.springframework.org/schema/beans""
	xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns:context=""http://www.springframework.org/schema/context""

	xsi:schemaLocation=""http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core-5.5.0.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"">
	<context:property-placeholder />

	<broker brokerId=""localhost"" xmlns=""http://activemq.apache.org/schema/core""
		dataDirectory=""${datadir}"" start=""false"">
		<managementContext>
			<managementContext connectorHost=""0.0.0.0""
				connectorPort=""14522"" createConnector=""true"" />
		</managementContext>
		<plugins>
			<jaasAuthenticationPlugin configuration=""activemq-domain""
				discoverLoginConfig=""true"" />
			<authorizationPlugin>
				<map>
					<authorizationMap>
						<authorizationEntries>
							<authorizationEntry queue="">"" read=""admins""
								write=""admins"" admin=""admins"" />

							<authorizationEntry topic="">"" read=""admins""
								write=""admins"" admin=""admins"" />

							<authorizationEntry topic=""ActiveMQ.Advisory.>""
								read=""guests,users"" write=""guests,users"" admin=""guests,users"" />
						</authorizationEntries>
					</authorizationMap>
				</map>
			</authorizationPlugin>
		</plugins>
		<transportConnectors>
			<transportConnector id=""openwire"" uri=""tcp://0.0.0.0:61616?trace=true"" />
		</transportConnectors>
	</broker>
</beans>
{code}

The JAAS-configuration has been verified to match username and password used by the client when connecting (username = system):

h4. login.config

{code}
activemq-domain {
    org.apache.activemq.jaas.PropertiesLoginModule required
        debug=false
        org.apache.activemq.jaas.properties.user=""users.properties""
        org.apache.activemq.jaas.properties.group=""groups.properties"";
};
{code}

h4.users.properties

{code}
system=manager
user=password
guest=password
{code}

h4. groups.properties
{code}
admins=system
users=user
guests=guest
{code}

h1. Cause

After debugging the problem it seems as if the problem is caused by a race condition introduced in PropertiesLoginModule in revision [1086219|https://fisheye6.atlassian.com/changelog/activemq?showid=1086219] (AMQ-3244). When the reload-support was added the users- and groups-fields were changed into static fields. But no additional synchronization was introduced, thereby introducing a race condition when several threads are entering the initialize- and commit-methods are the same time.

The following section of the initialize-method in PropertiesLoginModule contains the first part of the race condition. Please note the unsynchronized modification of both the users- and groups static fields:

{code:java}
        if (reload || users == null || uf.lastModified() > usersReloadTime) {
            if (debug) {
                LOG.debug(""Reloading users from "" + uf.getAbsolutePath());
            }
            try {
                users = new Properties(); // XXX Here be dragons
                java.io.FileInputStream in = new java.io.FileInputStream(uf);
                users.load(in);
                in.close();
                usersReloadTime = System.currentTimeMillis();
            } catch (IOException ioe) {
                LOG.warn(""Unable to load user properties file "" + uf);
            }
        }

        groupsFile = (String) options.get(GROUP_FILE) + """";
        File gf = baseDir != null ? new File(baseDir, groupsFile) : new File(groupsFile);
        if (reload || groups == null || gf.lastModified() > groupsReloadTime) {
            if (debug) {
                LOG.debug(""Reloading groups from "" + gf.getAbsolutePath());
            }
            try {
                groups = new Properties(); // XXX Here be dragons
                java.io.FileInputStream in = new java.io.FileInputStream(gf);
                groups.load(in);
                in.close();
                groupsReloadTime = System.currentTimeMillis();
            } catch (IOException ioe) {
                LOG.warn(""Unable to load group properties file "" + gf);
            }
        }
{code}

The next part comes in the login-method when the users password is retrieved:

{code:java}
        String password = users.getProperty(user); 
{code}

The final part of the puzzle occurs in the commit-method:
{code:java}
            for (Enumeration<?> enumeration = groups.keys(); enumeration.hasMoreElements();) {
                String name = (String)enumeration.nextElement();
                String[] userList = ((String)groups.getProperty(name) + """").split("","");
                for (int i = 0; i < userList.length; i++) {
                    if (user.equals(userList[i])) {
                        principals.add(new GroupPrincipal(name));
                        break;
                    }
                }
            }
{code}

The retrieval of the user password will fail if invoked by a thread immediately after a different thread has assigned an empty Properties-object to the users field in the initialize-method.

Similarly population of the GroupPrincipals into the Subject in the commit-method will silently fail if executed by a thread immediately after a different thread has assigned an empty Properties-object to the groups-field in the initialize-method.

h1. Proposed solution

I've created a testcase that reproduces the problem and an additional patch that introduces a wrapper around the Properties-objects for the users- and groups-fields.

The testcase and the proposed solution is available via https://github.com/lothor/activemq.",Bug
AMQ-3803,12549737,,"WebSphere 8 includes values other than Strings in the Hashtable provided to configure the external initial context factory when setting up a Generic JMS Provider.

The org.apache.activemq.jndi.AcuityActiveMQWASInitialContextFactory class does not anticipate non-string values in the Hashtable and throws a ClassCastException.

Key: osgi.service.jndi.bundleContext (String)
Value: com.ibm.osgi.jndi.fep.GatewayBundleContextProxy",Bug
AMQ-3715,12542419,,"According to the documentation [1], the activemq-all.jar should contain all required libraries.  However when running a sample project the following error occurs:

java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.mojo.exec.ExecJavaMojo$1.run(ExecJavaMojo.java:297)
	at java.lang.Thread.run(Thread.java:680)
Caused by: java.lang.NoClassDefFoundError: org/slf4j/impl/StaticLoggerBinder
	at org.slf4j.LoggerFactory.getSingleton(LoggerFactory.java:230)
	at org.slf4j.LoggerFactory.bind(LoggerFactory.java:121)
	at org.slf4j.LoggerFactory.performInitialization(LoggerFactory.java:112)
	at org.slf4j.LoggerFactory.getILoggerFactory(LoggerFactory.java:275)
	at org.slf4j.LoggerFactory.getLogger(LoggerFactory.java:248)
	at org.slf4j.LoggerFactory.getLogger(LoggerFactory.java:261)
	at org.apache.activemq.ActiveMQPrefetchPolicy.<clinit>(ActiveMQPrefetchPolicy.java:38)
	at org.apache.activemq.ActiveMQConnectionFactory.<init>(ActiveMQConnectionFactory.java:88)
	at org.apache.activemq.ActiveMQConnectionFactory.<init>(ActiveMQConnectionFactory.java:131)
	at com.fusesource.example.Producer.<init>(Producer.java:25)
	at com.fusesource.example.DEV3783.main(DEV3783.java:47)
	... 6 more
Caused by: java.lang.ClassNotFoundException: org.slf4j.impl.StaticLoggerBinder
	at java.net.URLClassLoader$1.run(URLClassLoader.java:202)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
	... 17 more

[1] http://activemq.apache.org/initial-configuration.html",Bug
AMQ-3865,12558461,,"The tests do index of comparison of ""foo\n"" where on windows you'd need to do ""foo\r\n"".  I don't think the line endings are really significant to test.  

If they are then I can change the test over to check the operating system and add carriage returns if necessary.  ",Bug
AMQ-4469,12642269,,The test case demonstrates that you can create even more connections than the maximum size.,Bug
AMQ-4158,12614565,,"BTreeIndexTest hangs when run on windows because it repeatedly tries to create/delete the same directory, which is problematic on windows.  I've attached a patch which just adds a timestamp to the directory name.
",Bug
AMQ-4753,12671230,,"Start with a client application running qpid v0.24 connecting to activemq v5.8.0 server over amqps. Configure the activemq server to use client SSL certificates for authentication.

{code}
                <!-- aqmp with SSL client certs -->
         <transportConnector name=""amqps"" uri=""amqp+ssl://0.0.0.0:5672?maximumConnections=1000&amp;wireformat.maxFrameSize=104857600&amp;transport.transformer=jms&amp;needClientAuth=true""/>
{code}

This works and messages successfully flow from server to client. Qpid however has a fatal bug where it cannot recover from broken connections, and so attempt to switch to the activemq amqp client to work around this problem.

On the client, we initialise activemq-amqp with the following parameters:

{code}
<!-- activemq -->
  <Parameter name=""java.naming.factory.initial"" value=""org.apache.activemq.jndi.ActiveMQInitialContextFactory"" />
  <Parameter name=""connectionFactoryNames"" value=""ConnectionFactory, QueueConnectionFactory, TopicConnectionFactory"" />

  <!-- Server to connect to -->
<!-- activemq -->
  <Parameter name=""java.naming.provider.url"" value=""amqp+nio+ssl://amqp.${env:SERVER_ENV}.example.com:5672"" />
{code}

With activemq-amqp in place instead of qpid, the client starts up, but no messages are processed. Instead, it is found that the aqmp+nio+ssl provider is spinning the CPU at 100% part of the way through the SSL handshake process.

A thread dump of the spinning thread is as follows:

{code}
Full thread dump Java HotSpot(TM) 64-Bit Server VM (23.25-b01 mixed mode):

""localhost-startStop-1"" daemon prio=10 tid=0x000000000179b800 nid=0x638e runnable [0x00007fd1fd84a000]
   java.lang.Thread.State: RUNNABLE
        at sun.nio.ch.FileDispatcherImpl.read0(Native Method)
        at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:39)
        at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:225)
        at sun.nio.ch.IOUtil.read(IOUtil.java:198)
        at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:375)
        - locked <0x00000000c4da50e8> (a java.lang.Object)
        at org.apache.activemq.transport.nio.NIOSSLTransport.secureRead(NIOSSLTransport.java:285)
        at org.apache.activemq.transport.nio.NIOSSLTransport.doHandshake(NIOSSLTransport.java:333)
        at org.apache.activemq.transport.nio.NIOSSLTransport.initializeStreams(NIOSSLTransport.java:128)
        at org.apache.activemq.transport.amqp.AmqpNioSslTransport.initializeStreams(AmqpNioSslTransport.java:43)
        at org.apache.activemq.transport.tcp.TcpTransport.connect(TcpTransport.java:514)
        at org.apache.activemq.transport.nio.NIOTransport.doStart(NIOTransport.java:156)
        at org.apache.activemq.transport.nio.NIOSSLTransport.doStart(NIOSSLTransport.java:356)
        at org.apache.activemq.util.ServiceSupport.start(ServiceSupport.java:55)
        at org.apache.activemq.transport.TransportFilter.start(TransportFilter.java:58)
        at org.apache.activemq.transport.TransportFilter.start(TransportFilter.java:58)
        at org.apache.activemq.transport.TransportFilter.start(TransportFilter.java:58)
        at org.apache.activemq.ActiveMQConnectionFactory.createActiveMQConnection(ActiveMQConnectionFactory.java:273)
        at org.apache.activemq.ActiveMQConnectionFactory.createActiveMQConnection(ActiveMQConnectionFactory.java:238)
        at org.apache.activemq.ActiveMQConnectionFactory.createConnection(ActiveMQConnectionFactory.java:184)
...
{code}

If an attempt is made to restart the activemq server, despite the spinning thread on the client the server side disconnection is detected by the client and the following exception is logged and the connection is successfully aborted:

{code}
Caused by: java.io.IOException: javax.net.ssl.SSLException: Received close_notify during handshake
        at org.apache.activemq.transport.nio.NIOSSLTransport.initializeStreams(NIOSSLTransport.java:130)
        at org.apache.activemq.transport.amqp.AmqpNioSslTransport.initializeStreams(AmqpNioSslTransport.java:43)
        at org.apache.activemq.transport.tcp.TcpTransport.connect(TcpTransport.java:514)
        at org.apache.activemq.transport.nio.NIOTransport.doStart(NIOTransport.java:156)
        at org.apache.activemq.transport.nio.NIOSSLTransport.doStart(NIOSSLTransport.java:356)
        at org.apache.activemq.util.ServiceSupport.start(ServiceSupport.java:55)
        at org.apache.activemq.transport.TransportFilter.start(TransportFilter.java:58)
        at org.apache.activemq.transport.TransportFilter.start(TransportFilter.java:58)
        at org.apache.activemq.transport.TransportFilter.start(TransportFilter.java:58)
        at org.apache.activemq.ActiveMQConnectionFactory.createActiveMQConnection(ActiveMQConnectionFactory.java:273)
        ... 33 more
Caused by: javax.net.ssl.SSLException: Received close_notify during handshake
        at sun.security.ssl.Alerts.getSSLException(Alerts.java:208)
        at sun.security.ssl.SSLEngineImpl.fatal(SSLEngineImpl.java:1619)
        at sun.security.ssl.SSLEngineImpl.fatal(SSLEngineImpl.java:1587)
        at sun.security.ssl.SSLEngineImpl.recvAlert(SSLEngineImpl.java:1732)
        at sun.security.ssl.SSLEngineImpl.readRecord(SSLEngineImpl.java:1060)
        at sun.security.ssl.SSLEngineImpl.readNetRecord(SSLEngineImpl.java:884)
        at sun.security.ssl.SSLEngineImpl.unwrap(SSLEngineImpl.java:758)
        at javax.net.ssl.SSLEngine.unwrap(SSLEngine.java:624)
        at org.apache.activemq.transport.nio.NIOSSLTransport.secureRead(NIOSSLTransport.java:304)
        at org.apache.activemq.transport.nio.NIOSSLTransport.doHandshake(NIOSSLTransport.java:333)
        at org.apache.activemq.transport.nio.NIOSSLTransport.initializeStreams(NIOSSLTransport.java:128)
        ... 42 more
{code}

What seems to be happening is that amqp+nio+ssl gets part of the way through the handshake fails and goes into a spin, continuing the spin until the TCP connection is killed from the other side, at which point the client aborts and continues as if nothing had happened.
",Bug
AMQ-4740,12670485,,"If I use the stomp.js library to connect to ActiveMQ over its WebSocket url (ws://localhost:61614), the CONNECTED frame returns with disabled heart-beat:

CONNECTED
heart-beat:0,0
session:ID:retsina.local-63633-1380117269290-2:1
server:ActiveMQ/5.8.0
version:1.1

If I connect to its TCP socket (localhost:61613), the CONNECT frame will have heart-beat:

CONNECTED
heart-beat:10000,10000
session:ID:retsina.local-63384-1380115729700-2:12
server:ActiveMQ/5.8.0
version:1.1

In both case, the stomp.js send the same CONNECT frame with heart-beat:

CONNECT
login:user
passcode:password
accept-version:1.1,1.0
heart-beat:10000,10000

Is heart-beat disabled on purpose for Web Socket? Please note that the stomp.js does support heart-beat (using window.setInterval in a Web browser)
",Bug
AMQ-4148,12614131,,"Symptom
=======
The remote broker path is not set on network consumers that result from static subscriptions; as a result, they are forwarded to other bridges even when the network TTL on the bridges is 1.  In an n+1 hub-and-spoke network, the next broker to join receives n subscriptions instead of 1.

Cause
=====
A consumer for a static subscriptions is created by the following code:

{code:title=DemandForwardingBridgeSupport.java}
private void startLocalBridge() throws Throwable {
...
    if (!disposed.get()) {
            setupStaticDestinations();
        } else {
            LOG.warn(""Network connection between "" + localBroker + "" and "" + remoteBroker + ""("" + remoteBrokerName + "") was interrupted during establishment."");
        }
    }
}

/**
 * Subscriptions for these destinations are always created
 */
protected void setupStaticDestinations() {
...
            DemandSubscription sub = createDemandSubscription(dest);
            try {
                addSubscription(sub);
            } catch (IOException e) {
                LOG.error(""Failed to add static destination "" + dest, e);
            }
            if (LOG.isTraceEnabled()) {
                LOG.trace(""bridging messages for static destination: "" + dest);
            }
        }
    }
}

final protected DemandSubscription createDemandSubscription(ActiveMQDestination destination) {
    ConsumerInfo info = new ConsumerInfo();
    info.setDestination(destination);

    // the remote info held by the DemandSubscription holds the original consumerId,
    // the local info get's overwritten
    info.setConsumerId(new ConsumerId(localSessionInfo.getSessionId(), consumerIdGenerator.getNextSequenceId()));
    DemandSubscription result = null;
    try {
        result = createDemandSubscription(info);
    } catch (IOException e) {
        LOG.error(""Failed to create DemandSubscription "", e);
    }
    return result;
}
{code}

Note how the broker path is *not* set on the {{ConsumerInfo}} that is used for the subscription.  

In contrast, a consumer for a dynamic subscription does have its broker path updated to indicate that it is from a remote broker:

{code:title=DemandForwardingBridgeSupport.java}
protected void serviceRemoteCommand(Command command) {
    if (!disposed.get()) {
        try {
            if (command.isMessageDispatch()) {
                safeWaitUntilStarted();
                MessageDispatch md = (MessageDispatch) command;
                serviceRemoteConsumerAdvisory(md.getMessage().getDataStructure());
                ackAdvisory(md.getMessage());
...

private void serviceRemoteConsumerAdvisory(DataStructure data) throws IOException {
...
        if (addConsumerInfo(info)) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(configuration.getBrokerName() + "" bridged sub on "" + localBroker + "" from "" + remoteBrokerName + "" : "" + info);
                }
            } else {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(configuration.getBrokerName() + "" Ignoring sub from "" + remoteBrokerName + "" as already subscribed to matching destination : "" + info);
                }
            }
        }
...

protected boolean addConsumerInfo(final ConsumerInfo consumerInfo) throws IOException {
    boolean consumerAdded = false;
    ConsumerInfo info = consumerInfo.copy();
    addRemoteBrokerToBrokerPath(info);
...
{code}

Because of this difference, a static subscription will be forwarded to new bridges with a {{null}} brokerPath while a dynamic subscription to the same queue will be forwarded with a singleton brokerPath.  As a result, static subscriptions will be propagated one further hop than their dynamic counterparts.  In the case of a network TTL of 1, the static subscription consumers from existing bridges are unexpectedly propagated to new bridges, while the dynamic subscription consumers are correctly suppressed.

Solution
========
There should be no logical difference between a network consumer created for a static subscription vs. a dynamic subscription.  In either case, the bridge creates a consumer on behalf of the remote broker.  As such, the consumer for a static subscription should have the remote broker in its broker path because it represents a subscription from that remote broker (even if there is no consumer).
",Bug
AMQ-3827,12553867,,The current https transport protocol does not allow the ability to use the SslContext instance to setup the secure communication for the broker.  The current implementation requires that you define the standard security properties.,Bug
AMQ-6976,13162383,,"We are running a so called ""Shared Nothing"" setup with several Wildfly 8.2.1 instances (10) on several host machines (4)- all connected to one standalone Activemq installation - Normally we have  600-700 connections in total to our broker.

The Activemq installation is configured to use 8GB RAM.
{code:java}
<broker xmlns=""http://activemq.apache.org/schema/core"" brokerName=""dcdng"" id=""dcdng"" useJmx=""true"" useShutdownHook=""false""
schedulerSupport=""false"" dataDirectory=""C:/activemq/data"" advisorySupport=""false"">

<managementContext>
<managementContext createConnector=""true"" connectorPort=""61610"" suppressMBean=""endpoint=dynamicProducer,endpoint=Consumer,connectionName=*,destinationName=ActiveMQ.Advisory.*""/>
</managementContext>
 <!-- ... -->
</broker>{code}
The memory usage is set to 500mb which is sufficient since our messages are relative small. (MaxMessageSize: 41442)

 

The system performs great until we put it under high load. Then the heap usage grows and it seems the memory cannot get cleaned up properly. 

 !image-2018-05-28-16-23-36-564.png! 

At the end I took a heap dump and the MAT prints the following:

!image-2018-05-28-13-54-21-048.png!

So why are there so many TransportConnectionState objects left an not cleaned up properly. When the system performs under ""normal"" load, everything seems to be fine.",Bug
AMQ-4725,12668952,,"The TestBadVersionNumberDoesNotWork and TestBadPropertyNameFails both hang when the init method adds the following:  

    addCombinationValues(""postfix"", new Object[] {"")?initialReconnectDelay=1000&maxReconnectDelay=1000""});

I'll attach a patch which comments these out so the build doesn't hang, as well as a stack trace.
",Bug
AMQ-4641,12658720,,"If you run QueryBrowserTest using amqp+nio, you get the following:


Tests run: 2, Failures: 2, Errors: 0, Skipped: 0, Time elapsed: 5.166 sec <<< FAILURE!
testSenderBrowser(org.objectweb.jtests.jms.conform.queue.QueueBrowserTest)  Time elapsed: 3.053 sec  <<< FAILURE!
junit.framework.AssertionFailedError: null
	at junit.framework.Assert.fail(Assert.java:55)
	at junit.framework.Assert.assertTrue(Assert.java:22)
	at junit.framework.Assert.assertTrue(Assert.java:31)
	at org.objectweb.jtests.jms.conform.queue.QueueBrowserTest.testSenderBrowser(QueueBrowserTest.java:103)

testBrowserWithMessageSelector(org.objectweb.jtests.jms.conform.queue.QueueBrowserTest)  Time elapsed: 2.051 sec  <<< FAILURE!
junit.framework.AssertionFailedError: expected:<1> but was:<0>
	at junit.framework.Assert.fail(Assert.java:57)
	at junit.framework.Assert.failNotEquals(Assert.java:329)
	at junit.framework.Assert.assertEquals(Assert.java:78)
	at junit.framework.Assert.assertEquals(Assert.java:234)
	at junit.framework.Assert.assertEquals(Assert.java:241)
	at org.objectweb.jtests.jms.conform.queue.QueueBrowserTest.testBrowserWithMessageSelector(QueueBrowserTest.java:142)


This may be similar to: https://issues.apache.org/jira/browse/AMQ-4376
",Bug
AMQ-4338,12633271,,"MQTTSSLTest has multiple different test cases (including testSendAndReceiveExactlyOnce, testSendAndReceiveLargeMessages, testSendAndReceiveMQTT, testSendAtLeastOnceReceiveAtMostOnce, testSendAtLeastOnceReceiveExactlyOnce, testSendJMSReceiveMQTT, testSendMQTTReceiveJMS) which fail fairly frequently because of a hang on the provider.connect() call in initializeConnection() as shown in the stacktrace below. 

Another problem with this test is it was giving a misleading error when run under Hudson, showing that the test that followed it (MQTTTest) was failing instead.  I think this was because of the way it was using AutoFailTestSupport.  I will attach a patch which removes that and uses timeouts on @Test annotations instead.

testSendAndReceiveLargeMessages(org.apache.activemq.transport.mqtt.MQTTSSLTest)  Time elapsed: 30.004 sec  <<< ERROR!
java.lang.Exception: test timed out after 30000 milliseconds
        at sun.misc.Unsafe.park(Native Method)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:834)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:994)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1303)
        at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:236)
        at org.fusesource.mqtt.client.Promise.await(Promise.java:88)
        at org.fusesource.mqtt.client.BlockingConnection.connect(BlockingConnection.java:49)
        at org.apache.activemq.transport.mqtt.FuseMQQTTClientProvider.connect(FuseMQQTTClientProvider.java:39)
        at org.apache.activemq.transport.mqtt.MQTTSSLTest.initializeConnection(MQTTSSLTest.java:60)


Results :

Tests in error:
  MQTTSSLTest>AbstractMQTTTest.testSendAndReceiveLargeMessages:247->initializeConnection:60 »
",Bug
AMQ-4306,12631493,,"This test runs very slowly on Solaris, taking 8-10 times as long as on Mac or Ubuntu.  It looks the the difference is almost all in the section where it builds the index.  I'll try to get more info later.

For now I'm attaching a patch which bumps up the timeout for this test so it doesn't cause the build to fail.",Bug
AMQ-3724,12542895,,"When enabling dynamic failover on the transport connectors some or all brokers in the cluster do not have their NetworkConnector or Queue mBeans enabled.  See attached patch.

Thanks,
Scott ES
http://fusesource.com",Bug
AMQ-4568,12650837,,"This test is currently hanging.  I'll attach a stack trace and a test patch which includes a timeout.
",Bug
AMQ-2189,12482760,,"The attached fix resolves a problem in KahaDBStore.KahaDBSession in which addMessage() wasn't using the caller supplied message key but instead allocated a new key. Without using the user supplied key, subsequent deletes would not properly delete the message. Also fixed corresponding test cases to provide a message key when adding messages. 

Also made some fixes to synchronization and delayed event processing in BrokerDatabase. The resulting code is not as performant in swimlanes testing, and should be optimized in the future (the problem is too many threads synchronizing on the opQueue is causing a lot of contention). 

Finally added some miscellaneous fixes to OpenwireProtocolHandler and the test drivers to avoid/detect duplicate messageIds. ",Bug
AMQ-2132,12482839,,"RemoteConnection error: java.lang.IndexOutOfBoundsException: Index: 7, Size: 3
  at java.util.ArrayList.RangeCheck(ArrayList.java:546)
  at java.util.ArrayList.get(ArrayList.java:321)
  at org.apache.activemq.dispatch.AbstractPooledDispatcher.chooseDispatcher(AbstractPooledDispatcher.java:132)
  at org.apache.activemq.dispatch.PriorityDispatcher$2$1.execute(PriorityDispatcher.java:89)
  at org.apache.activemq.flow.FlowController.checkUnblockSources(FlowController.java:424)
  at org.apache.activemq.flow.FlowController.dispatchOverflowQueue(FlowController.java:341)
  at org.apache.activemq.flow.FlowController.onUnthrottled(FlowController.java:300)
  at org.apache.activemq.flow.FlowController$1.onUnthrottled(FlowController.java:83)
  at org.apache.activemq.flow.AbstractLimiter.notifyUnThrottleListeners(AbstractLimiter.java:41)
  at org.apache.activemq.flow.SizeLimiter.remove(SizeLimiter.java:68)
  at org.apache.activemq.flow.RemoteConnection$WindowLimiter.remove(RemoteConnection.java:308)
  at org.apache.activemq.flow.RemoteConnection$WindowLimiter.onProtocolMessage(RemoteConnection.java:323)
  at org.apache.activemq.flow.RemoteConnection.onCommand(RemoteConnection.java:92)
  at org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:68)
  at org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:210)
  at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:84)
  at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:234)
  at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:216)
  at java.lang.Thread.run(Thread.java:613)
",Bug
AMQ-2133,12482834,,When a timer is added to the heap the units were being converted backwards so that adding a Runnable that is suppose to execute in 5000ms would execute in 5 nanoseconds.,Bug
AMQ-2108,12482828,,"The following deadlock can occur in FlowController.offer(). FlowController shouldn't hold onto the mutex when calling flowElementAccepted

Thread [pipe://Broker#2] (Suspended)	
	Object.wait(long, int) line: not available [native method]	
	ExclusivePriorityQueue<E>(Object).wait() line: 199 [local variables unavailable]	
	FlowController<E>.waitForResume() line: 372	
	FlowController<E>.blockSource(ISourceController<E>) line: 315	
	FlowController<E>.add(E, ISourceController<E>) line: 229	
	PriorityFlowController<E>.add(E, ISourceController<E>) line: 60	
	ExclusivePriorityQueue<E>.add(E, ISourceController<E>) line: 66	
	Router.route(ISourceController<Message>, Message) line: 30	
	RemoteConnection$1.flowElemAccepted(ISourceController<Message>, Message) line: 92	
	RemoteConnection$1.flowElemAccepted(ISourceController, Object) line: 1	
	FlowController<E>.offer(E, ISourceController<E>) line: 266	
	RemoteConnection.onCommand(Object) line: 73	
	PipeTransportFactory$PipeTransport.run() line: 66	
	Thread.run() line: 788	

Thread [consumer1-outbound] (Suspended)	
	FlowController<E>.onFlowResume(ISinkController<E>) line: 136	
	FlowController$2.run() line: 400	
	IDispatcher$RunnableAdapter.dispatch() line: 90	
	PriorityDispatcher$PriorityDispatchContext.dispatch() line: 183	
	PriorityDispatcher.run() line: 263	
	Thread.run() line: 788	
",Bug
AMQ-2107,12482816,,"There is deadlock in PriorityDispatcher.run when processing updates from foreign threads, it holds on to foreignQueue. If there are multiple dispatch threads this can lead to the following deadlock:

Thread [BrokerDispatcher-1] (Suspended)  
  owns: LinkedNodeList<T>  (id=102)  
  waiting for: LinkedNodeList<T>  (id=125)  
  PriorityDispatcher$PriorityDispatchContext.onForeignThreadUpdate() line: 132  
  ExecutionGraphLoadBalancer$ExecutionGraphNode.processForeignUpdates() line: 428  
  PriorityDispatcher$UpdateEvent.execute() line: 79  
  PriorityDispatcher.run() line: 279  
  Thread.run() line: 613  
Thread [BrokerDispatcher-2] (Suspended)  
  owns: LinkedNodeList<T>  (id=125)  
  waiting for: LinkedNodeList<T>  (id=102)  
  PriorityDispatcher$PriorityDispatchContext.onForeignThreadUpdate() line: 132  
  ExecutionGraphLoadBalancer$ExecutionGraphNode.processForeignUpdates() line: 428  
  PriorityDispatcher$UpdateEvent.execute() line: 79  
  PriorityDispatcher.run() line: 279  
  Thread.run() line: 613

The attached patch also includes refactoring of the PriorityPooledDispatcher to use a simplifed ExecutionLoadBalancer interface.",Bug
AMQ-275,12481609,,"Relaited to slow consumer condition.

WARN 2005-06-22 12:55:44,135 - Queue is full, waiting for it to be dequeued.


2005-06-22 11:51:09,678 [ocalport=61616]] WARN  BrokerClientImpl               - Connection: ID:ny-cap-33-2024-1119453996333-6:0 is a slow consumer
2005-06-22 11:51:09,678 [ocalport=61616]] WARN  BrokerClientImpl               - Connection: ID:ny-cap-33-2024-1119453996333-6:0 is a slow consumer
2005-06-22 11:51:09,694 [ocalport=61616]] INFO  DataContainer                  - making directory for temporary spooled data: ActiveMQTemp
2005-06-22 11:51:11,069 [ocalport=61616]] WARN  BrokerClientImpl               - Connection: ID:ny-cap-33-2005-1119453893347-6:0 is a slow consumer
2005-06-22 11:51:11,069 [ocalport=61616]] WARN  BrokerClientImpl               - Connection: ID:ny-cap-33-2005-1119453893347-6:0 is a slow consumer

2005-06-22 11:51:17,288 [ocalport=61616]] DEBUG ientTopicBoundedMessageManager - Adding consumer: CONSUMER_INFO: id = 336 ConsumerInfo{ browser = false, destination = ActiveMQ.Advisory.TempDestinations.temp-queue.TemporaryQueue-{TD{ID:ny-cap-33-2150-1119455437835-16:0}TD}ID:ny-cap-33-2150-1119455437835-23:0, consumerIdentifier = 'ID:ny-cap-33-2024-1119453996333-16:0.27.53' , clientId = 'ID:ny-cap-33-2024-1119453996333-16:0' , sessionId = '27' , consumerName = '' , selector = '' , startTime = 1119455477008, started = true, consumerNo = 53, noLocal = false, prefetchNumber = 1000, consumerKey = '[ID:ny-cap-33-2024-1119453996333-16:0:]'  }
2005-06-22 11:51:54,773 [ocalport=61616]] ERROR BrokerClientImpl               - Could not enqueue message ACTIVEMQ_OBJECT_MESSAGE: id = 0 ActiveMQMessage{ , jmsMessageID = ID:ny-cap-33-2005-1119453893347-68:121589, bodyAsBytes = org.activemq.io.util.ByteArray@1f07377, readOnlyMessage = false, jmsClientID = 'ID:ny-cap-33-2005-1119453893347-6:0' , jmsCorrelationID = 'null' , jmsDestination = Topic.sds.PropertyTemplatePublisher, jmsReplyTo = null, jmsDeliveryMode = 2, jmsRedelivered = false, jmsType = 'null' , jmsExpiration = 1119455573508, jmsPriority = 4, jmsTimestamp = 1119455513508, properties = null, readOnlyProperties = false, entryBrokerName = 'ID:nyotc023-2882-1119382254093-0:0' , entryClusterName = 'default' , consumerNos = [I@12cb4ae, transactionId = 'null' , xaTransacted = false, consumerIdentifer = 'null' , messageConsumed = false, transientConsumed = false, sequenceNumber = 121589, deliveryCount = 1, dispatchedFromDLQ = false, messageAcknowledge = null, jmsMessageIdentity = null, producerKey = ID:ny-cap-33-2005-1119453893347-68: } ActiveMQObjectMessage{ object = null } to SpooledBoundedQueue for this slow consumer
javax.jms.JMSException: enqueNoBlock failed: Too many open files
	at org.activemq.io.util.SpooledBoundedActiveMQMessageQueue.enqueueNoBlock(SpooledBoundedActiveMQMessageQueue.java:121)
	at org.activemq.io.util.SpooledBoundedActiveMQMessageQueue.enqueue(SpooledBoundedActiveMQMessageQueue.java:91)
	at org.activemq.broker.impl.BrokerClientImpl.dispatch(BrokerClientImpl.java:198)
	at org.activemq.service.boundedvm.TransientTopicBoundedMessageContainer.dispatchToQueue(TransientTopicBoundedMessageContainer.java:223)
	at org.activemq.service.boundedvm.TransientTopicBoundedMessageContainer.targetAndDispatch(TransientTopicBoundedMessageContainer.java:155)
	at org.activemq.service.boundedvm.TransientTopicBoundedMessageManager.doSendMessage(TransientTopicBoundedMessageManager.java:225)
	at org.activemq.service.boundedvm.TransientTopicBoundedMessageManager.sendMessage(TransientTopicBoundedMessageManager.java:204)
	at org.activemq.broker.impl.DefaultBroker.doMessageSend(DefaultBroker.java:563)
	at org.activemq.broker.impl.DefaultBroker.sendMessage(DefaultBroker.java:305)
	at org.activemq.broker.impl.BrokerContainerImpl.sendMessage(BrokerContainerImpl.java:462)
	at org.activemq.broker.impl.BrokerConnectorImpl.sendMessage(BrokerConnectorImpl.java:271)
	at org.activemq.broker.impl.BrokerClientImpl.consumeActiveMQMessage(BrokerClientImpl.java:706)
	at org.activemq.broker.impl.BrokerClientImpl.consume(BrokerClientImpl.java:310)
	at org.activemq.transport.TransportChannelSupport.doConsumePacket(TransportChannelSupport.java:374)
	at org.activemq.transport.TransportChannelSupport.doConsumePacket(TransportChannelSupport.java:368)
	at org.activemq.transport.tcp.TcpTransportChannel.run(TcpTransportChannel.java:311)
	at java.lang.Thread.run(Thread.java:534)

",Bug
AMQ-389,12481616,,"Within a clustered environment, messages that have been sent to a Queue can end up stuck in the broker and are never delivered to the connected consumer.

Suppose, we have a cluster of two JMS brokers, Node 0 and Node 1, and that there is an active producer and an active consumer connected to Node 0, that are producing and consuming from Queue, Q. i.e. 

Producer 

|

Node 0 <-----> Node 1

|

Consumer

And the following happens for a Message, M, sent to Queue, Q:

I) Node 0 receives message M from the producer 
II) Node 1 consumes message M from Node 0
iii) Node 0 consumes message M back from Node 1
iv) Node 1 attempts to consume message M from Node 0 again.

Then, the message will end up being undelivered. It will still be in the MessageStore for Node0, but will never be dispatched to any consumer, unless the broker is restarted.

The reason this happens, is that during step iv) the message wil be dispatched to the subscriber represented by Node 1, and thus Node 0 will believe the message has successfully been sent, but Node 1's subscriber will never actually send the message to Node 1, since the anti-cycle logic in the BrokerClientImpl::send() method will drop the packet silently.

A simple possible fix is:

Alter the method signature for BrokerClient::dispatch() to return a boolean iff only it can successfully dispatch the message to the actual consumer. The same change needs to be made to the DurableQueueSubscription::doDispatch() method, to propagate this information.

The DurableQueueBoundedMessageContainer::run() method can then be altered so it only considers a message dispatched if one of its subscribers doDispatch() methods returns true, otherwise it will retain the message.

I have attached the modified source files in the patch.zip.",Bug
AMQ-373,12481543,,"Steps to reproduce:

- Set up a network of 2 or more brokers 
- Produce messages on 1 distributed queue on both brokers
- Start a consumer on the queue on each broker
- Stop one or more of the consumers while the producers produce messages

The test results are inconsistent depending varying from run to run and how many messages are sent, but three different error scenarios occur:

1. Messages are lost and not delivered
2. Messages are delivered very slowly
3. Messages are delivered twice

It is also worth noting that shutdown of networked brokers doesn't happen very cleanly.

A testcase is attached and although it's not as clean as it perhaps should be, it's simple enough to be easily understandable. Please notify me if you are having problems reproducing it or want it to be cleaned up. :)
",Bug
AMQ-422,12481647,,"I'm trying to create a distributed topic between two servers for high availability (pretty much as described in http://activemq.codehaus.org/Networks+of+Brokers).  Both of the servers want to produce/consume messages to/from this topic.

The config looks like this:

<?xml version=""1.0"" encoding=""UTF-8""?>
<!DOCTYPE beans PUBLIC  ""-//ACTIVEMQ//DTD//EN"" ""http://activemq.org/dtd/activemq.dtd"">
<beans>
  <broker>
    <connector>
      <tcpServerTransport uri=""tcp://SERVER1:61616"" backlog=""1000"" useAsyncSend=""true"" maxOutstandingMessages=""50""/>
    </connector>    
    <networkConnector>      
      <networkChannel uri=""reliable:tcp://SERVER2:61616"" remoteBrokerName=""whocares""/>    
    </networkConnector>    
    <persistence>      
      <vmPersistence/>    
    </persistence>   
  </broker>
</beans>

Initial setup is fine, and upon starting both servers they connect and happily message with each other. However, problems arise if one of the servers is restarted or if a network outage occurs.

If one server (SERVER1, say) is stopped and restarted, reconnection occurs but messages are then received twice by the other server (SERVER2 - the one that was not stopped).  The activeMQ logging I get from SERVER2 on reconnect is:

14:56:16,765 channel status changed: Channel: tcp://192.168.1.171:61616 has reconnected
14:56:16,890 Adding new client: ID:elephant-3033-1132757775296-0:0_NetworkChannel on transport: TcpTransportChannel: Socket[addr=/192.168.1.172,port=3035,localport=61615]

but after this all messages are received once on SERVER1 and twice on SERVER2.
I could just about live with that, but...

...if both servers are running but encounter a network outage (ie. I disable then re-enable the network of one machine) I get one of two situations:
1) Both servers appear to reconnect, but neither one receives *any* messages any more, or
2) The servers reconnect, but upon one server posting to the topic, both are sent into an infinite loop receiving the same message for ever. 

I've attached an eclipse project with some simple test classes.  Run ""Main"" on two machines and specify the local host/port and remote host/port as arguments to the Main class.

",Bug
AMQ-336,12481097,,"When setting a message listener, using the ActiveMQMessageConsumer::setMessageListener() method, a deadlock can result, if there are messages being dispatched to that consumer by an ActiveMQSessionExecuter.

INFO   | jvm 1    | 2005/08/17 12:37:54 | Found one Java-level deadlock:
INFO   | jvm 1    | 2005/08/17 12:37:54 | =============================
INFO   | jvm 1    | 2005/08/17 12:37:54 | ""JmsSessionDispatcher: 1"":
INFO   | jvm 1    | 2005/08/17 12:37:54 |   waiting to lock monitor 00284bec (object 61acd670, a java.lang.Object),
INFO   | jvm 1    | 2005/08/17 12:37:54 |   which is held by ""NetworkChannel Initiator to reliable:tcp://ehrapp2.au.logicacmg.com:16010""
INFO   | jvm 1    | 2005/08/17 12:37:54 | ""NetworkChannel Initiator to reliable:tcp://ehrapp2.au.logicacmg.com:16010"":
INFO   | jvm 1    | 2005/08/17 12:37:54 |   waiting to lock monitor 00284cdc (object 61acd578, a org.activemq.ActiveMQMessageConsumer),
INFO   | jvm 1    | 2005/08/17 12:37:54 |   which is held by ""JmsSessionDispatcher: 1""
INFO   | jvm 1    | 2005/08/17 12:37:54 | 
INFO   | jvm 1    | 2005/08/17 12:37:54 | Java stack information for the threads listed above:
INFO   | jvm 1    | 2005/08/17 12:37:54 | ===================================================
INFO   | jvm 1    | 2005/08/17 12:37:54 | ""JmsSessionDispatcher: 1"":
INFO   | jvm 1    | 2005/08/17 12:37:54 | 	at org.activemq.ActiveMQMessageConsumer.processMessage(ActiveMQMessageConsumer.java:428)
INFO   | jvm 1    | 2005/08/17 12:37:54 | 	- waiting to lock <61acd670> (a java.lang.Object)
INFO   | jvm 1    | 2005/08/17 12:37:54 | 	- locked <61acd578> (a org.activemq.ActiveMQMessageConsumer)
INFO   | jvm 1    | 2005/08/17 12:37:54 | 	at org.activemq.ActiveMQSessionExecutor.dispatch(ActiveMQSessionExecutor.java:110)
INFO   | jvm 1    | 2005/08/17 12:37:54 | 	at org.activemq.ActiveMQSessionExecutor.run(ActiveMQSessionExecutor.java:95)
INFO   | jvm 1    | 2005/08/17 12:37:54 | 	at java.lang.Thread.run(Thread.java:534)
INFO   | jvm 1    | 2005/08/17 12:37:54 | ""NetworkChannel Initiator to reliable:tcp://ehrapp2.au.logicacmg.com:16010"":
INFO   | jvm 1    | 2005/08/17 12:37:54 | 	at org.activemq.ActiveMQMessageConsumer.processMessage(ActiveMQMessageConsumer.java:422)
INFO   | jvm 1    | 2005/08/17 12:37:54 | 	- waiting to lock <61acd578> (a org.activemq.ActiveMQMessageConsumer)
INFO   | jvm 1    | 2005/08/17 12:37:54 | 	at org.activemq.ActiveMQMessageConsumer.setMessageListener(ActiveMQMessageConsumer.java:243)
INFO   | jvm 1    | 2005/08/17 12:37:54 | 	- locked <61acd670> (a java.lang.Object)
INFO   | jvm 1    | 2005/08/17 12:37:54 | 	at org.activemq.advisories.ConnectionAdvisor.start(ConnectionAdvisor.java:82)
INFO   | jvm 1    | 2005/08/17 12:37:54 | 	at org.activemq.transport.NetworkChannel.initializeRemote(NetworkChannel.java:597)
INFO   | jvm 1    | 2005/08/17 12:37:54 | 	- locked <61a3c320> (a org.activemq.transport.NetworkChannel)
INFO   | jvm 1    | 2005/08/17 12:37:54 | 	at org.activemq.transport.NetworkChannel.initialize(NetworkChannel.java:565)
INFO   | jvm 1    | 2005/08/17 12:37:54 | 	at org.activemq.transport.NetworkChannel$1.run(NetworkChannel.java:197)
INFO   | jvm 1    | 2005/08/17 12:37:54 | 	at EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(Unknown Source)
INFO   | jvm 1    | 2005/08/17 12:37:54 | 	at java.lang.Thread.run(Thread.java:534)

A simple fix is to synchronize the setMessageListener() method, although this may be too coarse-grained.",Bug
AMQ-328,12481406,,"Using a topic requestor with requestor on one first broker and replier on second broker.  First reply message seems to work, but second is stopped prior to return across the bridge. ",Bug
AMQ-326,12481404,,Have seen cases where the delivery can be delayed by minutes.  This was happening in single broker configuration.  ,Bug
AMQ-379,12481377,,"I found if the Recevier and Sender start almost the same time.  The Receiver will receiver the same message twise.  I have included my Testing program run by 
java -classpath .;..\activemq-3.1.jar;..\lib\geronimo-spec-jms-1.1-rc4.jar;..\lib\geronimo-spec-j2ee-management-1.0-rc4.jar;..\lib\commons-logging-1.0.3.jar;..\lib\log4j-1.2.8.jar;..\lib\concurrent-1.3.4.jar;..\conf;..\lib\spring-1.2.2.jar TestJmsSender

I have test by restarted the program ~10 times and around 40% chance of have the error of receiver rec same message twise

",Bug
AMQ-339,12481184,,"The connector implementation does not allow for connection factory-specific deployments. As an example, to connect to a broker that does not listen on the standard port, you can configure this in JBoss with a connection factory deployment as follows:

  <tx-connection-factory>
    <jndi-name>/activemq/QueueConnectionFactory</jndi-name>
    <local-transaction/>
    <rar-name>activemq-ra-3.2-SNAPSHOT.rar</rar-name>
    <config-property name=""ServerUrl"" type=""java.lang.String"">tcp://localhost:10000</config-property>
    <config-property name=""Clientid"" type=""java.lang.String"">NodeX1002</config-property>
    <connection-definition>javax.jms.QueueConnectionFactory</connection-definition>
    <security-domain-and-application>JmsXARealm</security-domain-and-application>
  </tx-connection-factory>

However, the connector does not actually honor the new values although they are properly set in JBoss. This is ultimately b/c the ActiveMQManagedConnectionFactory calls back to the ActiveMQResourceAdapter's makeConnection() method to create the connection object. makeConnection() uses a connection factory with the default configuration, not the configuration of the factory. Patch attached, tested and working in my environment for simple message dispatching, should probably be tested with MDB activation as well. ",Bug
AMQ-414,12481337,,"I raised a Geronimo issue last week -- http://issues.apache.org/jira/browse/GERONIMO-1155. I also posted a patch. I'll repost, here...

While running a test of the DayTrader sample application, the server received an OutOfMemoryException. At the time of failure, there were over 150,000 ActiveMQSession objects. These sessions were being kept alive by ActiveMQ TransactionContexts associated with ActiveMQManagedConnections. I believe that Sessions are being registered with the ActiveMQManagedConnection TransactionContexts, but will never be unregistered via TransactionContext.removeSession(Session).

In non-managed environments, the TransactionContext is owned by the Session. So, a Session does not need to be explicitly removed from the TransactionContext. Once a Session has been closed, both the Session and the TransactionContext are available for garbage collection. The Session never bothers to ""unregister"" with its associated TransactionContext. IMO, this is the root of the problem. There's a different TransactionContexts structure in RA environments.

ManagedConnections have an additional TransactionContext. As Sessions are created, an RATransactionContext is generated for each new Session. As a Session registers with the RATransactionContext, the RATransactionContext locally registers the Session, but also registers the Session with the ManagedConnection's TransactionContext. It's this registration that is the problem... The Session will never be removed from the ManagedConnection's TransactionContext.

DayTrader repeatedly drives an EJB to publish a message. The processing in the EJB is pretty simple, create a connection from a ConnectionFactory, create a session, create a producer, and send a message. .createConnection(), connection.createSession(), session.createProducer, connection.close(). The ManagedConnection is pooled. So, the connection (and its TransactionContext) are long-lived. Each iteration through the EJB is going to cause the creation of a new Session which is registered with the ManagedConnection's TransactionContext. However, the Session will never be removed from this TransactionContext...

I could create the same basic problem by creating a Connection, and repeatedly creating a session and closing it. 

The above is from my reading of the code. I'm not currently able to run DayTrader in my dev environment. Should be easy to create a simple test-case, but I haven't gotten around to it, yet. 

The obvious fix is to add the following to ActiveMQSession.doClose():

    this.transactionContext.removeSession(this);

I'll post a patch. Let me know if I'm missing something obvious... ",Bug
AMQ-444,12481578,,"When using the STOMP c-client messages are sometimes delivered twice. See attached communication dump. See below for the comm flow;

--> CONNECT
<-- CONNECTED
--> SUBSCRIBE /queue/FOO.BAR
--> SEND /queue/FOO.BAR, msg-123, Hello World!
<-- MESSAGE Hello World!
<-- RECEIPT msg-123
<-- MESSAGE Hello World!
",Bug
AMQ-427,12481402,,"Yeah, it's trivia, but it annoys me!  
Patch attached.",Bug
AMQ-576,12481554,,"Test case: start JVM; start embedded JMS container; send 10 persistent messages to queue; commit; stop JMS container; shutdown JVM; start JVM; start JMS container; create queue consumer; consume messages.

Result: Only one message (the last message sent) received by the consumer.

I have attached the relevant source.
",Bug
AMQ-655,12481475,,"Will attach a patch that corrects the typo and also prefixes it with ""ActiveMQ "" so it is easily to identify the owner of the thread.",Bug
AMQ-761,12481707,,"If I set the brokerUrl of ActiveMQConnectionFactory using setBrokerURL(), the connection factory does not reparse all of the properties from the URL.  As a result, when a new connection is created, some of the properties from the URL specified during the construction of the connection factory (typically the defaults) are used instead.  Attached is a unit test to demonstrate the problem.

As a minimum, the following block of code is required in setBrokerURL().  But this doesn't really fix it because properties settings from the URL used by the constructor may not be reset by this code.  A structural change may be in order (e.g. just-in-time parsing of the properties).

       if( brokerURL.indexOf(""?"")>= 0 ) {
            String options = brokerURL.substring(brokerURL.indexOf(""?"")+1);
            Map properties = URIHelper.parseQuery(options);
            if (!properties.isEmpty()) {
                BeanUtils.populate(this, properties);
            }   ",Bug
AMQ-708,12481696,,"Hostname and port changes I made to the activemq connectors via the geronimo admin console don't get persisted in geronimo's var/config/config.xml, causing them to revert to their original values when the server restarts.

To fix this problem ActiveMQConnectorGBean needs to declare the host and port attributes as manageable when it creates its gbeaninfo. See the attached patch.",Bug
AMQ-727,12481604,,"Trying to create a new connector from the Admin Console in Geronimo v1.1 fails with the following ST:

11:06:48,041 ERROR [JMSConnectorPortlet] Unable to process portlet action
java.lang.IllegalArgumentException: GBeanInfo must have a source class set
at org.apache.geronimo.system.configuration.GBeanOverride.<init>(GBeanOverride.java:76)
at org.apache.geronimo.system.configuration.LocalAttributeManager.addGBean(LocalAttributeManager.java:320)
at org.apache.geronimo.system.configuration.LocalAttributeManager$$FastClassByCGLIB$$b20ef545.invoke(<generated>)
at net.sf.cglib.reflect.FastMethod.invoke(FastMethod.java:53)
at org.apache.geronimo.gbean.runtime.FastMethodInvoker.invoke(FastMethodInvoker.java:38)
at org.apache.geronimo.gbean.runtime.GBeanOperation.invoke(GBeanOperation.java:122)
at org.apache.geronimo.gbean.runtime.GBeanInstance.invoke(GBeanInstance.java:817)
at org.apache.geronimo.gbean.runtime.RawInvoker.invoke(RawInvoker.java:57)
at org.apache.geronimo.kernel.basic.RawOperationInvoker.invoke(RawOperationInvoker.java:35)
at org.apache.geronimo.kernel.basic.ProxyMethodInterceptor.intercept(ProxyMethodInterceptor.java:96)
at org.apache.geronimo.kernel.config.PersistentConfigurationList$$EnhancerByCGLIB$$d01f9f2b.addGBean(<generated>)
at org.apache.geronimo.kernel.config.EditableKernelConfigurationManager.addGBeanToConfiguration(EditableKernelConfigurationManager.java:127)
at org.apache.geronimo.kernel.config.EditableKernelConfigurationManager.addGBeanToConfiguration(EditableKernelConfigurationManager.java:60)
at org.apache.geronimo.kernel.config.EditableKernelConfigurationManager$$FastClassByCGLIB$$daeffab3.invoke(<generated>)
at net.sf.cglib.reflect.FastMethod.invoke(FastMethod.java:53)
at org.apache.geronimo.gbean.runtime.FastMethodInvoker.invoke(FastMethodInvoker.java:38)
at org.apache.geronimo.gbean.runtime.GBeanOperation.invoke(GBeanOperation.java:122)
at org.apache.geronimo.gbean.runtime.GBeanInstance.invoke(GBeanInstance.java:817)
at org.apache.geronimo.gbean.runtime.RawInvoker.invoke(RawInvoker.java:57)
at org.apache.geronimo.kernel.basic.RawOperationInvoker.invoke(RawOperationInvoker.java:35)
at org.apache.geronimo.kernel.basic.ProxyMethodInterceptor.intercept(ProxyMethodInterceptor.java:96)
at org.apache.geronimo.kernel.config.EditableConfigurationManager$$EnhancerByCGLIB$$e6ae163a.addGBeanToConfiguration(<generated>)
at org.activemq.gbean.management.ActiveMQManagerGBean.addConnector(ActiveMQManagerGBean.java:207)
at org.activemq.gbean.management.ActiveMQManagerGBean$$FastClassByCGLIB$$a78b116e.invoke(<generated>)
at net.sf.cglib.reflect.FastMethod.invoke(FastMethod.java:53)
at org.apache.geronimo.gbean.runtime.FastMethodInvoker.invoke(FastMethodInvoker.java:38)
at org.apache.geronimo.gbean.runtime.GBeanOperation.invoke(GBeanOperation.java:122)
at org.apache.geronimo.gbean.runtime.GBeanInstance.invoke(GBeanInstance.java:817)
at org.apache.geronimo.gbean.runtime.RawInvoker.invoke(RawInvoker.java:57)
at org.apache.geronimo.kernel.basic.RawOperationInvoker.invoke(RawOperationInvoker.java:35)
at org.apache.geronimo.kernel.basic.ProxyMethodInterceptor.intercept(ProxyMethodInterceptor.java:96)
at org.activemq.gbean.ActiveMQManager$$EnhancerByCGLIB$$1f9d3f5e.addConnector(<generated>)
at org.apache.geronimo.console.util.PortletManager.createJMSConnector(PortletManager.java:275)
at org.apache.geronimo.console.jmsmanager.server.JMSConnectorPortlet.processAction(JMSConnectorPortlet.java:80)
at org.apache.pluto.core.PortletServlet.dispatch(PortletServlet.java:229)
at org.apache.pluto.core.PortletServlet.doGet(PortletServlet.java:158)
at javax.servlet.http.HttpServlet.service(HttpServlet.java:595)
at javax.servlet.http.HttpServlet.service(HttpServlet.java:688)
at org.apache.pluto.core.PortletServlet.service(PortletServlet.java:153)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:252)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173)
at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:672)
at org.apache.catalina.core.ApplicationDispatcher.doInclude(ApplicationDispatcher.java:574)
at org.apache.catalina.core.ApplicationDispatcher.include(ApplicationDispatcher.java:499)
at org.apache.pluto.invoker.impl.PortletInvokerImpl.invoke(PortletInvokerImpl.java:120)
at org.apache.pluto.invoker.impl.PortletInvokerImpl.action(PortletInvokerImpl.java:68)
at org.apache.pluto.PortletContainerImpl.processPortletAction(PortletContainerImpl.java:164)
at org.apache.pluto.portalImpl.core.PortletContainerWrapperImpl.processPortletAction(PortletContainerWrapperImpl.java:82)
at org.apache.pluto.portalImpl.Servlet.doGet(Servlet.java:227)
at javax.servlet.http.HttpServlet.service(HttpServlet.java:595)
at javax.servlet.http.HttpServlet.service(HttpServlet.java:688)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:252)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173)
at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:213)
at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:178)
at org.apache.geronimo.tomcat.valve.DefaultSubjectValve.invoke(DefaultSubjectValve.java:52)
at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:524)
at org.apache.geronimo.tomcat.GeronimoStandardContext$SystemMethodValve.invoke(GeronimoStandardContext.java:342)
at org.apache.geronimo.tomcat.valve.GeronimoBeforeAfterValve.invoke(GeronimoBeforeAfterValve.java:31)
at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:126)
at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:105)
at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:107)
at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:541)
at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:148)
at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:869)
at org.apache.coyote.http11.Http11BaseProtocol$Http11ConnectionHandler.processConnection(Http11BaseProtocol.java:667)
at org.apache.tomcat.util.net.PoolTcpEndpoint.processSocket(PoolTcpEndpoint.java:527)
at org.apache.tomcat.util.net.LeaderFollowerWorkerThread.runIt(LeaderFollowerWorkerThread.java:80)
at org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:684)
at java.lang.Thread.run(Thread.java:534)

The problem seems to be that ActiveMQConnectorGBean.java doesn't provide a source class in its gbean info.  See the attached patch.

Also, please see the following GERONIMO JIRA which describes a similar problem with persisting a new connector across Geronimo restarts (it provides a patch).
    http://issues.apache.org/jira/browse/GERONIMO-1451",Bug
AMQ-746,12481644,,The current implementation resolves the persistence adapter directory via serverInfo.resolve. This causes a problem with the multi-server feature: the journal is located at var/activemq/journal instead of <server name>/var/activemq/journal,Bug
AMQ-556,12481583,,"The o.a.a.store.jdbc.TransactionContext does not correctly process the Statement.SUCCESS_NO_INFO return code from the executeBatch() method.
From http://java.sun.com/j2se/1.4.2/docs/api/java/sql/Statement.html#executeBatch()
""A value of SUCCESS_NO_INFO -- indicates that the command was processed successfully but that the number of rows affected is unknown""
Line 92 should be
                if ( rc[i]!= 1 && rc[i]!=Statement.SUCCESS_NO_INFO) {
instead of 
                if ( rc[i]!= 1 ) {
",Bug
AMQ-895,12483417,12483795,"I'm using ActiveMQ (4.0.1) JMS to JMS Bridge functionality to connect to a  SunMQ JMS Broker (3.6 SP3  (Build 02-A)). I'm using two queues, an input and an output one, with the following configuration:


    <jmsBridgeConnectors>
      <jmsQueueConnector outboundQueueConnectionFactory=""#REMOTE"">
      <outboundQueueBridges>
        <outboundQueueBridge outboundQueueName=""SUNRECV""/>
      </outboundQueueBridges>
      <inboundQueueBridges>
        <inboundQueueBridge inboundQueueName=""SUNSEND""/>
      </inboundQueueBridges>
      </jmsQueueConnector>
    </jmsBridgeConnectors>


The system works really well until the SunMQ broker needed to be restarted. This is what I found:
1.-ActiveMQ is not aware of the remote broker shutdown. I waited for a while, but no log on ActiveMQ indicates knowledge about the new situation.
2.-When I send a message to the output queue SUNRECV, ActiveMQ complains that the producer is closed:

[ERROR][2006/08/25.09:47:12.039][ActiveMQ Session Task]failed to forward message: ActiveMQTextMessage {commandId = 5, responseRequired = false, messageId = ID:trabucco-43457-1156491843149-3:4:1:1:1, originalDestination = null, originalTransactionId = null, producerId = ID:trabucco-43457-1156491843149-3:4:1:1, destination = queue://SUNRECV, transactionId = null, expiration = 0, timestamp = 1156492032027, arrival = 0, correlationId = null, replyTo = null, persistent = false, type = null, priority = 0, groupID = null, groupSequence = 0, targetConsumerId = null, compressed = false, userID = null, content = null, marshalledProperties = null, dataStructure = null, redeliveryCounter = 0, size = 2, properties = null, readOnlyProperties = true, readOnlyBody = true, text = 1}([C4064]: Cannot perform operation, producer is closed.)

 After this, it is automatically queueing messages without sending them, showing the log:

[DEBUG][2006/08/25.09:47:42.721][RMI TCP Connection(4)-10.95.89.20]No subscriptions registered, will not dispatch message at this time.

 Even if SunMQ is started again, ActiveMQ is not detecting the new situation, and continues queueing messages sent to SUNRECV.

Please, make me know if more information is needed to understand the situation.
",Bug
AMQ-714,12481737,,"When you define a policy Entry using a wildcard (eg. FOO.>) in the xml configuration it is not applied as expected.

Specifically I was attempting to use a lastImageSubscriptionRecoveryPolicy on all subtopics of FOO.>

If I publish three messages to each of FOO.a, FOO.b and FOO.c and then setup a consumer (retroactive = true) to each of the topics FOO.a, FOO.b and FOO.c I receive three copies of the last message sent to any of the topics  In this case the third message sent to FOO.c.

Expected behaviour would be to receive the last message from each topic that is message three from FOO.a, FOO.b and FOO.c

More troubling is if I setup a new session with a consumer only to FOO.a and FOO.b I receive two copied of the third message sent to FOO.c.  Even though this session is not subscribed to FOO.c, presumably this is because the policy is only keeping the last message that matches the destination and returning it as the last image, regardless of if the topic matches the subscription.

With explicit policy entries for each topic (FOO.a, FOO.b) the broker returns the correct messages, so I believe the problem is with wildcard handling.  I need wildcard support here because I do not know my topic names upfront.  I would think that this would be a common scenario (like setting a last image recovery policy on all stock quotes Stock.> )",Bug
AMQ-758,12481779,,"Specifying Message Groups on the client causes serialized/ single threaded processing of messages on the server side even when server side session pooling is configured.

Please find attached  sample code along with a JUnit test ""MessageGroupTests"" that demonstrates the issue. My sample is based on Lingo. The client calls an async method solve(scenarioName) and receives progress callbacks. When the cleint calls cancel(scenarioName) during a solve, the cancel method on the server side should be received and stop the running solve. Since a single JMS session evexcutes message listeners serially, I've configured a JMS server session pool of size 20 using Spring's DefaultMessageListenerContainer class.

I've configured use of a message group via a Lingo marshaller class org.sanjiv.lingo.client.MessageGroupMarshaller. This class basically sets the JMS header  ""JMSXGroupID"" to the ""scenarioName"" in question so that when a cluster of servers are running, the cancel(scenarioName) call is directed to the server that had solve(scenarioName) called for a given ""scenarioName"".

The issue is that when the message groups are enabled using the MessageGroupMarshaller, the cancel(scenarioName) call blocks and waits for the async solve(scenarioName) method to complete on the server (which is not the right behaviour). Disabling message groups by commenting out the client side MessageGroupMarshaller marshaller in org/sanjiv/lingo/test/messageGroupContext.xml results in the call being excuted correctly.

I see that the docs for message groups say that message order is preserved, however that should not require that the second message blocks till the first message completes. Only the order in which the listeners are executes should be guaranteed to be the order of message receipt.

Let me know if you have any questions.",Bug
AMQ-668,12481286,,"+----------------------------------------
| Executing clean ActiveMQ :: Web
| Memory: 6M/9M
+----------------------------------------
DEPRECATED: the default goal should be specified in the <build> section of project.xml instead of maven.xml
DEPRECATED: t",Bug
AMQ-653,12481633,,These need to be updated to point to the incubator web site.,Bug
AMQ-513,12483917,,"Oracle driver is not supported. This because the getBlob is not implemented.


---------------------------------------stacktrace:
java.lang.IndexOutOfBoundsException
	at java.io.DataInputStream.readFully(DataInputStream.java:263)
	at org.apache.activemq.openwire.BooleanStream.unmarshal(BooleanStream.java:88)
	at org.apache.activemq.openwire.OpenWireFormat.doUnmarshal(OpenWireFormat.java:213)
	at org.apache.activemq.openwire.OpenWireFormat.unmarshal(OpenWireFormat.java:181)
	at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:135)
	at java.lang.Thread.run(Thread.java:534)

2006-01-30 15:28:06,959 DEBUG [tcp:///127.0.0.1:1376] region.AbstractRegion (AbstractRegion.java:75)     - Adding destination: queue://queue
2006-01-30 15:28:07,037 DEBUG [tcp:///127.0.0.1:1376] broker.AbstractConnection (AbstractConnection.java:194)     - Sync error occurred: java.io.IOException: Failed to recover container. Reason: java.sql.SQLException: Invalid column type: getBLOB not implemented for class oracle.jdbc.driver.T4CNumberAccessor
java.io.IOException: Failed to recover container. Reason: java.sql.SQLException: Invalid column type: getBLOB not implemented for class oracle.jdbc.driver.T4CNumberAccessor
	at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:30)
	at org.apache.activemq.store.jdbc.JDBCMessageStore.recover(JDBCMessageStore.java:158)
	at org.apache.activemq.store.ProxyMessageStore.recover(ProxyMessageStore.java:49)
	at org.apache.activemq.broker.region.Queue.<init>(Queue.java:88)
	at org.apache.activemq.broker.region.QueueRegion.createDestination(QueueRegion.java:59)
	at org.apache.activemq.broker.region.AbstractRegion.addDestination(AbstractRegion.java:76)
	at org.apache.activemq.broker.region.RegionBroker.addDestination(RegionBroker.java:188)
	at org.apache.activemq.broker.BrokerFilter.addDestination(BrokerFilter.java:122)
	at org.apache.activemq.advisory.AdvisoryBroker.addDestination(AdvisoryBroker.java:137)
	at org.apache.activemq.broker.BrokerFilter.addDestination(BrokerFilter.java:122)
	at org.apache.activemq.broker.MutableBrokerFilter.addDestination(MutableBrokerFilter.java:134)
	at org.apache.activemq.broker.region.AbstractRegion.addConsumer(AbstractRegion.java:134)
	at org.apache.activemq.broker.region.RegionBroker.addConsumer(RegionBroker.java:255)
	at org.apache.activemq.broker.BrokerFilter.addConsumer(BrokerFilter.java:66)
	at org.apache.activemq.advisory.AdvisoryBroker.addConsumer(AdvisoryBroker.java:74)
	at org.apache.activemq.broker.BrokerFilter.addConsumer(BrokerFilter.java:66)
	at org.apache.activemq.broker.MutableBrokerFilter.addConsumer(MutableBrokerFilter.java:78)
	at org.apache.activemq.broker.AbstractConnection.processAddConsumer(AbstractConnection.java:413)
	at org.apache.activemq.command.ConsumerInfo.visit(ConsumerInfo.java:275)
	at org.apache.activemq.broker.AbstractConnection.service(AbstractConnection.java:190)
	at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:60)
	at org.apache.activemq.transport.ResponseCorrelator.onCommand(ResponseCorrelator.java:82)
	at org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:68)
	at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:105)
	at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:77)
	at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:136)
	at java.lang.Thread.run(Thread.java:534)
Caused by: java.sql.SQLException: Invalid column type: getBLOB not implemented for class oracle.jdbc.driver.T4CNumberAccessor
	at oracle.jdbc.driver.DatabaseError.throwSqlException(DatabaseError.java:125)
	at oracle.jdbc.driver.DatabaseError.throwSqlException(DatabaseError.java:162)
	at oracle.jdbc.driver.Accessor.unimpl(Accessor.java:387)
	at oracle.jdbc.driver.Accessor.getBLOB(Accessor.java:1324)
	at oracle.jdbc.driver.OracleResultSetImpl.getBLOB(OracleResultSetImpl.java:1223)
	at oracle.jdbc.driver.OracleResultSetImpl.getBlob(OracleResultSetImpl.java:1414)
	at org.apache.commons.dbcp.DelegatingResultSet.getBlob(DelegatingResultSet.java:269)
	at org.apache.commons.dbcp.DelegatingResultSet.getBlob(DelegatingResultSet.java:269)
	at org.apache.activemq.store.jdbc.adapter.OracleJDBCAdapter.getBinaryData(OracleJDBCAdapter.java:62)
	at org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.doRecover(DefaultJDBCAdapter.java:343)
	at org.apache.activemq.store.jdbc.JDBCMessageStore.recover(JDBCMessageStore.java:147)
	... 25 more",Bug
AMQ-944,12481954,,"It seems that one can nto use multicast in a transportConnector.

Description of the test:
In the distribution, go into /example
Edit the build.xml in order to use multicast. for instance
Change the URL in the build.xml to :
<property name=""url"" value=""multicast://225.0.0.1:61620"" />
Start the producer: ant producer

Here is the output:
    [echo] Running producer against server at $url = multicast://225.0.0.1:61620 for subject $subject = Syntheses
    [java] Connecting to URL: multicast://225.0.0.1:61620
    [java] Publishing a Message with size 1000 to queue: Syntheses
    [java] Using non-durable publishing
    [java] Sleeping between publish 0 ms
    [java] DEBUG MulticastTransport             - Joining multicast address: /225.0.0.1
    [java] DEBUG UdpTransport                   - Consumer thread starting for: multicast://225.0.0.1:61620@0
    [java] DEBUG UdpTransport                   - Sending oneway from: multicast://225.0.0.1:61620@0 to target: /225.0.
0.1:61620 command: ConnectionInfo {commandId = 1, responseRequired = true, connectionId = ID:ZOZMA-2042-1159347487015-0:
0, clientId = ID:ZOZMA-2042-1159347487015-1:0, userName = null, password = null, brokerPath = null, brokerMasterConnecto
r = false, manageable = true}
    [java] DEBUG DefaultReplayBuffer            - Adding command ID: 1 to replay buffer: org.apache.activemq.transport.
reliable.DefaultReplayBuffer@1b3f829 object: [B@698403
    [java] DEBUG CommandDatagramSocket          - Channel: multicast://225.0.0.1:61620@0 sending datagram: 1 to: /225.0
.0.1:61620
    [java] DEBUG CommandDatagramSocket          - Channel: multicast://225.0.0.1:61620@0 about to process: ConnectionIn
fo {commandId = 1, responseRequired = true, connectionId = ID:ZOZMA-2042-1159347487015-0:0, clientId = ID:ZOZMA-2042-115
9347487015-1:0, userName = null, password = null, brokerPath = null, brokerMasterConnector = false, manageable = true}
    [java] DEBUG ReliableTransport              - Still waiting for response on: multicast://225.0.0.1:61620@0 to comma
nd: ConnectionInfo {commandId = 1, responseRequired = true, connectionId = ID:ZOZMA-2042-1159347487015-0:0, clientId = I
D:ZOZMA-2042-1159347487015-1:0, userName = null, password = null, brokerPath = null, brokerMasterConnector = false, mana
geable = true} sending replay message
    [java] DEBUG UdpTransport                   - Sending oneway from: multicast://225.0.0.1:61620@0 to target: /192.9.
211.39:61620 command: ReplayCommand {commandId = 2, firstNakNumber = 1, lastNakNumber = 1}
    [java] DEBUG DefaultReplayBuffer            - Adding command ID: 2 to replay buffer: org.apache.activemq.transport.
reliable.DefaultReplayBuffer@1b3f829 object: [B@d02b51
    [java] DEBUG CommandDatagramSocket          - Channel: multicast://225.0.0.1:61620@0 sending datagram: 2 to: /192.9
.211.39:61620
    [java] DEBUG CommandDatagramSocket          - Channel: multicast://225.0.0.1:61620@0 about to process: ReplayComman
d {commandId = 2, firstNakNumber = 1, lastNakNumber = 1}
    [java] DEBUG ReliableTransport              - Processing replay command: ReplayCommand {commandId = 2, firstNakNumb
er = 1, lastNakNumber = 1}
    [java] DEBUG DefaultReplayBuffer            - Buffer: org.apache.activemq.transport.reliable.DefaultReplayBuffer@1b
3f829 replaying messages from: 1 to: 1
*     [java] DEBUG CommandDatagramSocket          - Channel: multicast://225.0.0.1:61620@0 REDELIVERING datagram: 1 to: /
225.0.0.1:61620*
",Bug
AMQ-849,12481796,,"Noticed that when using copyOnSend feature and compression, sent messages were not being compressed. It was then found that this was due to the fact that the connection that is used to determine whether compression should be performed or not, was null for the copied message. A look into the Message found that the connection and a number of other properties of the Message were not copied in the copy(Message) 

The patch attached copies the remaining properties of the Message to the message copy.",Bug
AMQ-1018,12481902,,"I have deployed my application in Tomcat 5.5.9, which uses Activemq 4.0.1. 

To get ConnectionFactory I have written a method called getConnectionFactory.

Following way i am tring to lookup..
Context ctx = new InitialContext();
Context ctx2= (Context) initCtx.lookup(""java:comp/env"");
ConnectionFactory cf = (ConnectionFactory) ctx2.lookup(""jms/ConnectionFactory"");

3 iterations of start and stop works successfully. But when I start the application 4th time, it executes Context ctx2 = (Context)initCtx.lookup(""java:comp/env""); then it goes to next line. After that it never returns ConnectionFactory. After I notice that the application hangs..

Please find the stack which i got by running ""kill -3 <tomcat-process-pid>
 ",Bug
AMQ-903,12482960,,"I have activemq with a postgresql backend running as a standalone server, and a client application that produces persistent messages in 50 threads. Each time I run my app it pushes as many msg as it can for about 62.5 seconds after which it quits. Although initially it works fast, every time I run my app it produces less messages:

enqueue speed 50 threads: msg/second: 334.18333333333334
             second time: msg/second: 194.15
              third time: msg/second: 123.0
             fourth time: msg/second: 58.61666666666667
              fifth time: msg/second: 19.433333333333334
              sixth time: msg/second: 33.81666666666667
            seventh time: msg/second: 11.783333333333333
              eigth time: msg/second: 24.733333333333334
             ninght time: msg/second: 10.883333333333333

After I ran the above test there seem to be 50241 msg in that queue.

activemq=> select count(1) from activemq_msgs ;
 count
-------
 50241
(1 row)

activemq=> select count(1) from activemq_acks ;
 count
-------
     0
(1 row)

Note that I don't have any message consumers active for this test.

Here is the way the client app connects:

	<bean id=""jmsResourceAdapter""
		class=""org.apache.activemq.ra.ActiveMQResourceAdapter"">
		<property name=""serverUrl"" value=""tcp://localhost:61616?wireFormat.cacheEnabled=false&amp;wireFormat.tightEncodingEnabled=false"" />
	</bean>
",Bug
AMQ-890,12481701,,I think this must be an issue running under jdk 1.5 only. It shows up on Mac OS X and Linux 1.5 jvms. Remove and gc() were stumbling over each other and invalidating the iterator. I broke them apart a bit to avoid the exception. Thanks to Alan Robbins for help tracking this down.,Bug
AMQ-957,12482146,,"When running a network of brokers, the first broker shutdown (kill) works.  Subsequent brokers hang after the kill.  Pasted are the significant threads from kill-3 (after the initial kill).


""ActiveMQ ShutdownHook"" prio=10 tid=0x008ee098 nid=0x66 in Object.wait() [0x8e11f000..0x8e11f9f0]
        at java.lang.Object.wait(Native Method)
        - waiting on <0x99d61140> (a java.lang.Object)
        at org.apache.activemq.transport.failover.FailoverTransport.oneway(FailoverTransport.java:352)
        - locked <0x99d61140> (a java.lang.Object)
        at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:45)
        - locked <0x99d611c8> (a java.lang.Object)
        at org.apache.activemq.transport.ResponseCorrelator.oneway(ResponseCorrelator.java:59)
        at org.apache.activemq.network.DemandForwardingBridgeSupport.stop(DemandForwardingBridgeSupport.java:297)
        at org.apache.activemq.network.DiscoveryNetworkConnector.doStop(DiscoveryNetworkConnector.java:191)
        at org.apache.activemq.util.ServiceSupport.stop(ServiceSupport.java:58)
        at org.apache.activemq.util.ServiceStopper.stop(ServiceStopper.java:42)
        at org.apache.activemq.broker.BrokerService.stop(BrokerService.java:398)
        at org.apache.activemq.broker.BrokerService.containerShutdown(BrokerService.java:1040)
        at org.apache.activemq.broker.BrokerService$3.run(BrokerService.java:1017)


I think this goes into DemandForwardingBridgeSupport::stop.  I fixed an issue (submitted in another issue report, I believe) in 4.0.1 for the same thing.  I believe the problem is that the code is expecting to send a message to a broker when it wants to stop the network bridge.  This is problematic, since the broker may be gone.  There could be any of a number of problems going on in the network, and trying to send a message first before closing out the network bridge will only sometimes work.

I can submit a patch for this.",Bug
AMQ-967,12483907,,"
The documentation (http://incubator.apache.org/activemq/resource-adapter-properties.html) suggests that setting maximumRedeliveries to -1 means ""no maximum"", i.e. infinite retries.
However, my tests (and the code) show that -1 is equivalent to 0 (i.e. no redelivery).

The patch attempts to fix this.",Bug
AMQ-1226,12482641,,"Setup:
1 Publisher (single thread)
1 Subscriber
1 DurableTopic
1 Broker (Default configuration)

Steps to reproduce:
1) Publisher sends MapMessages that include a message number (1, 2, 3, ...)

2) Subscriber receives messages and makes sure the message numbers are in order

3) Stop the subscriber and let some messages accumulate on the broker.  Let's assume the last message received was number 11.

4) Restart the subscriber.

5) First several messages can be in reverse order.  I.E.  16, 15, 14, 13, 12

6) Then messages start coming in order.  I.E.   17, 18, 19, ...

Cause:
org.apache.activemq.broker.region.DurableTopicSubscription.deactivate()
When the consumer stops, the deactivate method moves messages that have been dispatched but not acknowledged from the ""dispatched"" LinkedList to the ""pending""  PendingMessageCursor (which is backed by a LinkedList).  These messages must be placed at the beginning of the ""pending"" list because the dispatched messages are chronologically before the pending messages already in the list.  The deactivate method iterates over the ""dispatched"" list and adds each message to the beginning of the ""pending"" list one at a time.  This reverses the order of the messages.

If the messages in question get written to JDBC, the problem can be hidden because the messages get queried in the correct order.

If the prefetch size is set to 1 the problem does not present because there will only be 1 message in the ""dispatched"" list.

Solution:
In the deactivate method, iterate the ""dispatched"" list in reverse order.

Patch against 4.1.1 attached.
",Bug
AMQ-889,12481822,,"A client that uses a transport like the failover transport can damage the broker's ability to deliver messages to other clients and ultimately cause broker resource leaks and message loss. I've found 4 issues starting on the client and ending on the broker that could be improved to make the situation a lot better. In this issue I've provided a patch for #3.

1) A failover client stores session metadata commands like ConsumerInfo in a local state tracker. When failover occurs it replays these commands verbatim to the newly connected-to broker. If the failover transport fails back to the original broker it will replay the same commands with the same ids as it already sent the broker. If the failover happens before the broker notices the old connection has gone this can result in bad mojo. Clients should probably regenerate session, consumer, and maybe connection ids.

2) When the broker detects a duplicate ClientId being sent to it it throws an exception saying so, but this does not stop the broker from processing subsequent messages on that connection. The broker should tear down the connection immediately when it sees a client thrashing about.

3) When a broker receives a certain series of ConsumerInfo add and remove commands with the same ConsumerId it leaks resources. One of the resources leaked is the knowledge of lock owners on messages out in prefetch buffers. This means those messages are stuck forever on the broker and can never be retrieved and never be gc()ed. More below.

4) Messages locked and out in prefetch buffers have no broker-side timeout. If a consumer is up, saying hello to the inactivity monitor, but otherwise doing nothing then its messages are locked forever. The broker should have a janitor that redrives stale messages. This seems like the hardest of the 4 to fix, but is one of the most important.

More on #3: One bad sequence of events is:

1) Consumer 'c' connects to the broker over a failover transport. 
2) c subscribes to a queue and addConsumer() gets called. 
3) c fails away and then fails back.
4) c replays ConsumerInfo to the broker. addConsumer() gets called again and overwrites subscription tracking from the first.

After this the broker will eventually get a double remove and there will be noisy JMX complaints etc., but the serious problem has already occurred in step 4. My patch synchronizes the add step so that the  broker is protected. The individual client will still be a bit confused, and there will still be noise when the second remove comes and JMX can't find the consumer to remove, but the resource and message leaks are taken care of.

I'll file issues on the other 3 problems if they sound valid to you and aren't already entered.",Bug
AMQ-932,12481823,,"Connections to the openwire port that are pathologically broken (for example any http request) or that die in some other way extremely quickly will lead to memory losses of aout 64Kb each time. This happens because many services are stop()ed directly in the middle of start(), and then never stopped for real, or stopped again but on an object tree with an inconsistent state. This is usually also accompanied by the JMX message:

WARN  ManagedTransportConnection     - Failed to unregister mbean: org.apache.activemq:BrokerName=localhost,Type=Connection,ConnectorName=default,Connection=25

But that is a cosmetic symptom and not critical (and this has otherwise nothing to do with JMX).

My patch is a band-aid that is functional but I'm not very happy with it. The patch changes some service logic so that if stop is called in the middle of start, the stop is instead queued and called at the end of start. There will still be multiple stops, and you'll still see the cosmetic JMX error from the second ineffectual stop, but the first stop cleans up correctly so there are no leaks.

I think there's probably a better solution, but it was tough to see what. I'd appreciate better ideas. Possibly something involving moving the dangerous operations (wire format negotiation etc) out of start?

I am working on a unit test, but I can't promise I will have something to submit. I'm having to play JVM games to detect the problem in a unit test and that might not fly for general purpose use.",Bug
AMQ-1006,12481899,,"In case that multiple consumers with different message selectors are registered for the same destination, messages are not evenly divided.

To reproduce, register 2 consumers for prio 9, one for prio 4. Of 1000 messages with prio 9 both prio 9 consumers should receive 500. Actually, the first consumer gets 667 messages, the second 333.

This is caused by the consumer shifting strategy in the RoundRobinDispatchPolicy which rotates consumers, even if they did not match.

The attached file contains a testcase illustrating the behavior and a patch for RoundRobinDispatchPolicy, that shifts the first matching consumer instead of the first.
",Bug
AMQ-959,12481837,,"When sending messages to composite destinations, for each simple destination a copy of the original message is created an sent. However, it's internal messageId is reused. As the messageId carries the brokerSequenceId, which is used as primary key in the jdbc message store, this is overwritten by the last send. All messages refer to the same store row so that the first acknowledge removes the content for all MessageReferences in memory.

The attached patch creates a copy of the messageId when copying a message.

Regards,
Holger


",Bug
AMQ-1029,12481908,,"The BrokerService keeps the configured TransportConnectors in a list called transportConnectors. In startAllConnectors, the list is traversed and each connector is started through startTransportConnector(). This method checks if JMX is configured, and if so, it called connector.asManagedConnector() which returns a new instance of a TransportConnector. This instance is started.

But in the  transportConnectors list of BrokerService, the old, unstarted object is still existent. Since a TransportConnector starts a TransportServiceDetector thread, the old, unstarted instance contains a TSD that is not active. But the started TSD isn't referenced anymore.

On shutdown, the old, unstarted TC and subsequently TSD are stopped. The ""lost"" instance can't be touched anymore.

My patch does this: During spin-up, startTransportConnector() returns the instance that is started. The started instances are collected in an arraylist, this list replaces transportConnectors after startup.

Thanks to jstrachan for being patient on irc.
",Bug
AMQ-929,12482031,,"XmlSpy reports http://people.apache.org/repository/org.apache.activemq/xsds/activemq-core-4.1-incubator-SNAPSHOT.xsd is invalid with the following message:

<xs:element ref='tns:topic'> makes the content model non-deterministic. Possible causes: name equality, overlapping occurance or substitution groups.

It's complaining because it has no way to validate whether it should validate against tns:topic/tns:queue or the xs:any for the following element

<xs:element name='destination' minOccurs='0' maxOccurs='1'>
   <xs:complexType>
      <xs:choice minOccurs='0' maxOccurs='1'>
         <xs:element ref='tns:queue'/>
         <xs:element ref='tns:topic'/>
         <xs:any/>
      </xs:choice>
   </xs:complexType>
</xs:element>

Possible fix adapted from http://www.thescripts.com/forum/threadedpost1605613.html:

<xs:element name=""destination"" minOccurs=""0"" maxOccurs=""1"">
	<xs:complexType>
		<xs:choice minOccurs=""0"" maxOccurs=""1"">
			<xs:element name=""extensions"">
				<xs:sequence maxOccurs=""1"">
					<xs:any/>				
				</xs:sequence>
			</xs:element>
			<xs:element ref=""tns:queue""/>
			<xs:element ref=""tns:topic""/>
		</xs:choice>
	</xs:complexType>
</xs:element>

But I suspect difficult to fix as the XSD is autogenerated + you'll lose backwards compatability with previous documents. The problem occurs repeatedly throughout the schema.

",Bug
AMQ-1161,12481952,,"PooledSession does not appear to use the Topic supplied to the createPublisher(topic) method. When the publish(Message) method is called on the returned TopicPublisher instance, an UnsupportedOperationException is thrown (""A destination must be specified."").
Some simple digging turns up the fact that the ActiveMQTopicPublisher instance nested inside PooledTopicPublisher gets initialized with a ProducerInfo whose destination is null. Looks like PooledSession.getTopicPublisher() is responsible for creating the publisher from the contained ActiveMQSession, but does not supply a destination (explicitly passes null).

Sample code to recreate issue (also attached is Junit test case):
		ActiveMQTopic topic = new ActiveMQTopic(""test"");
		PooledConnectionFactory pcf = new PooledConnectionFactory();
		pcf.setConnectionFactory(new ActiveMQConnectionFactory(""vm://test""));

		TopicConnection conn = (TopicConnection)pcf.createConnection();
		TopicSession session = conn.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
		TopicPublisher publisher = session.createPublisher(topic);
		publisher.publish(session.createMessage());
",Bug
AMQ-1192,12481986,,"I have added to the STOMP tester so it can take command line args for number of message to be read/sent.  Using this the following tests will show the problems

#1)  All messages are lost when a client does STOMP disconnect

1.1 start a subscriber to read 5 messages
./activemq_tester -d sub -m 5
1.2 start a publisher to publish 10 messages
./activemq_tester -d pub -m 10
1.3 run subscriber again to get the remaining 5 messages
./activemq_tester -d sub -m 5

---> No messages are available for the second run of the test subscriber.  It seems there is no way to shutdown a stomp client without loosing all the messages on that q.

Output here.

-bash-2.05b$ ./activemq_tester -d pub -m 10
Connecting......OK
Sending connect message.OK
Reading Response.Response: CONNECTED, 
OK
Sending Message.Sending Message: This is message number 0
Sending Message: This is message number 1
Sending Message: This is message number 2
Sending Message: This is message number 3
Sending Message: This is message number 4
Sending Message: This is message number 5
Sending Message: This is message number 6
Sending Message: This is message number 7
Sending Message: This is message number 8
Sending Message: This is message number 9
OK
Sending Disconnect.OK
Disconnecting...OK

--- first run of subscriber ----------------------
-bash-2.05b$ ./activemq_tester -d sub -m 5
Connecting......OK
Sending connect message.OK
Reading Response.Response: CONNECTED, 
OK
Sending Subscribe.OK
Reading Subscribed Messsages.Received: MESSAGE, This is message number 0
Received: MESSAGE, This is message number 1
Received: MESSAGE, This is message number 2
Received: MESSAGE, This is message number 3
Received: MESSAGE, This is message number 4
OK
Sending Disconnect.OK
Disconnecting...OK



----- second run of subscriber -----------------
-bash-2.05b$ ./activemq_tester -d sub -m 5
Connecting......OK
Sending connect message.OK
Reading Response.Response: CONNECTED, 
OK
Sending Subscribe.OK
Reading Subscribed Messsages.

=======> None of the remaning message numbers 5...9 are available.  They are lost.


2) Now to see the ghost STOMP subscriber problem, hit control-C to stop the subscriber.
Then rerun subscriber and publisher and see the following output.....
(publisher output not shown here, same as before)

-bash-2.05b$ ./activemq_tester -d sub -m 5
Connecting......OK
Sending connect message.OK
Reading Response.Response: CONNECTED, 
OK
Sending Subscribe.OK
Reading Subscribed Messsages.Received: MESSAGE, This is message number 1
Received: MESSAGE, This is message number 3
Received: MESSAGE, This is message number 5
Received: MESSAGE, This is message number 7
Received: MESSAGE, This is message number 9
OK
Sending Disconnect.OK
Disconnecting...OK


",Bug
AMQ-1147,12481886,,"The cast to the concrete class at ActiveMQManagedConnectionFactory:50 fails:

    public void setResourceAdapter(ResourceAdapter adapter) throws ResourceException {
        this.adapter = (ActiveMQResourceAdapter) adapter;

org.springframework.beans.TypeMismatchException: Failed to convert property value of type [$Proxy63] to required type [javax.resource.spi.ResourceAdapter] for property 'resourceAdapter'; nested exception is java.lang.ClassCastException: $Proxy63 cannot be cast to org.apache.activemq.ra.ActiveMQResourceAdapter
Caused by: java.lang.ClassCastException: $Proxy63 cannot be cast to org.apache.activemq.ra.ActiveMQResourceAdapter
    at org.apache.activemq.ra.ActiveMQManagedConnectionFactory.setResourceAdapter(ActiveMQManagedConnectionFactory.java:50)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.springframework.beans.BeanWrapperImpl.setPropertyValue(BeanWrapperImpl.java:786)
[...]

Spring (2.0.3 build 66) config:

	<aop:aspectj-autoproxy />

	<aop:spring-configured />

	<bean id=""jms.managedConnectionFactory"" class=""org.apache.activemq.ra.ActiveMQManagedConnectionFactory"">
		<property name=""resourceAdapter"">
			<ref local=""jms.resourceAdapter"" />
		</property>
	</bean>

	<bean id=""jms.resourceAdapter"" class=""org.apache.activemq.ra.ActiveMQResourceAdapter"">
		<property name=""serverUrl"">
			<value>${amq.serverUrl}</value>
		</property>
	</bean>

There's probably a workaround for this, but it's still annoying.",Bug
AMQ-1128,12481849,,"When setting create=false in ActiveMQConnectionFactory.brokerUrl, the VMTransportFactory's doCompositeConnect method fails with:

Invalid connect parameters: {create=false}

Removing this option from the options map when retrieving it fixes this bug.  Patch attached.
",Bug
AMQ-1442,12482472,,"ActiveMQ binary distribution (apache-activemq-4.1.1.tar.gz) has a compatibility issue with the bundled spring binary. xbean-spring-2.8.jar binary is depending on spring-1.2.x binary but the mentioned ActiveMQ distribution comes with spring-2.x binary and it's not compatible. it throws the following exception when you have the default spring-2.x binary :

18:36:34,069 WARN  [ServiceController] Problem starting service jboss.jca:service=RARDeployment,name='activemq-ra.rar'
javax.resource.spi.ResourceAdapterInternalException: Failed to startup an embedded broker: xbean:broker-config.xml, due to: org.springframework.beans.factory.BeanDefinitionStoreException: Unrecognized xbean element mapping: beans in namespace http://activemq.org/config/1.0
        at org.apache.activemq.ra.ActiveMQResourceAdapter.start(ActiveMQResourceAdapter.java:83)
        at org.jboss.resource.deployment.RARDeployment.startService(RARDeployment.java:109)

to work around this issue, you have to provide a spring-1.2.x binary.

steps to reproduce this problem :
make ActiveMQ embedded inside JBossAS, uncomment 
<config-property-value>xbean:broker-config.xml</config-property-value>
which tells the AMQ to process broker-config.xml

the complete error log is attached
",Bug
AMQ-1321,12482444,,"Default topic SubscriptionRecoveryPolicy is a FixedCountSubscriptionRecoveryPolicy, that can eventually lead to huge amount of memory wasted by messages in topics. James recommended to set it to NoSubscriptionRecoveryPolicy.
I'm sending a patch to do so in 4.1 branch.",Bug
AMQ-1448,12482431,,"After building maven-activemq-perf-plugin as described in http://activemq.apache.org/activemq-performance-module-users-manual.html and then changing to the performance folder, the installed plug-in cannot be found by maven.  The reason is an outdated groupId section for the plugin configuration.

The groupId needs to have .tooling as postfix.  See attached patch file.

",Bug
AMQ-1443,12482418,,"I am trying to build ActiveMQ as found under https://svn.apache.org/repos/asf/activemq/tags/activemq-4.1.1.

The build fails due to missing Log4j dependencies.  I had to change the scope of log4j from runtime to compile to get it compiled.
",Bug
AMQ-1624,12482370,,"After a normal build, the blob-message fileserver webapp dosn't work.
The classes necessary for file-upload will are not included.

The patch include the class-files from fileserver module to the assambly and insert the essential block to the activemq.xml",Bug
AMQ-1480,12481984,,"Every time I read one message (with REST/GET) from a queue with more than 1 message,  two messages are deleted.",Bug
AMQ-1545,12483413,,Opening three browser windows of the Chat sample is resulting in it not working properly.  Each message sent from one window gets picked up by only one of the three browser windows (in rotating fashion).  It is possible to move to a publish-subscribe model for the javascript comprising this example so all windows get each message sent?,Bug
AMQ-1616,12482344,,"According to the JMS Spec, section 4.3.5, ""Closing a closed connection must NOT throw an exception.""",Bug
AMQ-1315,12482342,,The links for the rss and atom view of the queues (in queues.jsp) are broken. They render an error page (something like could not create connection factory). ,Bug
AMQ-1810,12482165,,"If a client tries to connect to the broker and the broker is not available the client can't be stopped because of a deadlock in ActiveMQConnection.

The problem is that the thread that wants to establish the connection is stuck in {{syncSendPacket()}} which is called from inside {{ensureConnectionInfoSent()}} which is {{synchronized}} (and holds the lock on the ActiveMQConnection instance). The call to {{close()}} calls {{stop()}} and this will call {{checkClosedOrFailed()}} which is {{synchronized}}, too, and there is the deadlock.

The patch has removed the {{synchronized}} on the {{ensureConnectionInfoSent()}} and uses a mutex instead to prevent calling the method unsynchronized.

Another problem is that {{PooledConnectionFactory}} is triggered from Spring classes to create connections even if the PooledConnectionFactory was stopped (call to {{stop()}} and the new created connections can not be stopped normally later. 
I have added a {{stopped}} flag that prevents the creation of new connecions after {{stop()}} was called.

I think the issue AMQ-1470 is related to the same problem. 
The patch also contains the patch for AMQ-1791.",Bug
AMQ-1961,12482230,,"I create a vm queue with ten messages. I then create a consumer, dequeue the top message (message #1), and close that consumer. If I then create a second consumer, and try to dequeue the top message (message #2), there is a small chance that this will unexpectedly fail, and the request will time out. This is one problem.

After this happens, examining the queue with a queue browser shows message #2 still on the queue. However, subsequent attempts to dequeue this message will always time out. Messages #3-10 will be in the same state; they will still be in the queue, but they cannot be dequeued. This is a worse problem, as it means that we can not reuse this queue.

The problem arises more frequently as there are more consumers. With two or three consumers, it comes up sporadically. With twenty or more consumers, it happens almost 100% of the time. I've attached a test case which demonstrates the bug consistenty.",Bug
AMQ-1743,12482494,,"The 5.1.0 distribution does not include the xstream jars, which are needed for the new JSON / XML to Java Map translation that is part of the Stomp transport.",Bug
AMQ-1740,12482488,,"The Web console fails with java.lang.NoClassDefFoundError: com/thoughtworks/xstream/XStream while browsing the queues through atom or rss. Please refer to the attached screeshot.

Resolution - 
Copied the latest xstream jar, xstream-1.3.jar, into the lib directory of the activemq distribution (apache-activemq-5.1.0\lib) and restarted activemq. This resolved the issue and now the queues can be browsed through atom or rss.",Bug
AMQ-2170,12483685,,"http://activemq.apache.org/per-destination-policies.html says that the advisory messages available for a destination are
advisoryForConsumed
advisoryForDelivered
advisoryForDiscardedMessages
advisoryForSlowConsumers
advsioryForFastProducers
advisoryWhenFull

However, the page at http://activemq.apache.org/advisory-message.html says
advisoryForConsumed
advisoryForDelivery (different)
advisoryForDiscardingMessages (different)
advisoryForSlowConsumers
advisdoryForFastProducers (different)
advisoryWhenFull

The two pages should say the same thing (currently the 2nd page matches the code); and you should also consider changing the name of 'advisdoryForFastProducers' to be 'advisoryForFastProducers' in the code and the documentation to remove the typo.",Bug
AMQ-1274,12481731,,"If Active MQ is installed in a directory that contains spaces (i.e. E:\Program Files\apache-activemq-4.2-SNAPSHOT) the win32 service wrapper installer does not work.

Just need to add quotes around path variables in bin\win32\wrapper.conf",Bug
AMQ-2213,12483738,,"The equals method return false even when it is executed on the same object for the specialized classes of Session (TopicSession, QueueSession). If those objects are held within a List, the contains method would return false even if the object in question is already in the list. 

This is a minor issue as the cleanups are normally done on the connection level and users shouldn't need to keep track of open sessions for a later cleanup.
 

",Bug
AMQ-1263,12481992,,"Start two brokers in a JDBC master/slave configuration.  One will become master, the other slave.
Shutdown the database.
The slave will immediately begin emitting emitting database connection exceptions messages from the DefaultdatabaseLocker.
Bring up the database again.
The slave continues to emit database error messages and all subsequent attempts by the DefaultdatabaseLocker to issue its locking query will fail.

The problem is that the DefaultdatabaseLocker grabs one db connection at startup and never releases it.  Therefore unless the JDBC connection has an auto-reconnect feature, the slave broker is dead in the water, because its Connection is bad.  The fix is to allocate a new Connection and PreparedStatement on every iteration of the database locker loop, and free the statement/connection on any Exception.

",Bug
AMQ-2334,12483757,,"Shared master/slave setup, described here http://activemq.apache.org/shared-file-system-master-slave.html
Scenario:
1. Transacted consumer receives a message
2. Transacted consumer disconnects prior to committing
3. Transacted consumer #2 receives the same message.

Normally consumer #2 sees that message as getJMSRedelivered() = true.  However, if the broker fails and another takes over from the data dir between step 1 and 3, the redelivery is set as false - even though a consumer has, in fact, seen the message before.  See attached unit test.",Bug
AMQ-2526,12483785,,"Imagine you are processing a few jobs by a thread pool. A timeout is set for the whole batch. A job should send a JMS message. If the timeout expires before all the jobs are completed the pool will interrupt still running jobs. 

Most of the time the interruption will be caught and processed deep inside of ActiveMQ TCP transport classes. While I'm not entirely convinced it's a good idea to shut down and reopen the connection to the ActiveMQ server if a client thread is merely interrupted what really seems ugly is:

15:12:53,745 ERROR [org.apache.activemq.transport.tcp.TcpTransport] Could not stop service: tcp:///x.x.x.x:61616. Reason: java.lang.InterruptedException
java.lang.InterruptedException
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquireSharedNanos(AbstractQueuedSynchronizer.java:1200)
	at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:245)
	at org.apache.activemq.transport.tcp.TcpTransport.doStop(TcpTransport.java:482)
	at org.apache.activemq.util.ServiceSupport.stop(ServiceSupport.java:69)
	at org.apache.activemq.transport.tcp.TcpTransport.stop(TcpTransport.java:499)
	at org.apache.activemq.transport.InactivityMonitor.stop(InactivityMonitor.java:113)
	at org.apache.activemq.transport.TransportFilter.stop(TransportFilter.java:64)
	at org.apache.activemq.transport.WireFormatNegotiator.stop(WireFormatNegotiator.java:87)
	at org.apache.activemq.util.ServiceSupport.dispose(ServiceSupport.java:43)
	at org.apache.activemq.transport.failover.FailoverTransport.handleTransportFailure(FailoverTransport.java:201)
	at org.apache.activemq.transport.failover.FailoverTransport.oneway(FailoverTransport.java:471)
	at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:40)
	at org.apache.activemq.transport.ResponseCorrelator.oneway(ResponseCorrelator.java:60)
	at org.apache.activemq.ActiveMQConnection.doAsyncSendPacket(ActiveMQConnection.java:1214)
	at org.apache.activemq.ActiveMQConnection.asyncSendPacket(ActiveMQConnection.java:1208)
	at org.apache.activemq.ActiveMQSession.send(ActiveMQSession.java:1643)
	at org.apache.activemq.ActiveMQMessageProducer.send(ActiveMQMessageProducer.java:227)
	at org.apache.activemq.ActiveMQMessageProducerSupport.send(ActiveMQMessageProducerSupport.java:241)

and the reason for it is that the await call on the CountDownLatch in TcpTransport::doStop will throws an InterruptedException if the calling thread is already interrupted. No attempt is made (in both 5.2 or 5.3) to gracefully process InterruptedException, the exception itself is logged as ERROR with a rather menacing message and the log file gets full of meaningless stack traces although no real harm was done.

Calling latch.await(1,TimeUnit.SECONDS) in a try block seems like a no-brainer but there could be even smarted approaches to processing InterruptedExceptions differently than, say, IOEs and other genuine problems. ",Bug
AMQ-2673,12483660,,"When a Producer is started before a Consumer we get a ""javax.jms.JMSException: Unmatched acknowledege"".

The same application runs fine when a Producer is started after a Consumer.

Attached you will find full repro instruction code and scripts.",Bug
AMQ-2414,12483691,,"JDBC Master/Slave doesn't work properly for mysql cluster when the master and slave brokers are using different MYSQL frontends as would be required in a HA setup.  The code currently locks the database using a TABLE lock which are not cluster wide in mysql.
http://dev.mysql.com/doc/refman/5.1/en/mysql-cluster-limitations-multiple-nodes.html

The default code path uses a SELECT FOR UPDATE to get a lock.  This is supported in mysql cluster.
The attached patch works for me.",Bug
AMQ-2301,12483583,,"Using the AMQ web console and watching the number of currently open connections (http://localhost:8161/admin/connections.jsp), there are a number of empty lines listed. See screenshot.",Bug
AMQ-2674,12483621,,"Slow consumer problem when using java explicit configuration while the same application runs fine when using an equivalent (?) activemq.xml configuration.

Attached you will find full repro instruction code and scripts.",Bug
AMQ-2761,12483482,12483687,"We are seeing an issue with ActiveMQ Topic subscription when there is an uncaught exception.

It appears to be related to an old report (but who knows) :
http://mail-archives.apache.org/mod_mbox/activemq-users/200805.mbox/<17189972.post@talk.nabble.com> 

Basically, what happens is our Consumer (onMessage) was throwing an NPE. After that happens, the consumer no longer receives any more messages.

Following it through in the debugger - when the exception is thrown, what we see is the the ""ActiveMQ Session Task"" thread completes... 
After that, it never seems to execute again. Seems some state in the PooledTaskRunner gets borked? Investigating further - but at first glance it appears it thinks the connection is shutting down...
",Bug
AMQ-2612,12483480,,"Scenario:
1. Configure polling consumer (prefetch=0), with onMessage()-style processing, e.g. with Spring's DefaultMessageListenerContainer.
2. Restart broker.
3. Notice consumer does not consumer messages anymore.

In client application this may show up during short network interruptions as reconnect message in logs/console + processing stoppage.

See http://old.nabble.com/ActiveMQ-reconnect-issue-with-consumer.prefetchSize%3D0-td27574923.html for more context.",Bug
AMQ-2557,12483178,,"This is an exception test with the following set up. 

ProducerTool sends 200000 non-persistent messages to a Topic with the message size = 2000. 

The ConsumerTool that reads the messages from the Topic has a sleep time of 2 msec, thus creating a slow consumer scenario.   

Temp store = 300mb, Topic memoryLimit = 30mb, producerFlowControl = false. 

The consumer begins to receive messages and messages get written out to the temp store as expected, because the slow consumer cannot keep up with the message load and temp topic fills up. However, when the temp store eventually fills as well, the broker goes comatose. It no longer accepts clients connections and stops dispatching messages to the slow consumer.  You'd expect the broker to at least continue dispatching messages to the slow consumer while the producer is blocked awaiting the temp store to free up. If I double the temp store capacity, everyone is a happy camper. I'll attach a thread dump.



",Bug
AMQ-2528,12483585,,"According to the JMS specification, an ""empty string"" message selector indicates no message selector (i.e., all messages should be selected):

""A message selector is a String whose syntax is based on a subset of the SQL92 conditional expression syntax. If the value of a message selector is an empty string, the value is treated as a null and indicates that there is no message selector for the message consumer.""

However, if org.apache.activemq.broker.region.Queue#removeMatchingMessages(String selector)  with selector = """", the following stacktrace is generated:

javax.jms.InvalidSelectorException: 
	at org.apache.activemq.selector.SelectorParser.parse(SelectorParser.java:72)
	at org.apache.activemq.selector.SelectorParser.parse(SelectorParser.java:46)
	at org.apache.activemq.broker.region.Queue.createSelectorFilter(Queue.java:1200)
	at org.apache.activemq.broker.region.Queue.removeMatchingMessages(Queue.java:908)
	at org.apache.activemq.broker.region.Queue.removeMatchingMessages(Queue.java:898)
	at com.invoqsystems.foundation.utility.AMQUtility.deleteMessages(AMQUtility.java:192)
	at com.invoqsystems.foundation.utility.AMQUtilityTest.testDeleteMessages(AMQUtilityTest.java:187)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.junit.internal.runners.TestMethodRunner.executeMethodBody(TestMethodRunner.java:99)
	at org.junit.internal.runners.TestMethodRunner.runUnprotected(TestMethodRunner.java:81)
	at org.junit.internal.runners.BeforeAndAfterRunner.runProtected(BeforeAndAfterRunner.java:34)
	at org.junit.internal.runners.TestMethodRunner.runMethod(TestMethodRunner.java:75)
	at org.junit.internal.runners.TestMethodRunner.run(TestMethodRunner.java:45)
	at org.junit.internal.runners.TestClassMethodsRunner.invokeTestMethod(TestClassMethodsRunner.java:71)
	at org.junit.internal.runners.TestClassMethodsRunner.run(TestClassMethodsRunner.java:35)
	at org.junit.internal.runners.TestClassRunner$1.runUnprotected(TestClassRunner.java:42)
	at org.junit.internal.runners.BeforeAndAfterRunner.runProtected(BeforeAndAfterRunner.java:34)
	at org.junit.internal.runners.TestClassRunner.run(TestClassRunner.java:52)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:38)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)
Caused by: org.apache.activemq.selector.ParseException: Parse error at line 0, column 0.  Encountered: <EOF>
	at org.apache.activemq.selector.SelectorParser.generateParseException(SelectorParser.java:1196)
	at org.apache.activemq.selector.SelectorParser.jj_consume_token(SelectorParser.java:1148)
	at org.apache.activemq.selector.SelectorParser.unaryExpr(SelectorParser.java:453)
	at org.apache.activemq.selector.SelectorParser.multExpr(SelectorParser.java:375)
	at org.apache.activemq.selector.SelectorParser.addExpression(SelectorParser.java:344)
	at org.apache.activemq.selector.SelectorParser.comparisonExpression(SelectorParser.java:196)
	at org.apache.activemq.selector.SelectorParser.equalityExpression(SelectorParser.java:141)
	at org.apache.activemq.selector.SelectorParser.andExpression(SelectorParser.java:120)
	at org.apache.activemq.selector.SelectorParser.orExpression(SelectorParser.java:99)
	at org.apache.activemq.selector.SelectorParser.JmsSelector(SelectorParser.java:91)
	at org.apache.activemq.selector.SelectorParser.parse(SelectorParser.java:69)
	... 26 more


",Bug
AMQ-2944,12483836,,"I am using a single broker configured to accept both tcp and ssl connections using the configuration below

<transportConnectors>
       <transportConnector name=""openwire"" uri=""tcp://0.0.0.0:61616""/>
       <transportConnector name=""ssl"" uri=""ssl://0.0.0.0:61617""/>
</transportConnectors>

The clients are configured to use the failover transport over ssl to connect to a single broker (e.g. URL: failover:ssl://Host:61616).  Upon startup the client correctly connects to the broker on port 61617 via ssl.  I then simulate a network outage and the transport is interrupted and waits for the connection to become available.  After a short amount of time the Broker detects inactivity on the connection and then drops the connection (viewed via JMX and Jconsole).  When the network connection is restored, the client reconnects to broker on port 61616 using tcp instead of ssl on port 61617 (not good if you require ssl encryption).

It appears that the ordering of the transportConnectors in the activemq.xml file affects which transport is used upon resumption of an interrupted failover transport.  It turns out that upon reconnection the first defined transport will always be used regardless of what transport was specified in the original client connection url.  Changing the ordering to the following fixes the problem and upon reconnection the ssl transport will be used.  However, the reverse issue will occur for clients that originally connection via tcp transport where upon reconnection they will connect via ssl transport instead of tcp.

<transportConnectors>
       <transportConnector name=""ssl"" uri=""ssl://0.0.0.0:61617""/>
       <transportConnector name=""openwire"" uri=""tcp://0.0.0.0:61616""/>
</transportConnectors>",Bug
AMQ-2712,12482327,,"A QueueBrowser cannot be used on a transacted session.  During the call to destroyConsumer(), the call:

            if (session.getTransacted()) {
                session.commit();
            }

will fail and the consumer will not be closed.

Additionally, when calling nextElement(), the ackLater() method (called by beforeMessageIsConsumed(), called by receiveNoWait(), called by nextElement()) will throw a JMSException.

The latter issue may be related to https://issues.apache.org/activemq/browse/AMQ-2659, but the former is not.

The workaround is to always use non-transacted QueueBrowsers and manually handle any issues if you try to consume a message found in the QueueBrowser.",Bug
AMQ-2974,12483510,,"We are using the NMS stomp-client to communicate with ActiveMQ. Our Stomp-Clients are mobile devices connected via GSM and loose the connection from time to time. Therefore we are using durable subscriptions and the clients use a fixed but unique Client-ID. When they loose the connection they can't reconnect because the server doesn't release the (failed) connection.

The server log looks like this:
INFO  | Transport failed: java.io.IOException: Broker: localhost - Client: client1 already connected from /xxx.xxx.xxx.xxx:yyyyy | org.apache.activemq.broker.TransportConnection.Transport | ActiveMQ Transport: tcp:///xxx.xxx.xxx.xxx:yyyyy
java.io.IOException: Broker: localhost - Client: client1 already connected from /xxx.xxx.xxx.xxx:zzzzz
        at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:39)
        at org.apache.activemq.transport.stomp.ProtocolConverter$2.onResponse(ProtocolConverter.java:510)
        at org.apache.activemq.transport.stomp.ProtocolConverter.onActiveMQCommand(ProtocolConverter.java:579)
        at org.apache.activemq.transport.stomp.StompTransportFilter.oneway(StompTransportFilter.java:58)
        at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:40)
        at org.apache.activemq.broker.TransportConnection.dispatch(TransportConnection.java:1247)
        at org.apache.activemq.broker.TransportConnection.processDispatch(TransportConnection.java:808)
        at org.apache.activemq.broker.TransportConnection.dispatchSync(TransportConnection.java:768)
        at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:187)
        at org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:69)
        at org.apache.activemq.transport.stomp.StompTransportFilter.sendToActiveMQ(StompTransportFilter.java:81)
        at org.apache.activemq.transport.stomp.ProtocolConverter.sendToActiveMQ(ProtocolConverter.java:140)
        at org.apache.activemq.transport.stomp.ProtocolConverter.onStompConnect(ProtocolConverter.java:503)
        at org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommand(ProtocolConverter.java:192)
        at org.apache.activemq.transport.stomp.StompTransportFilter.onCommand(StompTransportFilter.java:70)
        at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)
        at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:219)
        at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:201)
        at java.lang.Thread.run(Thread.java:636)
Caused by: javax.jms.InvalidClientIDException: Broker: localhost - Client: client1 already connected from /xxx.xxx.xxx.xxx:yyyyy
        at org.apache.activemq.broker.region.RegionBroker.addConnection(RegionBroker.java:242)
        at org.apache.activemq.broker.BrokerFilter.addConnection(BrokerFilter.java:85)
        at org.apache.activemq.broker.BrokerFilter.addConnection(BrokerFilter.java:85)
        at org.apache.activemq.advisory.AdvisoryBroker.addConnection(AdvisoryBroker.java:78)
        at org.apache.activemq.broker.BrokerFilter.addConnection(BrokerFilter.java:85)
        at org.apache.activemq.broker.BrokerFilter.addConnection(BrokerFilter.java:85)
        at org.apache.activemq.broker.MutableBrokerFilter.addConnection(MutableBrokerFilter.java:91)
        at org.apache.activemq.broker.TransportConnection.processAddConnection(TransportConnection.java:694)
        at org.apache.activemq.broker.jmx.ManagedTransportConnection.processAddConnection(ManagedTransportConnection.java:83)
        at org.apache.activemq.command.ConnectionInfo.visit(ConnectionInfo.java:137)
        at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:309)
        at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:185)
        ... 10 more

At the same time the NMS-Client logs the following:
StompWireFormat - Received ERROR command: Broker: localhost - Client: client1 already connected from /xxx.xxx.xxx.xxx:yyyyy

The connection is not being released even after more than 10 minutes. I have to restart the ActiveMQ server to be able to reconnect earlier.

For me it looks quite similar to the following Issue: https://issues.apache.org/activemq/browse/AMQ-2831",Bug
AMQ-2917,12483951,,"As per the title, the activemq script is determining the conf/ and data/ directories off ACTIVEMQ_HOME, instead of off ACTIVEMQ_BASE. This has a nasty side effect in that you can't run two different broker instances on the same machine, as the script tries to store the PID for each in the sample place. Ouch! 

Have attached a fix. ",Bug
AMQ-2942,12483823,,"Well, you can however the configuration isn't applied.  This patch sorts that out.  Note that I couldn't automate a test for this as I had to manually kill off one of the brokers to get the behavior to manifest itself, as described [here|http://fusesource.com/issues/browse/MB-733].",Bug
AMQ-3012,12483831,,"Symptom
=======
org.apache.activemq.transport.http.HttpTunnelServlet.java contains the following logic:

    protected BlockingQueueTransport createTransportChannel(HttpServletRequest request, HttpServletResponse response) throws IOException {
...
            clients.put(clientID, answer);
            Transport transport = answer;
            try {
                HashMap options = new HashMap(transportOptions);
                transport = transportFactory.serverConfigure(answer, null, options);
            } catch (Exception e) {
               IOExceptionSupport.create(e);
            }

If the call to transportFactory.serverConfigure(...) throws an exception, IOExceptionSupport.create(e) is called, which wraps the exception in an IOException, but that IOException is never thrown.

Solution
=======
See attached patch file.  Add a ""throw"" clause to propagate the IOException.
",Bug
AMQ-3123,12494988,,"When an ajax client is subscribed to multiple topics, the ""id"" attribute of a returned <response> element indicates to JavaScript which callback function should process the message.  Currently, the MessageListenerServlet returns multiple copies of each message, 1 per subscription.  So all callback functions will receive all messages.

For example, if I send messages 'A1' and 'A2' to /topic/topicA, and messages 'B1' and 'B2' to /topic/topicB, my ajax client gets the following message:
<ajax-response>
  <response id='handlerA' destination='topic://topicA' >A1</response>
  <response id='handlerA' destination='topic://topicA' >B1</response>
  <response id='handlerA' destination='topic://topicA' >A2</response>
  <response id='handlerA' destination='topic://topicA' >B2</response>
  <response id='handlerB' destination='topic://topicB' >A1</response>
  <response id='handlerB' destination='topic://topicB' >B1</response>
  <response id='handlerB' destination='topic://topicB' >A2</response>
  <response id='handlerB' destination='topic://topicB' >B2</response>
</ajax-response>

Further, these messages are constantly re-delivered to the client.  (They are never removed from the unconsumedMessages linked list in AjaxListener.)

If https://issues.apache.org/jira/secure/attachment/12467757/all_messages_are_delivered_to_ajax_clients.patch from https://issues.apache.org/jira/browse/AMQ-3094 is applied, the duplication is reduced, but the ""id"" values for the ""topicB"" messages are still incorrect.

<ajax-response>
  <response id='handlerA' destination='topic://topicA' >A1</response>
  <response id='handlerA' destination='topic://topicA' >B1</response>
  <response id='handlerA' destination='topic://topicA' >A2</response>
  <response id='handlerA' destination='topic://topicA' >B2</response>
</ajax-response>

I've attached a test which demonstrates the problem.  This patch will conflict with the one attached to AMQ-3094, but the conflicts should be easy to resolve.",Bug
AMQ-3380,12512008,,"This is a pure master/slave setup with multiple transacted exclusive consumers.  When the master is stopped, the exclusive consumer is switched (which seems odd to me).  This would be okay except the prior consumer is not rolled back.  The new consumer does not see all the messages (presumably since the prior consumer was not rolled back).  In rare cases in my environment, I have experienced message loss -- a message does not get sent on the new consumer.",Bug
AMQ-3948,12600391,,"We have a java web-service (running in Jetty) that dynamically instantiates an ActiveMQ queue and send messages to the queue - the messages are integers (i.e. 1, 2, 3, etc). We have from one to many consumers that read from this queue to process these messages. Each consumer is started from a single process but each consumer is running in it's own thread or process. When we have multiple consumers running, they occasionally will pick up the same integer or message from the queue. This is not desired. If a consumer reads a message, we don't want other consumers to retrieve that same message. We're fairly new to ActiveMQ but those we're telling about this issue said it should not be happening. They think it might be that we have an ActiveMQ configuration issue. Could be we need to set a property to prevent this. Just looking for some help. I've attached our applicationContext-mcp-parallelization-activemq XML. We could have configured this incorrectly. We're using the internalAmqConnectionFactory for this queue.",Bug
AMQ-3557,12528266,,"We are trying to upgrade our ActiveMQ installation and have run into some performance issues. I'll attached our activemq.xml file to this bug.

I've setup a fresh SQLServer database for our upgrade tests and using the example Ant tools in the distribution, I've populated a persistent queue with 1,000,000 messages. I then consume those messages using the example Ant consumption script. The producing side works fine. However the performance of the consumption side is extremely poor. To consume just 10,000 of those messages takes over 5 minutes.

The consumer will pause for 4-5 seconds every 200 messages. This is easily visible in the output of the Ant script. We have also traced the DB to see what is happening there and have found that the findNextMessagesStatement takes 4-5 seconds every time it is executed. The statement's ID parameter is increased by 200 every time it is executed.  We also noticed the use of the ""SET ROWCOUNT 10000"" statement setting the maximum number of rows returned from a query at 10000. We also traced previous versions of ActiveMQ and found that SET ROWCOUNT was used much more often, with much smaller values (often 10, 20 or 30).

We have also tested the same setup with version 5.4.0 and did not have the same issues. Consumption speeds with 5.4.0 were normal, with no pauses. Version 5.4.3 did have the problem, however. So there seems to be a regression somewhere between 5.4.0 and 5.4.3 (also affects 5.5.0 and later).

Please let me know if you need more information, including the database traces.
",Bug
AMQ-3303,12506378,,"Null pointer exception when accessing the JSPs if the first jmx server (here activemq-1) in the jmx url is the slave.
findBrokers in RemoteJMXBrokerFacade finds the slave broker but accessing some of its attributes results in a NullPointerException.",Bug
AMQ-3292,12504985,,,Bug
AMQ-3649,12537157,,"
{noformat}
2012-01-03 19:17:50,646 | DEBUG | commit: TX:ID:foo-7365-1325617993757-0:1:1 syncCount: 2 | org.apache.activemq.transaction.LocalTransaction | ActiveMQ Transport: tcp:///bar:13219
2012-01-03 19:17:50,650 | ERROR | KahaDB failed to store to Journal | org.apache.activemq.store.kahadb.MessageDatabase | ActiveMQ Transport: tcp:///bar:13219
java.io.EOFException
	at java.io.RandomAccessFile.readFully(RandomAccessFile.java:383)
	at java.io.RandomAccessFile.readFully(RandomAccessFile.java:361)
	at org.apache.kahadb.page.PageFile.readPage(PageFile.java:779)
	at org.apache.kahadb.page.Transaction$2.readPage(Transaction.java:440)
	at org.apache.kahadb.page.Transaction$2.<init>(Transaction.java:431)
	at org.apache.kahadb.page.Transaction.openInputStream(Transaction.java:428)
	at org.apache.kahadb.page.Transaction.load(Transaction.java:404)
	at org.apache.kahadb.page.Transaction.load(Transaction.java:361)
	at org.apache.kahadb.index.BTreeIndex.loadNode(BTreeIndex.java:262)
	at org.apache.kahadb.index.BTreeIndex.getRoot(BTreeIndex.java:174)
	at org.apache.kahadb.index.BTreeIndex.put(BTreeIndex.java:189)
	at org.apache.activemq.store.kahadb.MessageDatabase.upadateIndex(MessageDatabase.java:1026)
	at org.apache.activemq.store.kahadb.MessageDatabase$AddOpperation.execute(MessageDatabase.java:1777)
	at org.apache.activemq.store.kahadb.MessageDatabase$18.execute(MessageDatabase.java:976)
	at org.apache.kahadb.page.Transaction.execute(Transaction.java:728)
	at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:973)
	at org.apache.activemq.store.kahadb.MessageDatabase$13.visit(MessageDatabase.java:874)
	at org.apache.activemq.store.kahadb.data.KahaCommitCommand.visit(KahaCommitCommand.java:130)
	at org.apache.activemq.store.kahadb.MessageDatabase.process(MessageDatabase.java:856)
	at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:783)
	at org.apache.activemq.store.kahadb.KahaDBTransactionStore.commit(KahaDBTransactionStore.java:270)
	at org.apache.activemq.transaction.LocalTransaction.commit(LocalTransaction.java:72)
	at org.apache.activemq.broker.TransactionBroker.commitTransaction(TransactionBroker.java:173)
	at org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:103)
	at org.apache.activemq.broker.TransportConnection.processCommitTransactionOnePhase(TransportConnection.java:420)
	at org.apache.activemq.command.TransactionInfo.visit(TransactionInfo.java:100)
	at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:306)
	at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:179)
	at org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:69)
	at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)
	at org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:227)
	at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)
	at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:220)
	at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:202)
	at java.lang.Thread.run(Thread.java:619)
2012-01-03 19:17:50,650 | WARN  | Store COMMIT FAILED:  | org.apache.activemq.transaction.LocalTransaction | ActiveMQ Transport: tcp:///bar:13219
java.lang.NullPointerException
	at org.apache.activemq.util.DefaultIOExceptionHandler.handle(DefaultIOExceptionHandler.java:54)
	at org.apache.activemq.broker.BrokerService.handleIOException(BrokerService.java:2193)
	at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:804)
	at org.apache.activemq.store.kahadb.KahaDBTransactionStore.commit(KahaDBTransactionStore.java:270)
	at org.apache.activemq.transaction.LocalTransaction.commit(LocalTransaction.java:72)
	at org.apache.activemq.broker.TransactionBroker.commitTransaction(TransactionBroker.java:173)
	at org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:103)
	at org.apache.activemq.broker.TransportConnection.processCommitTransactionOnePhase(TransportConnection.java:420)
	at org.apache.activemq.command.TransactionInfo.visit(TransactionInfo.java:100)
	at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:306)
	at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:179)
	at org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:69)
	at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)
	at org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:227)
	at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)
	at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:220)
	at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:202)
	at java.lang.Thread.run(Thread.java:619)
2012-01-03 19:17:50,651 | DEBUG | rollback: TX:ID:foo-7365-1325617993757-0:1:1 syncCount: 2 | org.apache.activemq.transaction.LocalTransaction | ActiveMQ Transport: tcp:///bar:13219
2012-01-03 19:17:50,651 | DEBUG | Error occured while processing sync command: TransactionInfo {commandId = 229, responseRequired = true, type = 2, connectionId = ID:foo-7365-1325617993757-0:1, transactionId = TX:ID:foo-7365-1325617993757-0:1:1}, exception: javax.transaction.xa.XAException: STORE COMMIT FAILED: Transaction rolled back. | org.apache.activemq.broker.TransportConnection.Service | ActiveMQ Transport: tcp:///bar:13219
javax.transaction.xa.XAException: STORE COMMIT FAILED: Transaction rolled back.
	at org.apache.activemq.transaction.LocalTransaction.commit(LocalTransaction.java:77)
	at org.apache.activemq.broker.TransactionBroker.commitTransaction(TransactionBroker.java:173)
	at org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:103)
	at org.apache.activemq.broker.TransportConnection.processCommitTransactionOnePhase(TransportConnection.java:420)
	at org.apache.activemq.command.TransactionInfo.visit(TransactionInfo.java:100)
	at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:306)
	at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:179)
	at org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:69)
	at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)
	at org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:227)
	at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)
	at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:220)
	at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:202)
	at java.lang.Thread.run(Thread.java:619)
Caused by: java.lang.NullPointerException
	at org.apache.activemq.util.DefaultIOExceptionHandler.handle(DefaultIOExceptionHandler.java:54)
	at org.apache.activemq.broker.BrokerService.handleIOException(BrokerService.java:2193)
	at org.apache.activemq.store.kahadb.MessageDatabase.store(MessageDatabase.java:804)
	at org.apache.activemq.store.kahadb.KahaDBTransactionStore.commit(KahaDBTransactionStore.java:270)
	at org.apache.activemq.transaction.LocalTransaction.commit(LocalTransaction.java:72)
	... 13 more
{noformat}",Bug
AMQ-3567,12528814,,"The process that activemq uses to check if there has been inactivity for a connection has a flaw when it tries to close the connection because of inactivity. The current process generates the following interrupt exception. 

{code} 
2011-10-25 12:13:56,878 | DEBUG | org.apache.activemq.util.ServiceSupport - Could not stop service: tcp://localhost/127.0.0.1:61616. Reason: java.lang.InterruptedException
java.lang.InterruptedException
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquireSharedNanos(AbstractQueuedSynchronizer.java:1302)
    at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:253)
    at org.apache.activemq.transport.tcp.TcpTransport.doStop(TcpTransport.java:553)
    at org.apache.activemq.util.ServiceSupport.stop(ServiceSupport.java:70)
    at org.apache.activemq.transport.tcp.TcpTransport.stop(TcpTransport.java:570)
    at org.apache.activemq.transport.InactivityMonitor.stop(InactivityMonitor.java:132)
    at org.apache.activemq.transport.TransportFilter.stop(TransportFilter.java:65)
    at org.apache.activemq.transport.WireFormatNegotiator.stop(WireFormatNegotiator.java:91)
    at org.apache.activemq.util.ServiceSupport.dispose(ServiceSupport.java:43)
    at org.apache.activemq.transport.failover.FailoverTransport.disposeTransport(FailoverTransport.java:207)
    at org.apache.activemq.transport.failover.FailoverTransport.handleTransportFailure(FailoverTransport.java:223)
    at org.apache.activemq.transport.failover.FailoverTransport$3.onException(FailoverTransport.java:184)
    at org.apache.activemq.transport.TransportFilter.onException(TransportFilter.java:101)
    at org.apache.activemq.transport.WireFormatNegotiator.onException(WireFormatNegotiator.java:160)
    at org.apache.activemq.transport.InactivityMonitor.onException(InactivityMonitor.java:265)
    at org.apache.activemq.transport.InactivityMonitor$4.run(InactivityMonitor.java:185)
    at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
    at java.lang.Thread.run(Thread.java:680)
{code} 

This is caused because the spawned thread in the AbstractInactivityMonitor classes readCheck method calls the onException method. This method will then call the stopMonitorThreads method which subsequently calls the shutdownNow method of the ASYNC_TASKS executor. This call causes the executor to call the interrupt method for all active threads in the executor. The problem is that the calling thread is part of the ASYNC_TASKS executor and therefore it is generating the interrupt exception. 

Here is the stack trace of the call that is causing the interrupt. 

{code} 
Daemon Thread [InactivityMonitor Async Task: java.util.concurrent.ThreadPoolExecutor$Worker@66da9ea4] (Suspended (entry into method interrupt in Thread))   
    Thread.interrupt() line: 902   
    ThreadPoolExecutor$Worker.interruptNow() line: 855   
    ThreadPoolExecutor.shutdownNow() line: 1167   
    InactivityMonitor.stopMonitorThreads() line: 363   
    InactivityMonitor.onException(IOException) line: 264   
    InactivityMonitor$4.run() line: 185   
    ThreadPoolExecutor$Worker.runTask(Runnable) line: 886   
    ThreadPoolExecutor$Worker.run() line: 908   
    Thread.run() line: 680  
{code} 


The solution is to replace the shutdownNow method call with shutdown. Subsequent testing with this change does not cause the interrupt exception. 

I was able to create a testcase that reproduces this issue. The testcase uses the useInactivityMonitor=false attribute to reproduce this issue, thanks Gary for the hint. Unfortunately there aren't any steps that I can use to determine that the raised interrupted exception was raised or not. The test will pass either way. 

A patch will be added to this issue.


",Bug
AMQ-3488,12521829,,"ActiveMQTempDestinations hold onto the source connection that created them. When the source connection is closed, its temporary destinations are deleted. Unfortunately, DestinationInfo commands convey the destination object with its source connection to all other connections on the same VMTransportServer. Hence when these other connections are closed, they attempt to delete the source connection's temporary destination.

Note that enabling marshaling on the VM transport works around this bug because destination serialization and deserialization does not maintain the source connection reference.

This bug was not present in 5.4.2.",Bug
AMQ-3506,12523721,,"When configuring a PooledConnectionFactory with maximumActive=1 and blockIfSessionPoolIsFull=true (default behavior for latter config) it is possible that multiple threads that concurrently try to use the same JMS connection to create a new session might create more sessions than the configured maximumActive limit.

That's because the call to ConnectionPool.createSession() is not synchronized and if multiple threads try to call this method concurrently (on the same underlying JMS connection) then the if-condition in 
{code:java}
SessionKey key = new SessionKey(transacted, ackMode);
SessionPool pool = cache.get(key);
if (pool == null) {
  pool = createSessionPool(key);
  cache.put(key, pool);
}
{code}

will evaluate to true for *all* threads and they all end up creating their own sessionPool using the same SessionKey properties. 
Access to the if-condition needs to be synchronized so that only one session pool gets created. That will ensure that not more than the configured maximumActive number of sessions can get created. ",Bug
AMQ-3514,12525074,,"Hi, 

we are debugging a shutdown problem using the activemq-web-console deployed into jetty. 

It seems as if everything is terminated as expected, apart from a TimerThread which logs to the console about every minute. 

05 Jul 2011 09:03:19,246 DEBUG [Timer-1] org.apache.activemq.web.MessageListenerServlet.debug() -- Cleaning up expired web clients. 

Tracing down the problem indicated one possible cause. 
The web-console package declares the AjaxServlet to send messages via the web to the broker, it extends MessageListenerServlet. 

The init() mehtod of the MessageListenerServlet schedules task 

        clientCleanupTimer.schedule( new ClientCleaner(), 5000, 60000 ); 

but the timer (clientCleanupTimer) is never canceled and according to the javadoc of Timer this can prevent the JVM from shutting down cleanly. 

Patch attached",Bug
AMQ-3518,12525230,,"The MessageServlet used for the REST interface supplied in the demo web app will not correctly use the request body of an HTTP POST request if the content-type header contains more than just the MIME type.

The specification for this header indicates that there can be multiple values in this header.  ",Bug
AMQ-3837,12555021,,"When a client has connected to broker,we can see more than one rows of connections via web console on page titled connections.",Bug
AMQ-3794,12548999,,"The method 
{code:title=org.apache.activemq.transport.ws.StompSocket.java}
public void sendToStomp(StompFrame command) throws IOException {
   outbound.sendMessage(WebSocket.SENTINEL_FRAME, command.toString());
}
{code}

 calls {{toString()}} method of the {{StompFrame}} instance instead of the {{format()}} method. The message body is truncated by the {{toString()}} to 64 chars.",Bug
AMQ-3974,12603501,,"If a JNDI lookup is done for a dynamic or topic called ""a/b"" then another lookup is done for ""a"", then the second lookup returns an instance of org.apache.activemq.jndi.ReadOnlyContext instead of a Queue. Example:
# Object q1 = context.lookup(""dynamicQueues/a/b"");
  This correctly returns a Queue object
# Object q2 = context.lookup(""dynamicQueues/a"");
  This incorrectly returns a ReadOnlyContext object instead of a Queue.

To reproduce:
# drop attached file JNDILookup.java into $ACTIVEMQ_HOME/example/src
# edit build.xml in the example directory to add the following:
{quote}
    <target name=""jndi"" depends=""compile"" description=""Runs JDNI testcase"">
        <echo>Running a Log4j JMS Appender example</echo>
        <java classname=""JNDILookup"" fork=""yes"" maxmemory=""100M"">
            <classpath refid=""javac.classpath"" />
        </java>
    </target>
{quote}
# run by issuing the command ""ant jndi"". 
# Observce that the output is as follows:
{quote}
jndi:
     [echo] Running JNDI testcases
     [java] wrongObjectTypeFound: ERROR q2 is not a queue, q2=org.apache.activemq.jndi.ReadOnlyContext@7ddf5a8f
     [java] wrongDestinationFound: ERROR q2 has unexpected name a, expected a/b
{quote}
The message starting ""wrongObjectTypeFound:"" demonstrates the problem.",Bug
AMQ-3744,12544389,,"The bug affects the ActiveMQ-Fuse Version 5.5.1-fuse-02-02. The version 5.5.1-fuse-00-08 is the last testet with no problem.

when trying to connect to a failover-url with multiple failover nodes, the failover transport connects successful already at the first node, even if it is an inactive slave. 
Then, of course, no session can be started. The consumer is waiting all the time.",Bug
AMQ-3722,12542847,,"Small cosmetic error

The help message printed from activemq-admin browse

{code}
Main browse --amqurl tcp://localhost:61616 --user someUser --pass somePass FOO.BAR
        - Print the message header, custom message header, and message body of all messages in the
          queue FOO.BAR, using someUser as the user name, and somePass as the password
{code}

the ""-pass"" argument above is not recognized, it should be ""-password""


",Bug
AMQ-3669,12539109,,"We fill a queue that is backed by a qmirror with data (persistent) that exceeds the configured memory limit.
The producer (producerFlowControl=""true"" at queue and qmirror) will be throttled when the the limit is reached, no messages are spooled to disk.
As an overall result, we are not able to write a lot of messages into amq.

*Configuration:*

{code:xml} 
	<destinationInterceptors>
		<mirroredQueue copyMessage = ""true"" postfix="".qmirror"" prefix=""""/>
	</destinationInterceptors>

	<destinationPolicy>
		<policyMap>
		  <policyEntries>
			<policyEntry topic="">"" producerFlowControl=""true"" memoryLimit=""2mb"" />
			<policyEntry queue=""created.static.for.persistent"" producerFlowControl=""true"" memoryLimit=""1mb"" />
		  </policyEntries>
		</policyMap>
	</destinationPolicy> 

	<destinations>
		<queue physicalName=""created.static.for.persistent"" />
	</destinations>

	<persistenceAdapter>
		<kahaDB directory=""${activemq.base}/data/kahadb""/>
	</persistenceAdapter>
	
	<systemUsage>
		<systemUsage>
			<memoryUsage><memoryUsage limit=""10 mb"" /></memoryUsage>
			<storeUsage><storeUsage limit=""100 mb""/></storeUsage>
			<tempUsage><tempUsage limit=""100 mb""/></tempUsage>
		</systemUsage>
	</systemUsage>
	
	<transportConnectors>
		<transportConnector name=""openwire"" uri=""tcp://0.0.0.0:61616""/>
	</transportConnectors>
 {code}

*Java test code:*

{code} 
    ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(""tcp://localhost:61616"");
    Connection connection = factory.createConnection(""user"", ""pwd"");
    connection.start();
    Session session = connection.createSession(false, Session.CLIENT_ACKNOWLEDGE);
    Destination destination = session.createQueue(""created.static.for.persistent"");
    MessageProducer producer = session.createProducer(destination);
    producer.setDeliveryMode(DeliveryMode.PERSISTENT);
    char[] m = new char[1024];
    Arrays.fill(m, 'x');
    // create some messages that have 1k each
    for (int i = 0; i < 12000; i++) {
      ActiveMQTextMessage message = new ActiveMQTextMessage();
      message.setText(new String(m));
      producer.send(message);
    }
    connection.stop();
    connection.close();
  }

{code} 

*Expectation:*

Messages should be written to disk when the memory limit exceeds, all messages should be available within the queue/topic.

*Result:*

 INFO | Usage Manager memory limit (2097152) reached for topic://created.static.for.persistent.qmirror. Producers will be throttled to the rate at which messages are removed from this destination to prevent flooding it. See http://activemq.apache.org/producer-flow-control.html for more info

Store percent used  : 10 
Memory percent used : 20
Temp percent used   : 0

Interesting: The smaller flow control for the queue (1mb) does not seem to catch but the qmirror does (2mb).
",Bug
AMQ-4673,12662462,,"I have an application that uses activemq-camel and deploys/works fine with GlassFish v3.  I tried to deploy the same application on GlassFish v4 and get this error:

remote failure: Error occurred during deployment: Exception while deploying the app [appname] : The lifecycle method [afterPropertiesSet] must not throw a checked exception. Related annotation information: annotation [@javax.annotation.PostConstruct()] on annotated element [public void org.apache.activemq.camel.component.CamelEndpointLoader.afterPropertiesSet() throws java.lang.Exception] of type [METHOD]. Please see server.log for more details.
Command deploy failed.

It appears that CamelEndpointLoader has a @PostConstruct method that throws an Exception and per the Java EE spec that isn't allowed.  Apparently GlassFish v3 was lenient but v4 is not.

Looking at the code, it is easy to fix.  The afterPropertiesSet method just needs to catch the exceptions from addQueue/addTopic and log them at the end of the method like it does earlier in the method.  If a failure to add these during the method should actually be considered a failure, then something like IllegalStateException or another unchecked exception should be thrown instead.

This fix has been tested and verified to get past the problem.",Bug
AMQ-3849,12556381,,"activemq-core/src/main/proto/journal-data.proto contains several typos in the word 'transaction', spelled as 'transaciton'. These typos also propagate to the Java code and the API, as a result of protobuf compilation.

Will submit a fix in the next hours.",Bug
AMQ-3831,12554314,,"There was an issue in the init.d scripts generated by the maven appassembler plugin that is in ActiveMQ too

http://jira.codehaus.org/browse/MAPPASM-113

{quote}
When using RUN_AS_USER (set to a different user than the current one) su is called to call the script again. The return code of the called script is later ignored and 0 is always returned.

For example, status should return non zero when service is not running, but it returns zero anyway.
{quote}

",Bug
AMQ-4084,12609462,,"When building the broker on a Windows machine, the Linux/Unix specific files are not converted to the correct EOL character.  Specifically, the activemq and activemq-admin script files.  If these files are not converted when the package is built on a Windows machine, then the broker fails to run when deployed on a Linux/Unix machine.",Bug
AMQ-5086,12699227,,"Experience this bug on 5.7.0, I think this is the same on the trunk

using vm transport for a client to connect to an embedded broker, in a multithreaded application, I'm experiencing a an error (sometimes) which appears to be a race condition at startup.

Im using create=false and waitForStart to create a connectionFactory for a client connection
vm://ApplicationName?create=false&waitForStart=120000

The broker service is started in a seperate thread

the client connection is started first. but surprisingly it tries start the brokers transport connector. An apparent glitch follows when the broker service stops and re-start the transport.

{noformat}
2014-03-05 11:07:57,626 [ClientConnection_thread] INFO  org.apache.activemq.broker.TransportConnector - Connector vm://ApplicationName Started
[...]
2014-03-05 11:08:07,009 [Main_thread] INFO  org.apache.activemq.broker.TransportConnector - Connector vm://ApplicationName Stopped
2014-03-05 11:08:07,011 [Main_thread] INFO  org.apache.activemq.broker.TransportConnector - Connector vm://ApplicationName Started
{noformat}

I look into the activemq source and saw this:

BrokerService.class
{code}
public void start() throws Exception {
[...]
    // in jvm master slave, lets not publish over existing broker till we get the lock
    final BrokerRegistry brokerRegistry = BrokerRegistry.getInstance();
    if (brokerRegistry.lookup(getBrokerName()) == null) {
            brokerRegistry.bind(getBrokerName(), BrokerService.this);
    }
    startPersistenceAdapter(startAsync);
    startBroker(startAsync);
    brokerRegistry.bind(getBrokerName(), BrokerService.this);
{code}

VMTransportFactory.class
{code}
    private BrokerService lookupBroker(final BrokerRegistry registry, final String brokerName, int waitForStart) {
        BrokerService broker = null;
        synchronized(registry.getRegistryMutext()) {
            broker = registry.lookup(brokerName);
            if (broker == null && waitForStart > 0) {
                final long expiry = System.currentTimeMillis() + waitForStart;
                while (broker == null  && expiry > System.currentTimeMillis()) {
                    long timeout = Math.max(0, expiry - System.currentTimeMillis());
                    try {
                        LOG.debug(""waiting for broker named: "" + brokerName + "" to start"");
                        registry.getRegistryMutext().wait(timeout);
                    } catch (InterruptedException ignored) {
                    }
                    broker = registry.lookup(brokerName);
                }
            }
        }
        return broker;
    }
{code}

It appears that create=false and waitForStart only waits for the broker to be added to the BrokerRegistry. However when the brokerService is starts, it seems that the broker is added to the registry before it is started.

I believe some synchronization is missing make the VMTransportFactory wait for the broker not only to be added to the registry, but also fully started.










",Bug
AMQ-4142,12613936,,The SimpleAuthenticationPluginTest sometimes hangs on Hudson,Bug
AMQ-4133,12613301,,"Hello,

we noticed an inconsistent behaviour of stomp+ssl and stomp+nio+ssl with same connector options.

- stomp+ssl works with both {{transport.needClientAuth=true}} and {{needClientAuth=true}} options
- stomp+nio+ssl works with {{transport.needClientAuth=true}} but not with {{needClientAuth=true}}
In this last case it fails with a non-obvious exception:
{noformat}
junit.framework.ComparisonFailure: java.lang.SecurityException: Unable to authenticate transport without SSL certificate.
        at org.apache.activemq.security.JaasCertificateAuthenticationBroker.addConnection(JaasCertificateAuthenticationBroker.java:74)
        at org.apache.activemq.security.JaasDualAuthenticationBroker.addConnection(JaasDualAuthenticationBroker.java:98)
{noformat}

It would be nice to have a URI parameters validation or the same behaviour with similar connectors.

What do you think?

Unit test which shows the problem attached, sorry for reusing pieces from another bug.",Bug
AMQ-5140,12707722,,"Using hawtio, navigate to activeMQ, select Health in Tree, then Operations.

Both operations Health() and Health list() lead to the exception, although in the attributes section everything is fine!?

Status: Good 

{noformat}
java.lang.ArithmeticException: / by zero
	at org.apache.activemq.broker.jmx.HealthView.healthList(HealthView.java:158)
	at org.apache.activemq.broker.jmx.HealthView.health(HealthView.java:51)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at sun.reflect.misc.Trampoline.invoke(Unknown Source)
	at sun.reflect.GeneratedMethodAccessor17.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at sun.reflect.misc.MethodUtil.invoke(Unknown Source)
	at com.sun.jmx.mbeanserver.StandardMBeanIntrospector.invokeM2(Unknown Source)
	at com.sun.jmx.mbeanserver.StandardMBeanIntrospector.invokeM2(Unknown Source)
	at com.sun.jmx.mbeanserver.MBeanIntrospector.invokeM(Unknown Source)
	at com.sun.jmx.mbeanserver.PerInterface.invoke(Unknown Source)
	at com.sun.jmx.mbeanserver.MBeanSupport.invoke(Unknown Source)
	at javax.management.StandardMBean.invoke(Unknown Source)
	at org.apache.activemq.broker.jmx.AnnotatedMBean.invoke(AnnotatedMBean.java:198)
	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(Unknown Source)
	at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(Unknown Source)
	at org.jolokia.handler.ExecHandler.doHandleRequest(ExecHandler.java:98)
	at org.jolokia.handler.ExecHandler.doHandleRequest(ExecHandler.java:40)
	at org.jolokia.handler.JsonRequestHandler.handleRequest(JsonRequestHandler.java:89)
	at org.jolokia.backend.MBeanServerExecutorLocal.handleRequest(MBeanServerExecutorLocal.java:109)
	at org.jolokia.backend.MBeanServerHandler.dispatchRequest(MBeanServerHandler.java:102)
	at org.jolokia.backend.LocalRequestDispatcher.dispatchRequest(LocalRequestDispatcher.java:98)
	at org.jolokia.backend.BackendManager.callRequestDispatcher(BackendManager.java:409)
	at org.jolokia.backend.BackendManager.handleRequest(BackendManager.java:158)
	at org.jolokia.http.HttpRequestHandler.executeRequest(HttpRequestHandler.java:197)
	at org.jolokia.http.HttpRequestHandler.handlePostRequest(HttpRequestHandler.java:137)
	at org.jolokia.http.AgentServlet$2.handleRequest(AgentServlet.java:399)
	at org.jolokia.http.AgentServlet.handle(AgentServlet.java:287)
	at org.jolokia.http.AgentServlet.doPost(AgentServlet.java:256)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:713)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:806)
	at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:652)
	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1329)
	at io.hawt.web.AuthenticationFilter$2.run(AuthenticationFilter.java:143)
	at java.security.AccessController.doPrivileged(Native Method)
	at javax.security.auth.Subject.doAs(Unknown Source)
	at io.hawt.web.AuthenticationFilter.executeAs(AuthenticationFilter.java:140)
	at io.hawt.web.AuthenticationFilter.doFilter(AuthenticationFilter.java:108)
	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1300)
	at io.hawt.web.CORSFilter.doFilter(CORSFilter.java:42)
	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1300)
	at org.ops4j.pax.web.service.internal.WelcomeFilesFilter.doFilter(WelcomeFilesFilter.java:193)
	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1300)
	at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:445)
	at org.ops4j.pax.web.service.jetty.internal.HttpServiceServletHandler.doHandle(HttpServiceServletHandler.java:70)
	at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:137)
	at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:534)
	at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:227)
	at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1038)
	at org.ops4j.pax.web.service.jetty.internal.HttpServiceContext.doHandle(HttpServiceContext.java:117)
	at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:374)
	at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:189)
	at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:972)
	at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:135)
	at org.ops4j.pax.web.service.jetty.internal.JettyServerHandlerCollection.handle(JettyServerHandlerCollection.java:75)
	at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:116)
	at org.eclipse.jetty.server.Server.handle(Server.java:363)
	at org.eclipse.jetty.server.AbstractHttpConnection.handleRequest(AbstractHttpConnection.java:483)
	at org.eclipse.jetty.server.AbstractHttpConnection.content(AbstractHttpConnection.java:931)
	at org.eclipse.jetty.server.AbstractHttpConnection$RequestHandler.content(AbstractHttpConnection.java:992)
	at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:856)
	at org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:240)
	at org.eclipse.jetty.server.AsyncHttpConnection.handle(AsyncHttpConnection.java:82)
	at org.eclipse.jetty.io.nio.SelectChannelEndPoint.handle(SelectChannelEndPoint.java:627)
	at org.eclipse.jetty.io.nio.SelectChannelEndPoint$1.run(SelectChannelEndPoint.java:51)
	at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:608)
	at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:543)
	at java.lang.Thread.run(Unknown Source)
{noformat}",Bug
AMQ-4893,12679489,,If we try to copy headers between messages using getProperties and setObjectProperty with those values it now fails since the UTF8Buffer is not in the whitelist of convertable types. I think it should be added as a whitelisted type that gets handled like a string on setObjectProperty (and probably setStringProperty). Otherwise this causes the application code to have to special case String properties and couple to the hawtbuffer implementation detail.,Bug
AMQ-4696,12665911,,"I can add a more detail description if needed but for now to reproduce this you'll need to comment out testUnsubscribe in the JoramJmsTest TopicSessionTest, build a snapshot, uncomment TopicSessionTest in JoramJmsTest and run that.  The testDurableSubscriber will fail.

I have a patch for this, I can post it now or after the patch for AMQ-4596 is posted",Bug
AMQ-4601,12654790,,"Attached a test case that does the following: 

1. Registers 4 consumers. 

2. Sends a message. 

3. When the first message is received, it does the following:
3.1. Unregister the listeners for the consumers. 
3.2. Close the consumers. 
3.3. Rollback the transaction. 

4. Consume the message from a new consumer

After running the test called TestActiveMqRedeliveryIssue you will see in the logs (among others things): 

delivery count 1 
delivery count 5 

The first one corresponds to the first message and the second one to the message that is consumed from the queue after the stop() procedure was called. 

As you can see, the count increased by 4, which is the number of consumers. 

The expected behaviour would be to have the redelivery counter set to 1 when the message is consumed the second time",Bug
AMQ-4588,12653550,,"In order to have the AMQ client run on OpenShift the IdGenerator call 'new ServerSocket(0);' needs to be configurable to be avoided. OpenShift only allows binding to a specific, provided, unique loopback address and a limited set of ports. Ideally there would be a configuration option that allows the stub prefix to be set via a JVM param. The current logic doesn't break OpenShift as the PermissionDenied exception is caught and swallowed but the stack trace is ugly.",Bug
AMQ-4589,12653686,,"Running activemq-web under a container that supports Servlet 3, there is a race condition when resuming continuations that leads to lost messages because the same continuation is resumed multiple times and the second time around the undelivered_message attribute is overwritten. 

Here's an example debug log of the issue under Jetty:

{noformat}
2013-06-19 10:46:51,340 DEBUG o.a.a.web.MessageListenerServlet   - doMessage timeout=25000
2013-06-19 10:46:51,350 DEBUG o.a.a.web.MessageListenerServlet   - received null from ActiveMQMessageConsumer { value=ID:deapp0313-52345-1371228095770-3:126:1:1, started=true }
2013-06-19 10:46:51,350 DEBUG o.a.a.web.MessageListenerServlet   - Suspending continuation org.eclipse.jetty.continuation.Servlet3Continuation@73d4a75a
2013-06-19 10:46:53,053 DEBUG org.apache.activemq.web.AjaxListener   - message is ActiveMQTextMessage {commandId = 4419, responseRequired = true, messageId = ID:deapp0313-52345-1371228095770-1:1:1:1:4415, originalDestination = null, originalTransactionId = null, producerId = ID:deapp0313-52345-1371228095770-1:1:1:1, destination = topic://W2ETopic, transactionId = null, expiration = 0, timestamp = 1371631612606, arrival = 0, brokerInTime = 1371631612628, brokerOutTime = 1371631612629, correlationId = null, replyTo = null, persistent = true, type = null, priority = 4, groupID = null, groupSequence = 0, targetConsumerId = null, compressed = false, userID = null, content = null, marshalledProperties = org.apache.activemq.util.ByteSequence@1e5bc429, dataStructure = null, redeliveryCounter = 0, size = 0, properties = {instance=1796}, readOnlyProperties = true, readOnlyBody = true, droppable = false, text = {""instance"":{""instanceId"":1796,""changeNo"":217...nput"":true}}}
2013-06-19 10:46:53,062 DEBUG org.apache.activemq.web.AjaxListener   - Resuming suspended continuation org.eclipse.jetty.continuation.Servlet3Continuation@73d4a75a
2013-06-19 10:46:53,063 DEBUG org.apache.activemq.web.AjaxListener   - message for ActiveMQMessageConsumer { value=ID:deapp0313-52345-1371228095770-3:126:1:1, started=true } continuation=org.eclipse.jetty.continuation.Servlet3Continuation@73d4a75a
2013-06-19 10:46:53,064 DEBUG org.apache.activemq.web.AjaxListener   - message is ActiveMQTextMessage {commandId = 4420, responseRequired = true, messageId = ID:deapp0313-52345-1371228095770-1:1:1:1:4416, originalDestination = null, originalTransactionId = null, producerId = ID:deapp0313-52345-1371228095770-1:1:1:1, destination = topic://W2ETopic, transactionId = null, expiration = 0, timestamp = 1371631612644, arrival = 0, brokerInTime = 1371631612644, brokerOutTime = 1371631613022, correlationId = null, replyTo = null, persistent = true, type = null, priority = 4, groupID = null, groupSequence = 0, targetConsumerId = null, compressed = false, userID = null, content = null, marshalledProperties = org.apache.activemq.util.ByteSequence@1aab6f51, dataStructure = null, redeliveryCounter = 0, size = 0, properties = {instance=1796}, readOnlyProperties = true, readOnlyBody = true, droppable = false, text = {""instance"":{""instanceId"":1796,""changeNo"":217...nput"":true}}}
2013-06-19 10:46:53,064 DEBUG org.apache.activemq.web.AjaxListener   - Resuming suspended continuation org.eclipse.jetty.continuation.Servlet3Continuation@73d4a75a
2013-06-19 10:46:53,065 DEBUG o.a.a.web.MessageListenerServlet   - GET client=org.apache.activemq.web.AjaxWebClient@7c00281 session=c5qseeifcc9l1n49e7ivdx3at clientId=w2e-gui-0.18586184200830758 uri=/amq query=timeout=120000&d=1371631611528&r=0.4084213834721595&clientId=w2e-gui-0.18586184200830758
2013-06-19 10:46:53,065 DEBUG o.a.a.web.MessageListenerServlet   - doMessage timeout=25000
2013-06-19 10:46:53,065 DEBUG o.a.a.web.MessageListenerServlet   - sending pre-existing message
2013-06-19 10:46:53,066 DEBUG o.a.a.web.MessageListenerServlet   - Send 0 unconsumed messages
2013-06-19 10:46:53,065 ERROR org.apache.activemq.web.AjaxListener   - Error receiving message java.lang.IllegalStateException: REDISPATCHED,resumed
java.lang.IllegalStateException: REDISPATCHED,resumed
	at org.eclipse.jetty.server.HttpChannelState.dispatch(HttpChannelState.java:335) ~[jetty-server-9.0.3.v20130506.jar:9.0.3.v20130506]
	at org.eclipse.jetty.server.AsyncContextState.dispatch(AsyncContextState.java:109) ~[jetty-server-9.0.3.v20130506.jar:9.0.3.v20130506]
	at org.eclipse.jetty.continuation.Servlet3Continuation.resume(Servlet3Continuation.java:186) ~[jetty-continuation-9.0.3.v20130506.jar:9.0.3.v20130506]
	at org.apache.activemq.web.AjaxListener.onMessageAvailable(AjaxListener.java:74) ~[activemq-web-5.8.0.jar:5.8.0]
	at org.apache.activemq.ActiveMQMessageConsumer.dispatch(ActiveMQMessageConsumer.java:1343) [activemq-client-5.8.0.jar:5.8.0]
	at org.apache.activemq.ActiveMQSessionExecutor.dispatch(ActiveMQSessionExecutor.java:131) [activemq-client-5.8.0.jar:5.8.0]
	at org.apache.activemq.ActiveMQSessionExecutor.iterate(ActiveMQSessionExecutor.java:202) [activemq-client-5.8.0.jar:5.8.0]
	at org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:129) [activemq-client-5.8.0.jar:5.8.0]
	at org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:47) [activemq-client-5.8.0.jar:5.8.0]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110) [na:1.7.0_07]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603) [na:1.7.0_07]
	at java.lang.Thread.run(Thread.java:722) [na:1.7.0_07]
2013-06-19 10:46:53,068 DEBUG o.a.a.web.MessageListenerServlet   - Continuation org.eclipse.jetty.continuation.Servlet3Continuation@73d4a75a completed.
{noformat}

The root of the race is that the code uses isSuspended() to check whether a continuation has been resumed, but resume() only resets isSuspended() after the resume request has been processed in the servlet engine. The race-free way to check whether is has been resumed is to check isResumed(), see attached patch. ",Bug
AMQ-4484,12644386,,"At least for duplex NetworkConnectors a consumer for queue:// is added on the remote broker, if there are no statically included destinations.

This is caused by the string ""[]"" incorrectly converted to a list with one element, instead of an empty list.

The attached patch fixes the problem.",Bug
AMQ-4266,12628741,,We missed proton-api as dependency.,Bug
AMQ-5745,12824150,,"Code analysis revealed multiple vulnerable sections of code in ActiveMQ 5.9.0.  A patch file is attached that address the issues below.

activemq-web/src/main/resources/org/apache/activemq/web/prototype.js:700,706

	This code uses the  ""eval()"" function to evaluate JSON code -- this method is deprecated and dangerous and has been replaced by the JSON.parse() method, which is supported in all modern browsers -- considering that less than 2% of modern computers are still using legacy browsers, we believe the code should be upgraded to use the more secure method

activemq-broker/src/main/java/org/apache/activemq/broker/BrokerService.java:248
activemq-broker/src/main/java/org/apache/activemq/broker/PropertiesBrokerFactory.java:59
activemq-broker/src/main/java/org/apache/activemq/util/IOHelper.java:257,259
activemq-client/src/main/java/org/apache/activemq/ActiveMQSslConnectionFactory.java:130,162
activemq-client/src/main/java/org/apache/activemq/blob/DefaultBlobUploadStrategy.java:43,58
activemq-client/src/main/java/org/apache/activemq/blob/FTPBlobUploadStrategy.java:41
activemq-client/src/main/java/org/apache/activemq/blob/FileSystemBlobStrategy.java:68,77
activemq-console/src/main/java/org/apache/activemq/console/command/CreateCommand.java:194,218,219
activemq-fileserver/src/main/java/org/apache/activemq/util/IOHelper.java:102,104
activemq-jaas/src/main/java/org/apache/activemq/jaas/TextFileCertificateLoginModule.java:92,127
activemq-jdbc-store/src/main/java/org/apache/activemq/store/jdbc/adapter/BlobJDBCAdapter.java:142
activemq-jdbc-store/src/main/java/org/apache/activemq/store/jdbc/adapter/StreamJDBCAdapter.java:51
activemq-kahadb-store/src/main/java/org/apache/activemq/store/kahadb/disk/page/PageFile.java:198
activemq-kahadb-store/src/main/java/org/apache/activemq/store/kahadb/disk/util/DiskBenchmark.java:214,246,270
activemq-stomp/src/main/java/org/apache/activemq/transport/stomp/ProtocolConverter.java:68
activemq-tooling/activemq-perf-maven-plugin/src/main/java/org/apache/activemq/tool/AbstractJmsClientSystem.java:266
activemq-web/src/main/java/org/apache/activemq/web/AjaxServlet.java:67
activemq-tooling/activemq-perf-maven-plugin/src/main/java/org/apache/activemq/tool/JmsProducerClient.java:356
activemq-tooling/activemq-perf-maven-plugin/src/main/java/org/apache/activemq/tool/reports/XmlFilePerfReportWriter.java:198

	Resource leaks are possible at these code locations (the patched code releases the resources within a finally() statement)

activemq-broker/src/main/java/org/apache/activemq/broker/jmx/DestinationView.java:330
activemq-client/src/main/java/org/apache/activemq/ActiveMQConnectionFactory.java:283,290
activemq-kahadb-store/src/main/java/org/apache/activemq/store/kahadb/disk/journal/CallerBufferingDataFileAppender.java:182
activemq-kahadb-store/src/main/java/org/apache/activemq/store/kahadb/disk/journal/DataFileAppender.java:391
activemq-kahadb-store/src/main/java/org/apache/activemq/store/kahadb/disk/journal/Journal.java:568

	NULL dereferences are possible at these code locations

activemq-broker/src/main/java/org/apache/activemq/transport/vm/VMTransport.java:269

	Double-locking of this form is vulnerable to race conditions

activemq-http/src/main/java/org/apache/activemq/transport/http/HttpTunnelServlet.java:196,236
activemq-web/src/main/java/org/apache/activemq/web/MessageServlet.java:278,284

	XSS reflection is possible at these code locations (an XSS filter should be added)

activemq-fileserver/src/main/java/org/apache/activemq/util/RestFilter.java:72

	Path manipulation is possible via "".."" directory traversal

activemq-client/src/main/java/org/apache/activemq/thread/PooledTaskRunner.java:141

	A return statement inside a finally block will cause any exception that might be thrown in the try or catch block to be discarded.

activemq-log4j-appender/src/main/java/org/apache/activemq/util/JmsLogAppender.java:68

	Recording passwords to a logfile in plaintext is inadvisable",Bug
AMQ-5384,12746084,,"AMQ 5.9 gets stuck under 30-50 req/second load when using JDBC persistence - this affects our application as it hangs during performance testing (this happens almost every night).
Following stacktraces indicate that there's a deadlock on DB connection:

Stack logged by C3P0, showing when first DB connection has been picked from the pool:
{noformat}
2014-10-06 08:44:40,646 | INFO  | Logging the stack trace by which the overdue resource was checked-out. | com.mchange.v2.resourcepool.BasicResourcePool | C3P0PooledConnectionPoolManager[identityToken->2x1e6s941raztn6mju110
java.lang.Exception: DEBUG STACK TRACE: Overdue resource check-out stack trace.
        at com.mchange.v2.resourcepool.BasicResourcePool.checkoutResource(BasicResourcePool.java:555)
        at com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool.checkoutAndMarkConnectionInUse(C3P0PooledConnectionPool.java:756)
        at com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool.checkoutPooledConnection(C3P0PooledConnectionPool.java:683)
        at com.mchange.v2.c3p0.impl.AbstractPoolBackedDataSource.getConnection(AbstractPoolBackedDataSource.java:140)
        at org.apache.activemq.store.jdbc.TransactionContext.getConnection(TransactionContext.java:58)
        at org.apache.activemq.store.jdbc.TransactionContext.begin(TransactionContext.java:163)
        at org.apache.activemq.store.jdbc.JDBCPersistenceAdapter.beginTransaction(JDBCPersistenceAdapter.java:510)
        at org.apache.activemq.store.memory.MemoryTransactionStore$Tx.commit(MemoryTransactionStore.java:92)
        at org.apache.activemq.store.memory.MemoryTransactionStore.commit(MemoryTransactionStore.java:259)
        at org.apache.activemq.transaction.XATransaction.storeCommit(XATransaction.java:85)
        at org.apache.activemq.transaction.XATransaction.commit(XATransaction.java:75)
        at org.apache.activemq.broker.TransactionBroker.commitTransaction(TransactionBroker.java:253)
        at org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:112)
        at org.apache.activemq.broker.TransportConnection.processCommitTransactionTwoPhase(TransportConnection.java:433)
        at org.apache.activemq.command.TransactionInfo.visit(TransactionInfo.java:102)
        at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:292)
        at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:149)
        at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)
        at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)
        at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:270)
        at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)
        at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)
        at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)
        at java.lang.Thread.run(Thread.java:662)
{noformat}

Following stack shows the same thread pending for second DB connection (without releasing the first one):
{noformat}
""ActiveMQ Transport: tcp:///10.132.7.20:36431@5445"" daemon prio=10 tid=0x000000004119d000 nid=0x61bf in Object.wait() [0x00007f41120d7000]
   java.lang.Thread.State: WAITING (on object monitor)
	at java.lang.Object.wait(Native Method)
	- waiting on <0x00000000fabdd2c0> (a com.mchange.v2.resourcepool.BasicResourcePool)
	at com.mchange.v2.resourcepool.BasicResourcePool.awaitAvailable(BasicResourcePool.java:1414)
	at com.mchange.v2.resourcepool.BasicResourcePool.prelimCheckoutResource(BasicResourcePool.java:606)
	- locked <0x00000000fabdd2c0> (a com.mchange.v2.resourcepool.BasicResourcePool)
	at com.mchange.v2.resourcepool.BasicResourcePool.checkoutResource(BasicResourcePool.java:526)
	at com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool.checkoutAndMarkConnectionInUse(C3P0PooledConnectionPool.java:756)
	at com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool.checkoutPooledConnection(C3P0PooledConnectionPool.java:683)
	at com.mchange.v2.c3p0.impl.AbstractPoolBackedDataSource.getConnection(AbstractPoolBackedDataSource.java:140)
	at org.apache.activemq.store.jdbc.TransactionContext.getConnection(TransactionContext.java:58)
	at org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.getStoreSequenceId(DefaultJDBCAdapter.java:290)
	at org.apache.activemq.store.jdbc.JDBCPersistenceAdapter.getStoreSequenceIdForMessageId(JDBCPersistenceAdapter.java:840)
	at org.apache.activemq.store.jdbc.JDBCMessageStore.removeMessage(JDBCMessageStore.java:194)
	at org.apache.activemq.store.memory.MemoryTransactionStore$4.run(MemoryTransactionStore.java:348)
	at org.apache.activemq.store.memory.MemoryTransactionStore$Tx.commit(MemoryTransactionStore.java:103)
	at org.apache.activemq.store.memory.MemoryTransactionStore.commit(MemoryTransactionStore.java:259)
	at org.apache.activemq.transaction.XATransaction.storeCommit(XATransaction.java:85)
	at org.apache.activemq.transaction.XATransaction.commit(XATransaction.java:69)
	at org.apache.activemq.broker.TransactionBroker.commitTransaction(TransactionBroker.java:253)
	at org.apache.activemq.broker.MutableBrokerFilter.commitTransaction(MutableBrokerFilter.java:112)
	at org.apache.activemq.broker.TransportConnection.processCommitTransactionOnePhase(TransportConnection.java:424)
	at org.apache.activemq.command.TransactionInfo.visit(TransactionInfo.java:100)
	at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:292)
	at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:149)
	at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:50)
	at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:113)
	at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:270)
	at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)
	at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:214)
	at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:196)
	at java.lang.Thread.run(Thread.java:662) 
{noformat}

Problem seems to be related with JDBCMessageStore.removeMessage method:
{code:java}
    public void removeMessage(ConnectionContext context, MessageAck ack) throws IOException {
    	long seq = persistenceAdapter.getStoreSequenceIdForMessageId(ack.getLastMessageId(), destination)[0];
...
{code}

Call to {{removeMessage}} already has one DB connection passed in {{context}} method parameter, but calling {{persistenceAdapter.getStoreSequenceIdForMessageId}} creates another DB connection in the same transaction.

Deadlock occurs when all DB connections are used by {{context}}, so that  {{removeMessage}} can't fetch its own connection.

Possible solution would be to pass {{ConnectionContext}} object to {{persistenceAdapter.getStoreSequenceIdForMessageId}} method, so that the method would reuse same connection.",Bug
AMQ-4971,12689176,,"DemandForwardingBridge sends messages to the other broker and asynchronously waits for ACKs keeping message bodies in heap. Amount of un-ACK-ed messages kept in heap is not limited. If local producer is fast then whole heap will be consumed by messages waiting to be ACK-ed by other broker.
Possible option to fix the issue:
Don't wait for ACK from other broker when forwarding the message if some threshold of un-ACK-ed messages is reached.
",Bug
AMQ-5198,12716030,,"We currently have an object that acts both as a consumer and as a producer over the same queue.

Lazy initialization of the scheduler is not 100% thread safe when a consumer and a producer are created sharing the same connection.


We encountered the following sporadic NPE when a rollback() is invoked:
Caused by: java.lang.NullPointerException
        at org.apache.activemq.thread.Scheduler.executeAfterDelay(Scheduler.java:64)
        at org.apache.activemq.ActiveMQMessageConsumer.rollback(ActiveMQMessageConsumer.java:1278)
        at org.apache.activemq.ActiveMQMessageConsumer$5.afterRollback(ActiveMQMessageConsumer.java:1054)
        at org.apache.activemq.TransactionContext.afterRollback(TransactionContext.java:157)
        ... 11 more



We believe that the lazy initialized getScheduler() is open for a race condition when a publish and rollback are happening concurrently.

try {
                        result = scheduler = new Scheduler(""ActiveMQConnection[""+info.getConnectionId().getValue()+""] Scheduler"");
                        scheduler.start();
                    } catch(Exception e) {
                        throw JMSExceptionSupport.create(e);
                    }

The suggested fix is to simply invoke the start within the constructor of the Scheduler class.",Bug
AMQ-5059,12695563,,The method MQTTProtocolConverter.onUnSubscribe(UNSUBSRIBE command) does not call checkConnected() to check whether CONNECT has already been received or not. ,Bug
AMQ-5058,12695557,,"The CONNECT.decode() method from mqtt-client had an issue which has been fixed in https://github.com/fusesource/mqtt-client/pull/31
Wit this fix MQTTProtocolConverter.onConnect() can now check for the condition outlined below and return a CONNACK with return code 0x02. 

From MQTT 3.1.1 draft specification

[MQTT-3.1.3-6] A Server MAY allow a Client to supply a ClientId that has a length of zero bytes.
However if it does so the Server MUST treat this as a special case and assign a
unique ClientId to that Client. It MUST then process the CONNECT packet as if
the Client had provided that unique ClientId.
[MQTT-3.1.3-7] If the Client supplies a zero-byte ClientId, the Client MUST also set Clean
Session to 1.
[MQTT-3.1.3-8] If the Client supplies a zero-byte ClientId with Clean Session set to 0, the Server
MUST respond to the CONNECT Packet with a CONNACK return code 0x02
(Identifier rejected) and then close the Network Connection.
[MQTT-3.1.3-9] If the Server rejects the ClientId it MUST respond to the CONNECT Packet with
a CONNACK return code 0x02 (Identifier rejected) and then close the Network
Connection.",Bug
AMQ-5066,12696018,,"When a client sends a SUBSCRIBE message with the same Topic/Filter as a previous SUBSCRIBE message but a different QoS, the Server MUST discard the older subscription, and resend all retained messages limited to the new Subscription QoS. ",Bug
AMQ-5065,12696016,,Retained messages must have a QoS of either the one set by the original publisher of the message or the maximum of the QoS of the subscription QoS granted to a receiver. ,Bug
AMQ-5153,12709191,,LevelDB store does not save the subscribedDestination of the SubscriptionInfo for a durable subscription.  This is important because when a restart happens you have no clue if this durable subscription goes with the topic or to a different topic (because of wildcarding).,Bug
AMQ-5166,12711710,,"The ""failoverProducersAuditDepth"" and ""maxFailoverProducersToTrack"" settings for MessageDatabase are actually used by the underlying MetaData's ActiveMQMessageAuditNoSync instance.  However, the MetaData instance and ActiveMQMessageAuditNoSync may change over the life of the MessageDatabase, and these settings are not perpetuated to the new instances (or restored instances).",Bug
AMQ-5467,12758709,,"When consuming messages in a transaction, the AMQP consumer accepts messages and specifies the transaction they are part of. AMQPProtocolConverter keeps a record of messages accepted in this way. When the transaction is committed, AMQPProtocolConverter assumes that the first and last messages in this 'dispatched in Tx' list form a range, and creates a ranged 'standard ack' MessageAck to cover the messages. The broker then checks that the acks it is processing match messages it has previously dispatched, in PrefetchSubscription#assertAckMatchesDispatched(MessageAck).

If the messages aren't added to the AMQP transaction in sequence, e.g. the assumed 'last id' is actually for a message dispatched before the assumed 'first id' in the sequence, the check fails even though all the messages being acked are in the dispatched list. There is also an implicit assumption in the processing that the ack range is an unbroken sequence, and as a result it would seem possible for messages to be acked that were not actually considered part of the AMQP transaction. This non-sequential ordering can for example happen because a client isn't releasing unconsumed prefetched messages after a rollback of consumed messages, or alternatively is processing higher priority messages before lower priority messages originally dispatched to it earlier. 

To combat these issues, the AMQP transaction commit processing should be updated to use 'individual acks'.",Bug
AMQ-5422,12752894,,"When you attempt to run ActiveMQ on Windows with the activemq.bat file from a directory with spaces (ex: ""C:\Program Files""), you get JVM related error about main class not found.  The problem is that one of the -D values in the ACTIVEMQ_OPTS line needs to have double quotes around it.  Will attach a patch to fix the problem.",Bug
AMQ-5713,12819288,,"While configuring the bridges, if we try to set the doHandleReplyTo parameter in the activemq.xml then a BeanCreationException is thrown.
Below is the sample:

<inboundQueueBridges>
	<inboundQueueBridge
		inboundQueueName = ""inBoundQ""
		localQueueName   = ""localTestQ""
		doHandleReplyTo=""false""/>
</inboundQueueBridges>

Attached is the log file.

The reason could be, the setter/getters are protected in DestinationBridge.java
",Bug
AMQ-6393,12996733,,"The issue is still persist and below is the  scenario.
I am using activemq 5.10 version.For publishing message am using VirtualTopic and also have <virtualTopic selectorAware=""true""/> in broker xml.
I have a consumer queue which consume message from this virtual topic.All the things work fine when the my consumer is up but once the consumer goes down or not active I am loosing the message.After configuring <virtualSelectorCacheBrokerPlugin/> in broker.xml I am getting below error on activemq log console. I have attached my activemq broker config file.
jvm 1 | ERROR | Unable to read persisted selector cache...it will be ignored!
jvm 1 | java.io.EOFException
jvm 1 | at java.io.ObjectInputStream$PeekInputStream.readFully(Unknown Source)[:1.8.0_101]
jvm 1 | at java.io.ObjectInputStream$BlockDataInputStream.readShort(Unknown Source)[:1.8.0_101]
jvm 1 | at java.io.ObjectInputStream.readStreamHeader(Unknown Source)[:1.8.0_101]
jvm 1 | at java.io.ObjectInputStream.<init>(Unknown Source)[:1.8.0_101]
jvm 1 | at org.apache.activemq.plugin.SubQueueSelectorCacheBroker.readCache(SubQueueSelectorCacheBroker.java:115)[activemq-broker-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.plugin.SubQueueSelectorCacheBroker.<init>(SubQueueSelectorCacheBroker.java:74)[activemq-broker-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.plugin.SubQueueSelectorCacheBrokerPlugin.installPlugin(SubQueueSelectorCacheBrokerPlugin.java:42)[activemq-broker-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.broker.BrokerService.addInterceptors(BrokerService.java:2295)[activemq-broker-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.broker.BrokerService.createBroker(BrokerService.java:2156)[activemq-broker-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.broker.BrokerService.getBroker(BrokerService.java:937)[activemq-broker-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.broker.BrokerService.getAdminConnectionContext(BrokerService.java:2426)[activemq-broker-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.broker.BrokerService.startVirtualConsumerDestinations(BrokerService.java:2566)[activemq-broker-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.broker.BrokerService.startDestinations(BrokerService.java:2417)[activemq-broker-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.broker.BrokerService.doStartBroker(BrokerService.java:667)[activemq-broker-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.broker.BrokerService.startBroker(BrokerService.java:659)[activemq-broker-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.broker.BrokerService.start(BrokerService.java:595)[activemq-broker-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.xbean.XBeanBrokerService.afterPropertiesSet(XBeanBrokerService.java:73)[activemq-spring-5.10.0.jar:5.10.0]
jvm 1 | at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)[:1.8.0_101]
jvm 1 | at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)[:1.8.0_101]
jvm 1 | at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)[:1.8.0_101]
jvm 1 | at java.lang.reflect.Method.invoke(Unknown Source)[:1.8.0_101]
jvm 1 | at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1638)[spring-beans-3.2.8.RELEASE.jar:3.2.8.RELEASE]
jvm 1 | at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1579)[spring-beans-3.2.8.RELEASE.jar:3.2.8.RELEASE]
jvm 1 | at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1509)[spring-beans-3.2.8.RELEASE.jar:3.2.8.RELEASE]
jvm 1 | at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:521)[spring-beans-3.2.8.RELEASE.jar:3.2.8.RELEASE]
jvm 1 | at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:458)[spring-beans-3.2.8.RELEASE.jar:3.2.8.RELEASE]
jvm 1 | at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:296)[spring-beans-3.2.8.RELEASE.jar:3.2.8.RELEASE]
jvm 1 | at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:223)[spring-beans-3.2.8.RELEASE.jar:3.2.8.RELEASE]
jvm 1 | at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:293)[spring-beans-3.2.8.RELEASE.jar:3.2.8.RELEASE]
jvm 1 | at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:194)[spring-beans-3.2.8.RELEASE.jar:3.2.8.RELEASE]
jvm 1 | at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:628)[spring-beans-3.2.8.RELEASE.jar:3.2.8.RELEASE]
jvm 1 | at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:932)[spring-context-3.2.8.RELEASE.jar:3.2.8.RELEASE]
jvm 1 | at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:479)[spring-context-3.2.8.RELEASE.jar:3.2.8.RELEASE]
jvm 1 | at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:64)[xbean-spring-3.16.jar:3.16]
jvm 1 | at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:52)[xbean-spring-3.16.jar:3.16]
jvm 1 | at org.apache.activemq.xbean.XBeanBrokerFactory$1.<init>(XBeanBrokerFactory.java:104)[activemq-spring-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)[activemq-spring-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)[activemq-spring-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)[activemq-broker-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)[activemq-broker-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)[activemq-console-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:57)[activemq-console-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:150)[activemq-console-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:57)[activemq-console-5.10.0.jar:5.10.0]
jvm 1 | at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)[activemq-console-5.10.0.jar:5.10.0]
jvm 1 | at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)[:1.8.0_101]
jvm 1 | at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)[:1.8.0_101]
jvm 1 | at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)[:1.8.0_101]
jvm 1 | at java.lang.reflect.Method.invoke(Unknown Source)[:1.8.0_101]
jvm 1 | at org.apache.activemq.console.Main.runTaskClass(Main.java:262)[activemq.jar:5.10.0]
jvm 1 | at org.apache.activemq.console.Main.main(Main.java:115)[activemq.jar:5.10.0]
jvm 1 | at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)[:1.8.0_101]
jvm 1 | at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)[:1.8.0_101]
jvm 1 | at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)[:1.8.0_101]
jvm 1 | at java.lang.reflect.Method.invoke(Unknown Source)[:1.8.0_101]
jvm 1 | at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)[wrapper.jar:3.2.3]",Bug
AMQ-5278,12727671,,"When using AMQP with transformer=jms, redelivered messages have a corrupted payload (payload of all zeros).  Creating this JIRA to link to the already opened Proton JIRA (624) and to provide a unit test for ActiveMQ.

See https://issues.apache.org/jira/browse/PROTON-624 for details.
",Bug
AMQ-5315,12732737,,"We have seen the following NPE setting up a demand forwarding bridge
{code}
java.lang.NullPointerException: null
	at org.apache.activemq.network.DemandForwardingBridgeSupport.collectBrokerInfos(DemandForwardingBridgeSupport.java:365) [activemq-broker-5.10.0.jar:5.10.0]
	at org.apache.activemq.network.DemandForwardingBridgeSupport.access$400(DemandForwardingBridgeSupport.java:105) [activemq-broker-5.10.0.jar:5.10.0]
	at org.apache.activemq.network.DemandForwardingBridgeSupport$5.run(DemandForwardingBridgeSupport.java:331) [activemq-broker-5.10.0.jar:5.10.0]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) [na:1.7.0_60]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) [na:1.7.0_60]
	at java.lang.Thread.run(Thread.java:745) [na:1.7.0_60]
{code}

This occurred in one of our tests but only under load so seems to be a race condition of some sort.
",Bug
AMQ-5252,12724421,,"Upgrading from a 5.5.1 broker to 5.10. 
I've managed to work around the issue by making some changes to org.apache.activemq.web.LocalBrokerFacade, but unsure if this is the root issue or a band-aid fix. 

{code}
Set destinations = getManagedBroker().getQueueRegion().getDestinations(destination); 
{code}

returns a AuthorizationDestinationFilter when the code is expecting a org.apache.activemq.broker.region.Queue - calling getNext() on the AuthorizationDestinationFilter returns the expected Queue. 
            

Old code:
{code}
 public void purgeQueue(ActiveMQDestination destination) throws Exception {	
        Set destinations = getManagedBroker().getQueueRegion().getDestinations(destination);
        for (Iterator i = destinations.iterator(); i.hasNext();) 
        {        	
            Destination dest = (Destination) i.next();
            if (dest instanceof Queue) {
                Queue regionQueue = (Queue) dest;
                regionQueue.purge();
           }
        }
    }
{code}
new:

{code}
 public void purgeQueue(ActiveMQDestination destination) throws Exception {	
        Set destinations = getManagedBroker().getQueueRegion().getDestinations(destination);
        for (Iterator i = destinations.iterator(); i.hasNext();) 
        {        	
            Destination dest = (Destination) i.next();
            if (dest instanceof Queue) {
                Queue regionQueue = (Queue) dest;
                regionQueue.purge();
            }
            else if(dest instanceof  AuthorizationDestinationFilter)
            {
            	AuthorizationDestinationFilter adf = (AuthorizationDestinationFilter)dest;
            	if (adf.getNext() instanceof Queue) 
            	{
            		Queue regionQueue = (Queue)adf.getNext();
                    regionQueue.purge();  
            	}
            }
        }
    }
{code}


Attached is the activemq.xml file we're using to test this - creating a message on the webconsole and then attempting to purge it will fail unless either the code change above is made, or the <plugins> section of activemq.xml is commented out. ",Bug
AMQ-5859,12839891,,"the reconnection attempts logic  based on the reconnection policy seems wrong.

In JmsConnector#doInitializeConnection the loop trying to reconnect to the foreign broker only execute once due to the erroneous test in the while
{code}
while (maxRetries < ++attempt && !connectionSerivce.isTerminating());
{code}
should be
{code}
while (maxRetries > ++attempt && !connectionSerivce.isTerminating());
{code}
",Bug
AMQ-5961,12863111,,"When we run JBoss EAP 6.4 with high load using AMQ 6.2 (ActiveMQ 5.11) everything grinds to a halt after a few hours. We have 170 threads blocked on the same lock:

""default-threads - 1400"" #406720 prio=5 os_prio=0 tid=0x00007f1b8402b800 nid=0xfe2d waiting for monitor entry [0x00007f19ccdd5000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at org.apache.activemq.TransactionContext.setXid(TransactionContext.java:729)
	- waiting to lock <0x000000063ac688b8> (a java.util.HashMap)
	at org.apache.activemq.TransactionContext.end(TransactionContext.java:418)
	at org.apache.activemq.ra.LocalAndXATransaction.end(LocalAndXATransaction.java:98)
	at org.jboss.jca.core.tx.jbossts.XAResourceWrapperImpl.end(XAResourceWrapperImpl.java:118)
	at com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord.topLevelPrepare(XAResourceRecord.java:208)
	at com.arjuna.ats.arjuna.coordinator.BasicAction.doPrepare(BasicAction.java:2530)
	at com.arjuna.ats.arjuna.coordinator.BasicAction.doPrepare(BasicAction.java:2497)
	at com.arjuna.ats.arjuna.coordinator.BasicAction.prepare(BasicAction.java:2074)
	- locked <0x000000067461c090> (a com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction)
	at com.arjuna.ats.arjuna.coordinator.BasicAction.End(BasicAction.java:1485)
	- locked <0x000000067461c090> (a com.arjuna.ats.internal.jta.transaction.arjunacore.AtomicAction)
	at com.arjuna.ats.arjuna.coordinator.TwoPhaseCoordinator.end(TwoPhaseCoordinator.java:98)
	at com.arjuna.ats.arjuna.AtomicAction.commit(AtomicAction.java:162)

This lock is owned by a thread that is waiting for another lock:

""default-threads - 1381"" #404073 prio=5 os_prio=0 tid=0x00007f1a6403c000 nid=0x7d49 waiting on condition [0x00007f19d8a91000]
   java.lang.Thread.State: WAITING (parking)
	at sun.misc.Unsafe.park(Native Method)
	- parking to wait for  <0x000000063ab2a260> (a java.util.concurrent.locks.ReentrantLock$NonfairSync)
	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:870)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1199)
	at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLock.java:209)
	at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:285)
	at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:66)
	at org.apache.activemq.transport.ResponseCorrelator.oneway(ResponseCorrelator.java:60)
	at org.apache.activemq.ActiveMQConnection.doAsyncSendPacket(ActiveMQConnection.java:1309)
	at org.apache.activemq.ActiveMQConnection.asyncSendPacket(ActiveMQConnection.java:1303)
	at org.apache.activemq.ActiveMQSession.asyncSendPacket(ActiveMQSession.java:2008)
	at org.apache.activemq.ActiveMQSession$5.afterRollback(ActiveMQSession.java:973)
	at org.apache.activemq.TransactionContext.afterRollback(TransactionContext.java:162)
	at org.apache.activemq.TransactionContext.prepare(TransactionContext.java:482)
	- locked <0x000000063ac688b8> (a java.util.HashMap)
	at org.apache.activemq.ra.LocalAndXATransaction.prepare(LocalAndXATransaction.java:130)
	at com.arjuna.ats.internal.jta.resources.arjunacore.XAResourceRecord.topLevelPrepare(XAResourceRecord.java:213)
	at com.arjuna.ats.arjuna.coordinator.BasicAction.doPrepare(BasicAction.java:2530)
	at com.arjuna.ats.arjuna.coordinator.BasicAction.doPrepare(BasicAction.java:2497)

The locked object is ENDED_XA_TRANSACTION_CONTEXTS in TransactionContext. The thread that has the lock calls afterRollback without first releasing it and afterRollback does not return promptly (not at all in fact, we need to restart the server to fix this). The same can happen with afterCommit, which is also called from within a synchronized block causing a potential deadlock.

I think I have a fix for this and will create a pull request in github, or if you prefer I can send a patch? It simply means moving the external calls out from the synchronized blocks and would both remove the very real deadlock risks and improve performance.",Bug
AMQ-5563,12772304,,"In org.apache.activemq.camel.component.ActiveMQConfiguration

We have default values

    private boolean useSingleConnection = false;
    private boolean usePooledConnection = true;


And the javadoc says
{code}
    /**
     * Enables or disables whether a Spring {@link SingleConnectionFactory} will be used so that when
     * messages are sent to ActiveMQ from outside of a message consuming thread, pooling will be used rather
     * than the default with the Spring {@link JmsTemplate} which will create a new connection, session, producer
     * for each message then close them all down again.
     * <p/>
     * The default value is true so that a single connection is used by default.
     *
     * @param useSingleConnection
     */
    public void setUseSingleConnection(boolean useSingleConnection) {
        this.useSingleConnection = useSingleConnection;
    }


    /**
     * Enables or disables whether a PooledConnectionFactory will be used so that when
     * messages are sent to ActiveMQ from outside of a message consuming thread, pooling will be used rather
     * than the default with the Spring {@link JmsTemplate} which will create a new connection, session, producer
     * for each message then close them all down again.
     * <p/>
     * The default value is false by default as it requires an extra dependency on commons-pool.
     */
    public void setUsePooledConnection(boolean usePooledConnection) {
        this.usePooledConnection = usePooledConnection;
    }
{code}

Notice the javadoc has wrong defaults. Its in fact pooled that is the default.",Bug
AMQ-5903,12849466,,"When using the broker camel component as defined here:  http://activemq.apache.org/broker-camel-component.html

There appears to be an undocumented limitation of the broker component's current implementation. I need to know whether said limitation is by design or an oversight. If it's an oversight then I can submit a patch for it.

This example route does not work as expected - the JMSXGroupID header is lost when received by the broker component.

<route> 
<from uri=""broker:queue:test""/> 
<setHeader headerName=""JMSXGroupID""> 
<constant>123</constant> 
</setHeader> 
<to uri=""broker:queue:test""/> 
</route>

After single stepping with a debugger the component executes this code: https://github.com/apache/activemq/blob/master/activemq-camel/src/main/java/org/apache/activemq/camel/component/broker/BrokerProducer.java#L102

As you can see from the method's implementation it only copies over a fixed set of six well-known headers. All other headers on the inbound message are discarded. Why not copy over every header? Consequently the JMSXGroupID header is not copied, despite being present on the inbound message.

This would appear to be a bug in my opinion as I do not believe we should be loosing any headers on a message in this case.  ",Bug
AMQ-5877,12844064,,"We are unable to read the message with message selector if we follow the below steps in ActiveMQ 5.11.1 
* Start ActiveMQ
* Send Two messages
* Read one message with our selector,Using consumer.recieve() API
* Send One more message, And hold the messageId
* Read the message with the above message Id which we are holding as a selector(""JMSMessageID='"" + messageId + ""'"") immediately.
* Now message we wont able to read, consumer thread will be waiting infinitely

*Note :*  Its required activemq-all-5.11.1.jar,Junit jars need to be in classpath.

Issue reproducible prgoram
{code:java}
import java.util.Properties;

import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.Message;
import javax.jms.MessageConsumer;
import javax.jms.MessageProducer;
import javax.jms.Queue;
import javax.jms.Session;
import javax.naming.Context;
import javax.naming.InitialContext;

import org.junit.AfterClass;
import org.junit.Assert;
import org.junit.BeforeClass;
import org.junit.Test;

/**
 * We are unable to read the message with message selector if we follow the
 * below steps in ActiveMQ 5.11.1
 * <ul>
 * <li>Start ActiveMQ</li>
 * <li>Send Two messages</li>
 * <li>Read one message with our selector,Using consumer.recieve() API</li>
 * <li>Send One more message, And hold the messageId</li>
 * <li>Read the message with the above message Id which we are holding as a
 * selector(""JMSMessageID='"" + messageId + ""'"") immediately.</li>
 * <li>Now message we wont able to read, consumer thread will be waiting
 * infinitely</li>
 * </ul>
 * <b>Note : </b> Its required activemq-all-5.11.1.jar,Junit jars need to be in classpath.
 *
 */
public final class MessageSelectorJunit {

	private static Connection connection = null;
	private static final String CONTEXT_FACTORY = ""org.apache.activemq.jndi.ActiveMQInitialContextFactory"";
	private static final String URL = ""tcp://localhost:61616"";
	private static final String QUEUE_NAME = ""TestQueue"";

	@BeforeClass
	public static void oneTimeSetUp() throws Exception {
		Properties properties = new Properties();
		properties.setProperty(Context.INITIAL_CONTEXT_FACTORY, CONTEXT_FACTORY);
		properties.setProperty(Context.PROVIDER_URL, URL);

		// Connection Creation
		Context context = new InitialContext(properties);
		ConnectionFactory connectionFactory = (ConnectionFactory) context.lookup(""QueueConnectionFactory"");
		connection = connectionFactory.createConnection();
		connection.start();
	}

	@Test
	public void testScenario() throws Exception {
		// Message1
		sendJMSMessage();
		sendJMSMessage();
		getJMSMessage(null);

		// Message2
		String messageId2 = sendJMSMessage();
		String messageSelector = ""JMSMessageID='"" + messageId2 + ""'"";
		Assert.assertNotNull(""Expected message to be read with message selector : "" + messageSelector,
				getJMSMessage(messageSelector));
	}

	private String sendJMSMessage() throws Exception {
		String messageId = null;
		Session session = null;
		MessageProducer producer = null;
		try {
			session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
			producer = session.createProducer(session.createQueue(QUEUE_NAME));

			Message msg = session.createTextMessage(""Test Message"");
			producer.send(msg);

			messageId = msg.getJMSMessageID();
			System.out.println(""Send MessageId : "" + messageId);
		} finally {
			producer.close();
			session.close();
		}
		return messageId;
	}

	private String getJMSMessage(String messageSelector) throws Exception {
		String recievedId = null;
		MessageConsumer consumer = null;
		Session session = null;
		try {
			session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
			Queue queue = session.createQueue(QUEUE_NAME);
			System.out.println(""Started Recieving the message with the message selector : "" + messageSelector);
			consumer = session.createConsumer(queue, messageSelector);
			connection.start();
			Message msg = consumer.receive(1000);
			if (msg != null) {
				recievedId = msg.getJMSMessageID();
				System.out.println(""Message Recieved, Id : "" + msg.getJMSMessageID());
			} else {
				System.out.println(""Message not recieved."");
			}
		} finally {
			consumer.close();
			session.close();
		}
		return recievedId;
	}

	@AfterClass
	public static void oneTimeTearDown() throws Exception {
		if (connection != null) {
			connection.close();
		}
	}
}
{code}",Bug
AMQ-5804,12833170,,"After specifying connection url like:
https://address:443?proxyHost=192.168.1.1&proxyPort=80
I got exception Scheme 'http' not registered
It happens because default schema for proxy is http,
but when we uses https address it registers only https schema in HttpsClientTransport

",Bug
AMQ-5668,12782550,,"Running KahaDB with concurrentStoreAndDispatchTopics=""true"" and sending 3 MQTT messages using different QoS values raises 

{code}
2015-03-17 13:27:48,866 WARN ActiveMQ NIO Worker 2 - Failed to send MQTT Publish:
java.lang.NullPointerException
	at org.apache.activemq.broker.region.cursors.AbstractStoreCursor.setLastCachedId(AbstractStoreCursor.java:319)
	at org.apache.activemq.broker.region.cursors.AbstractStoreCursor.trackLastCached(AbstractStoreCursor.java:280)
	at org.apache.activemq.broker.region.cursors.AbstractStoreCursor.addMessageLast(AbstractStoreCursor.java:213)
	at org.apache.activemq.broker.region.cursors.TopicStorePrefetch.addMessageLast(TopicStorePrefetch.java:74)
	at org.apache.activemq.broker.region.cursors.StoreDurableSubscriberCursor.addMessageLast(StoreDurableSubscriberCursor.java:198)
	at org.apache.activemq.broker.region.PrefetchSubscription.add(PrefetchSubscription.java:159)
	at org.apache.activemq.broker.region.DurableTopicSubscription.add(DurableTopicSubscription.java:274)
	at org.apache.activemq.broker.region.policy.SimpleDispatchPolicy.dispatch(SimpleDispatchPolicy.java:48)
	at org.apache.activemq.broker.region.Topic.dispatch(Topic.java:717)
	at org.apache.activemq.broker.region.Topic.doMessageSend(Topic.java:510)
	at org.apache.activemq.broker.region.Topic.send(Topic.java:441)
	at org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:419)
	at org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:468)
	at org.apache.activemq.broker.jmx.ManagedRegionBroker.send(ManagedRegionBroker.java:297)
	at org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:152)
	at org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)
	at org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:307)
	at org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:157)
	at org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:541)
	at org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:768)
	at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:334)
	at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:188)
	at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:45)
	at org.apache.activemq.transport.mqtt.MQTTInactivityMonitor.onCommand(MQTTInactivityMonitor.java:147)
	at org.apache.activemq.transport.mqtt.MQTTTransportFilter.sendToActiveMQ(MQTTTransportFilter.java:106)
	at org.apache.activemq.transport.mqtt.MQTTProtocolConverter.sendToActiveMQ(MQTTProtocolConverter.java:173)
	at org.apache.activemq.transport.mqtt.MQTTProtocolConverter.onMQTTPublish(MQTTProtocolConverter.java:445)
	at org.apache.activemq.transport.mqtt.MQTTProtocolConverter.onMQTTCommand(MQTTProtocolConverter.java:210)
	at org.apache.activemq.transport.mqtt.MQTTTransportFilter.onCommand(MQTTTransportFilter.java:94)
	at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)
	at org.apache.activemq.transport.mqtt.MQTTCodec$1.onFrame(MQTTCodec.java:54)
	at org.apache.activemq.transport.mqtt.MQTTCodec.processCommand(MQTTCodec.java:79)
	at org.apache.activemq.transport.mqtt.MQTTCodec.access$400(MQTTCodec.java:26)
	at org.apache.activemq.transport.mqtt.MQTTCodec$4.parse(MQTTCodec.java:194)
	at org.apache.activemq.transport.mqtt.MQTTCodec$3.parse(MQTTCodec.java:160)
	at org.apache.activemq.transport.mqtt.MQTTCodec$2.parse(MQTTCodec.java:123)
	at org.apache.activemq.transport.mqtt.MQTTCodec.parse(MQTTCodec.java:65)
	at org.apache.activemq.transport.mqtt.MQTTNIOTransport.serviceRead(MQTTNIOTransport.java:105)
	at org.apache.activemq.transport.mqtt.MQTTNIOTransport.access$000(MQTTNIOTransport.java:43)
	at org.apache.activemq.transport.mqtt.MQTTNIOTransport$1.onSelect(MQTTNIOTransport.java:66)
	at org.apache.activemq.transport.nio.SelectorSelection.onSelect(SelectorSelection.java:97)
	at org.apache.activemq.transport.nio.SelectorWorker$1.run(SelectorWorker.java:119)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
	at java.lang.Thread.run(Thread.java:744)
{code}",Bug
AMQ-6185,12944842,,"The keep-alive mechanism does not work (no keep-alives are sent), when the connections go over HTTP layer.
The InactivityMonitor closes then the connection and new connection to target is established. This repeats every 30 seconds (the default time out).

E.g.: Let's have a simple broker network. Machine A connects to machine B with duplex network bridge over HTTP...

Machine A config:
<networkConnector duplex=""true"" uri=""static:(http://machineB:61617)"" name=""bridgeToB"" />

Machine B config:
<transportConnector name=""http"" uri=""http://0.0.0.0:61617?maximumConnections=1000&amp;wireFormat.maxFrameSize=104857600""/>

When the transport layer is changed to e.g. TCP then keep-alive works and the connection is persistent.
",Bug
AMQ-6350,12988297,,"Blueprint:
{code}
<cm:property-placeholder persistent-id="".."" update-strategy=""reload"" />
<bean id=""pooledConnectionFactory"" class=""org.apache.activemq.jms.pool.PooledConnectionFactory""
        init-method=""start"" destroy-method=""stop"">
...
</bean>
{code}
or Java:
{code}
org.apache.activemq.jms.pool.PooledConnectionFactory pcf = new org.apache.activemq.jms.pool.PooledConnectionFactory();
pcf.start();
...
pcf.stop();
pcf.start();
// producer.send(textMsg);
{code}

Stacktrace:
{code}
Caused by: javax.jms.IllegalStateException: java.lang.IllegalStateException: Pool not open
	at org.apache.activemq.jms.pool.ConnectionPool.createSession(ConnectionPool.java:159)
	at org.apache.activemq.jms.pool.PooledConnection.createSession(PooledConnection.java:167)
	at org.talend.ipaas.rt.amqsource.AMQEventSource.createJmsSession(AMQEventSource.java:282)
	at org.talend.ipaas.rt.amqsource.AMQEventSource.sendEvent(AMQEventSource.java:117)
	... 2 more
Caused by: java.lang.IllegalStateException: Pool not open
	at org.apache.commons.pool2.impl.BaseGenericObjectPool.assertOpen(BaseGenericObjectPool.java:672)
	at org.apache.commons.pool2.impl.GenericKeyedObjectPool.borrowObject(GenericKeyedObjectPool.java:339)
	at org.apache.commons.pool2.impl.GenericKeyedObjectPool.borrowObject(GenericKeyedObjectPool.java:279)
	at org.apache.activemq.jms.pool.ConnectionPool.createSession(ConnectionPool.java:141)
	... 5 more
{code}",Bug
AMQ-7010,13171677,,"Recently, we upgraded our ActiveMQ instance from {{5.13.2}} to {{5.15.3}}. We basically use an almost default broker setup with KahaDB. Due to our setup, we occasionally run into {{java.io.IOException: No space left on device}}, which until now was fine since the broker would properly ignore them using the {{DefaultIOExceptionHandler}}, and resume its work once space is available again.

After upgrading to {{5.15.3}}, however, we noticed that the broker would actually stop itself following a _no space left_ exception. Digging a little bit, it seems that the change in behavior can be linked to a fix introduced in the {{5.15.0}} release, see AMQ-6625. With this fix, KahaDB would sometimes throw the following exception: {{java.io.IOException: Async Writer Thread Shutdown}} from its {{DataFileAppender}}, which, unfortunately, is not handled by the {{DefaultIOExceptionHandler}} unless {{ignoreAllErrors}} is set to true.

This would basically mean that the {{DefaultIOExceptionHandler}} has become useless in catching only _no space left_ exceptions, which I do not think is the intended behavior. 
h3. How to reproduce
 # Start a broker with default config on a small partition
 # Send a persistent message with web console to any queue
 # Fill the partition by any mean
 # Send more messages with web console, broker is eventually shut down

See the attached broker logs.",Bug
AMQ-6549,13029727,,Wrong logging message,Bug
AMQ-7006,13169695,,The patch referenced in AMQ-5423 only addressed the memory leak for Client-Individual mode. Client mode is still affected as multiple messages are acknowledged with a single ACK.  The single ACK is removed from memory but all the rest remain which grows over time until AMQ crashes or until the client session ends and all the pending ACKs are cleaned up at that point.  At the moment we are having to regularly restart our STOMP clients to prevent the memory leak from causing a crash.,Bug
AMQ-7118,13201770,,"KahaDB store limit can be exceeded with durable subscribers.

AMQ with store limit set, we can observe that the usage continues to increase AFTER PFC is engaged. Given time, this growth stabilizes. The issue of having exceeded the store limit remains.

See below output from KahaDB dump in attachments:

This appears to be caused by checkpointAckMessageFileMap. The log files are not GC'd, and the KAHA_ACK_MESSAGE_FILE_MAP_COMMAND is replicated and the DB log files continue to expand - this can become exponential. Side effect of also not checking storage size in checkpoint update can cause the DB log files to exceed any set limits. The real critical part is the duplicated and leaking Kaha messages which appears to happen with durable subscribers.

 

 

 ",Bug
AMQ-6042,12912765,,"In ActiveMQMessageConsumer, currently the rollback cause is only set for the case auto- or individual-acks. However, it should also be set for the other cases, so that in the rollback() method it can be picked up when creating the poison ack.

{code}
    if (isAutoAcknowledgeBatch() || isAutoAcknowledgeEach() || session.isIndividualAcknowledge()) {
        // schedual redelivery and possible dlq processing
        md.setRollbackCause(e);
        rollback();
    } else {
        // Transacted or Client ack: Deliver the next message.
        afterMessageIsConsumed(md, false);
    }
{code}

I'd suggest to move md.setRollbackCause(e); to before the if().",Bug
AMQ-5316,12732764,,"LoggingBrokerPluggin.logMessageEvents is not used.

It would be good to remove it from the configuration to avoid confusion - patch attached.

It would also be good to remove this from http://activemq.apache.org/logging-interceptor.html



",Bug
AMQ-4781,12671985,,,Bug
AMQ-4500,12645516,,"SparseAckReplayAfterStoreCleanupLevelDBStoreTest extends AMQ2832Test but uses LevelDB.  The test case testAlternateLossScenario is dependent on KahaDB, so it fails under SparseAckReplayAfterStoreCleanupLevelDBStoreTest.

I'll add a patch which skips this test when using LevelDB.
",Bug
AMQ-4427,12640315,,"260 out of 454 failed on the last run, mostl with ""java.net.BindException: Address already in use""
",Bug
AMQ-4415,12639641,,"Problem tests include:

AMQ2584Test 
AMQ2870Test  
QueueMbeanRestartTest 
FailoverTransactionTest
ConcurrentProducerDurableConsumerTest
DurableSubscriptionOfflineTest

The patch adds timeouts, and for the AMQ2584Test and AMQ2870Test does not run the LevelDB instance of the test, as these fail in tearDown, so timeouts do not prevent the tests from hanging.

Note:  Where possible I've changed these from using CombinationTestSupport to JUnit4 Parameterized tests with timeouts defined.  It looks like sometimes if a test which extends CombinationTestSupport turns on AutoFail and a timeout occurs, Maven reports the following:

Results :

Tests run: 0, Failures: 0, Errors: 0, Skipped: 0

",Bug
AMQ-4265,12628729,,"This test is failing with error:

Failed to start per destination persistence adapter for destination: queue://TEST.QUEUE, options:[KahaDBPersistenceAdapter[/home/jenkins/jenkins-slave/workspace/ActiveMQ-Java7/activemq-core/target/activemq-data/mKahaDB/queue#3a#2f#2fTEST.QUEUE], KahaDBPersistenceAdapter[/home/jenkins/jenkins-slave/workspace/ActiveMQ-Java7/activemq-core/target/activemq-data/mKahaDB/queue#3a#2f#2fTEST.QUEUE]]

",Bug
AMQ-4400,12638584,,"This is one of those once in a blue moon failures, but it just failed on fuse CI the other night.
",Bug
AMQ-4281,12629704,,"This depends on the order the tests are run in.  testConnectionFailsToConnectToVMBrokerThatIsNotRunning will fail if it is run after either testSetExceptionListener or testSetClientInternalExceptionListener.
",Bug
AMQ-4260,12628121,,"MessageGroupLateArrivalsTest fails intermittently on some systems.  In the testConsumersLateToThePartyGetSomeNewGroups test, it looks like sometimes worker2 does not start in time, so worker1 consumes all of it's messages.",Bug
AMQ-4388,12637647,,"I think this is the last of the tests which ironically fail because of the use of platform specific File.seperator.
",Bug
AMQ-4387,12637643,,"All test cases are failing on windows, where only testStompNIOSSLWithCertificate fails on mac or ubuntu",Bug
AMQ-4379,12637246,,The testTransactions case fails because of a hardcoded reference to /tmp,Bug
AMQ-4331,12632900,,"The activemq.xml file used by this test contained:

    <persistenceAdapter>
      <kahaPersistenceAdapter directory=""file:target/amq1095""
          maxDataFileLength=""200000""/>
    </persistenceAdapter>

which is no longer valid.  I fixed the test by changing it to 

    <persistenceAdapter>
      <kahaDB directory=""file:target/amq1095""/>
    </persistenceAdapter>",Bug
AMQ-4389,12637817,,,Bug
AMQ-4342,12633661,,"This test fails intermittently at a point where it expects BrokerView.getMemoryPercentUsage() to return 0, but it returns 1.  The problem here is that getMemoryPercentageUsage returns an int, and that number is truncated when calculated.

I did some debugging and found when the test fails the actual usage is about 0.85%, and when it fails it's only 1.02%.  I'll attach a patch that makes the assertion here slightly more lenient to accommodate for this.
",Bug
AMQ-4463,12641463,,"This fails occasionally with the following messages because of a race condition at startup:

java.lang.AssertionError: No messages received on iteration: 0

",Bug
AMQ-3214,12500963,,"-Have a multi-thread consumers running to consumer messages
-Have Connection to have these :
       		ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(brokerUrl);
		connectionFactory.setUseAsyncSend(false);
		connectionFactory.s",Bug
AMQ-3735,12543779,,"I downloaded the latest snapshot of the source today and tried installing the broker as a service using the instructions here: http://www.forwardslashbin.com/?p=46. When running it, apparently the Jetty configuration could not find the path to the conf folder. When removing the jetty.xml file from activemq xml, everything seemed to execute fine. Looking at the revision history, it looks like ${activemq.conf} is new to help externalize conf files. I'll be attaching the wrapper.log to this bug.",Bug
AMQ-3709,12541891,,"We created a monitor that utilizes calls to the web-console to determine stuck messages.  Occasionally, requests come back 404 (because the message disappears between calls) and the monitor dies because the XHTML for that page is invalid.  This patch makes the 404 and 500 pages valid in the eyes of the w3c markup validation service.

Note: I'm placing the patch here because I do not see a place to upload it on this form.  If it appears later, I will attached.

Index: activemq-web-console/src/main/webapp/500.html
===================================================================
--- activemq-web-console/src/main/webapp/500.html	(revision 1242141)
+++ activemq-web-console/src/main/webapp/500.html	(working copy)
@@ -22,8 +22,7 @@
  
 <!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN"" ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd""> 
  
-<!DOCTYPE html PUBLIC ""-//W3C//DTD HTML 4.01 Transitional//EN"" ""http://www.w3.org/TR/html4/loose.dtd""> 
-<html> 
+<html xmlns='http://www.w3.org/1999/xhtml'> 
 <head> 
     <meta http-equiv=""Content-Type"" content=""text/html; charset=iso-8859-1"" /> 
     <title>Apache ActiveMQ</title> 
@@ -67,7 +66,7 @@
                     <div class=""top_red_bar""> 
                         <div id=""site-breadcrumbs""> 
                         </div> 
-                        <div id=""site-quicklinks""><P> 
+                        <div id=""site-quicklinks""><p> 
                             <a href=""http://activemq.apache.org/support.html""
                                title=""Get help and support using Apache ActiveMQ"">Support</a></p> 
                         </div> 
@@ -93,7 +92,7 @@
                                     <div class=""navigation""> 
                                         <div class=""navigation_top""> 
                                             <div class=""navigation_bottom""> 
-                                                <H3>Useful Links</H3> 
+                                                <h3>Useful Links</h3> 
  
                                                 <ul class=""alternate"" type=""square""> 
                                                     <li><a href=""http://activemq.apache.org/""
Index: activemq-web-console/src/main/webapp/404.html
===================================================================
--- activemq-web-console/src/main/webapp/404.html	(revision 1242141)
+++ activemq-web-console/src/main/webapp/404.html	(working copy)
@@ -22,8 +22,7 @@
  
 <!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN"" ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd""> 
  
-<!DOCTYPE html PUBLIC ""-//W3C//DTD HTML 4.01 Transitional//EN"" ""http://www.w3.org/TR/html4/loose.dtd""> 
-<html> 
+<html xmlns='http://www.w3.org/1999/xhtml'> 
 <head> 
     <meta http-equiv=""Content-Type"" content=""text/html; charset=iso-8859-1"" /> 
     <title>Apache ActiveMQ</title> 
@@ -67,7 +66,7 @@
                     <div class=""top_red_bar""> 
                         <div id=""site-breadcrumbs""> 
                         </div> 
-                        <div id=""site-quicklinks""><P> 
+                        <div id=""site-quicklinks""><p> 
                             <a href=""http://activemq.apache.org/support.html""
                                title=""Get help and support using Apache ActiveMQ"">Support</a></p> 
                         </div> 
@@ -92,7 +91,7 @@
                                     <div class=""navigation""> 
                                         <div class=""navigation_top""> 
                                             <div class=""navigation_bottom""> 
-                                                <H3>Useful Links</H3> 
+                                                <h3>Useful Links</h3> 
  
                                                 <ul class=""alternate"" type=""square""> 
                                                     <li><a href=""http://activemq.apache.org/""


",Bug
AMQ-3601,12532121,,A no-args constructor should be added to org.apache.activemq.util.ByteSequence,Bug
AMQ-3587,12531000,,"Even when started with an existing log, the LogFileManager initializes activeLogFileCount to zero. This leads to LogFileManager.isPastHalfActive() to incorrectly return false and no JournalEventListener.overflowNotification() being issued.",Bug
AMQ-3450,12518810,,"We have a situation in front of us and its explained as below:

1. We have durable subscriber subscribed to a topic. 
2. This durable subscriber is a perl script which is run by a daemon.
3. The perl script uses stomp to connect to the broker.
4. The perl script wakes up every 5 mins, checks for messages in the topic and processes them in a batch by pre-fetching the messages.
5. The subscriber uses a client acknowledgement and acknowledges only the last message of the batch.
6. We are using AMQ 5.5 with kahaDB persistence.

Now what we see is,

1. Even though the messages are processed in a batch and the last message is acknowledged the inflight count does not come down.
2. Enqueue count, Dequeue count and Dispatch count do not match.
3. The journal files are not getting cleaned up.

I do understand that the journal files would be cleaned up once the references to the messages are lost or removed (i.e. the messages are consumed). But does it have to do anything with the various count attributes I see on the topic?

Also should I expect the inflight count to come down to 0 if client crashes and then consumes all messages after come back live?

I also see that dequeue count stays at 0 even when the dispatch count and the inflight counts change. I believe dequeue count has got a direct relation with messages getting removed from the topic.

Please let me know if there could be any other reason that could cause the journal files to stay back.

Thank you
Hari",Bug
AMQ-3037,12483885,,"When use a ActiveMQMapMessage.setLong(""key"", 200) and then use ActiveMQMapMessage.getInt(""key"") it will throw an Exception.

Exceptions is;
javax.jms.MessageFormatException:  cannot read an int from java.lang.Long
	at org.apache.activemq.command.ActiveMQMapMessage.getInt(ActiveMQMapMessage.java:320)
",Bug
AMQ-484,12481471,,"When transport connector as follows is defined

<transportConnector uri=""tcp://localhost:61616"" discoveryUri=""multicast://default""/>

in conjuction with the broker definition of:

<broker useJmx=""true"" />

The resulting TransportConnector created by XBeans from the defintion is provided with the discoveryUri.  However, the BrokerService then replaces that instance with ManagedTransportConnector instance but does not transfer the discoveryUri.  The result is no discovery agent is created for the connector when the connector is started.


",Bug
AMQ-1292,12482009,,commit for 549845 took out the logger imports but it left the logger,Bug
AMQ-1221,12482006,,"I found this problems when I try to consume from a Queue But I didn't when the Queue is a local one !!!!!!!!!!!!!!!!!!!!!

this is what I found in the consol when I run the example :

<<<<<<"""" Caught: java.lang.RuntimeException: javax.jms.JMSException: Failed to build body from bytes. Reason: java.io.IOException: com.tunisiana.ws.common.audit.AuditMessage
java.lang.RuntimeException: javax.jms.JMSException: Failed to build body from bytes. Reason: java.io.IOException: com.tunisiana.ws.common.audit.AuditMessage
	at file1.tt2$HelloWorldConsumer.run(tt2.java:197)
	at file1.tt2.main(tt2.java:38)
Caused by: javax.jms.JMSException: Failed to build body from bytes. Reason: java.io.IOException: com.tunisiana.ws.common.audit.AuditMessage
	at org.apache.activemq.util.JMSExceptionSupport.create(JMSExceptionSupport.java:33)
	at org.apache.activemq.command.ActiveMQObjectMessage.getObject(ActiveMQObjectMessage.java:172)
	at file1.tt2$HelloWorldConsumer.run(tt2.java:191)
	... 1 more
Caused by: java.io.IOException: com.tunisiana.ws.common.audit.AuditMessage
	at org.apache.activemq.command.ActiveMQObjectMessage.getObject(ActiveMQObjectMessage.java:168)
	... 2 more   """">>>>>
",Bug
AMQ-2707,12483423,,"I built activemq-protobuf from http://svn.apache.org/repos/asf/activemq/activemq-protobuf/trunk/ (r817001).
I changed the configuration of the activemq-protobuf plugin in the activemq-protobuf-test pom.xml to use type {{alt}}.
The plugin generates invalid Java for .proto files defining nested messages.

An example:

{code:title=Simple.proto}
package foo;

message Outer {
  message Inner {
    required string x = 1;
  }
  required Inner inner = 1;
}
{code}

generates code including a method {{Simple.Outer.OuterBean.readExternal}}:

{code:title=Simple.java}
public void readExternal(java.io.DataInput in) throws java.io.IOException {
  assert frozen==null : org.apache.activemq.protobuf.MessageBufferSupport.FORZEN_ERROR_MESSAGE;
  bean = this;
  frozen = null;
  if( in.readBoolean() ) {
    Outer.Inner.Outer.InnerBean o = new Outer.Inner.Outer.InnerBean();
    o.readExternal(in);
    f_inner = o;
  } else {
    f_inner = null;
  }
}
{code}

which fails to compile; it should refer to {{Outer.Inner.InnerBean}} rather than {{Outer.Inner.Outer.InnerBean}}.

I'm attaching a zip containing a patch which I've tested with 4 levels of nesting, & some test .proto files.",Bug
AMQ-1229,12482519,12485942,"org.apache.activemq.util.FactoryFinder.doFindFactoryProperies() correctly consults the current class's loader if Thread.currentThread().getContextClassLoader() is null:

        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        if (classLoader == null) classLoader = getClass().getClassLoader();

newInstance(), however, generates a null pointer exception if Thread.currentThread().getContextClassLoader() is null:

        Class clazz;
        try {
            clazz = Thread.currentThread().getContextClassLoader().loadClass(className);
        } catch (ClassNotFoundException e) {
            clazz = FactoryFinder.class.getClassLoader().loadClass(className);
        }",Bug
AMQ-1054,12481866,,"XAResource.recover seems to fail for 4.x of ActiveMQ:

ERROR IN RECOVERY [thread: SimpleAsyncTaskExecutor-3] on: 06-11-16 08:43:35,152 
[Lorg.apache.activemq.command.DataStructure; [thread: SimpleAsyncTaskExecutor-3] on: 06-11-16 08:43:35,152 
at: org.apache.activemq.TransactionContext.recover(TransactionContext.java:508) [thread: SimpleAsyncTaskExecutor-3] on: 06-11-16 08:43:35,152 
at: com.atomikos.datasource.xa.XATransactionalResource.recover(Unknown Source) [thread: SimpleAsyncTaskExecutor-3] on: 06-11-16 08:43:35,152 
at: com.atomikos.datasource.xa.XATransactionalResource.endRecovery(Unknown Source) [thread: SimpleAsyncTaskExecutor-3] on: 06-11-16 08:43:35,152 
at: com.atomikos.icatch.imp.TransactionServiceImp.recover(Unknown Source) [thread: SimpleAsyncTaskExecutor-3] on: 06-11-16 08:43:35,153 
at: com.atomikos.datasource.xa.XATransactionalResource.setRecoveryService(Unknown Source) [thread: SimpleAsyncTaskExecutor-3] on: 06-11-16 08:43:35,153 
at: com.atomikos.icatch.system.Configuration.addResource(Unknown Source) [thread: SimpleAsyncTaskExecutor-3] on: 06-11-16 08:43:35,153 
at: com.atomikos.jms.QueueConnectionFactoryBean.checkSetup(Unknown Source) [thread: SimpleAsyncTaskExecutor-3] on: 06-11-16 08:43:35,153 
at: com.atomikos.jms.QueueConnectionFactoryBean.createQueueConnection(Unknown Source) [thread: SimpleAsyncTaskExecutor-3] on: 06-11-16 08:43:35,153 
at: com.atomikos.jms.QueueConnectionFactoryBean.createConnection(Unknown Source) [thread: SimpleAsyncTaskExecutor-3] on: 06-11-16 08:43:35,153 

Also see http://www.atomikos-support.com/forums/viewtopic.php?t=351 (where I borrowed this stack trace from). We have seen similar things in other applications that tried to use ActiveMQ. I think this is a class cast error in ActiveMQ...

With 3.1 there is no problem. ",Bug
AMQ-1439,12482090,,"All occurrences  of connectedCount != minAckCount should be replaced with connectedCount < minAckCount.  The logic should proceed once the minimum number of acks have been achieved.

see http://www.nabble.com/FanoutTransport-Patches-tf4562939s2354.html",Bug
AMQ-1132,12483319,,"When you include activemq-core as a dependency on an empty project, even simplest examples fails with

java.io.FileNotFoundException: /target/test.log (No such file or directory)

exception.

First of all, the core package includes dependency on activeio-core test jar 

    <dependency>
      <groupId>${pom.groupId}</groupId>
      <artifactId>activeio-core</artifactId>
      <optional>false</optional>
      <type>test-jar</type>
    </dependency>

for which I'm not sure is needed.
Second, in this test activeio package logging.properties is configured so that root logger writes into ${basedir}/target/test.log, which causes application to fail. It would be better to set it to write to stdout by default.
",Bug
AMQ-822,12481777,,"UdpTransportFactory contains commented out code that contain symbol that eclipse cannot handle. The following fix was sufficient for code to be compiled without problem:

fateev@fateev:/workplace/fateev/activemq/trunk> svn diff activemq-core/src/main/java/org/apache/activemq/transport/udp/UdpTransportFactory.java
Index: activemq-core/src/main/java/org/apache/activemq/transport/udp/UdpTransportFactory.java
===================================================================
--- activemq-core/src/main/java/org/apache/activemq/transport/udp/UdpTransportFactory.java      (revision 421719)
+++ activemq-core/src/main/java/org/apache/activemq/transport/udp/UdpTransportFactory.java      (working copy)
@@ -161,7 +161,7 @@
          * switch to the target endpoint // based on the last packet that was
          * received // so that all future requests go to the newly created UDP
          * channel Endpoint from = info.getFrom();
-         * System.out.println(""####&#65533;setting the client side target to: "" +
+         * System.out.println(""####setting the client side target to: "" +
          * from); udpTransport.setTargetEndpoint(from); } }; return transport;
          */
     }
fateev@fateev:/workplace/fateev/activemq/trunk>
",Bug
AMQ-126,12481306,,"I'm not seeing how to specify the maximumRetries property, relating to a networkChannel, if I use zeroconf discovery agent.  It looks like the broker dynamically creates a networkChannel once it finds another broker via the zeroconf agent.  The maximumRetries property only applies to the networkChannel which, if specified, must have a URI given as well.  That seems to defeat the purpose of zeroconf.

How can I override the default maximumRetries when using zeroconf?",Bug
AMQ-118,12481221,,"Doing some testing last week, it seemed like the TransientQueueBoundedMessageContainer was dropping messages that did not have an intrested consumer. 

If there was an active consumer, the messages would get delivered, to the consumer.  If the messages were sent to the destination before the consumer was created, the messages would not get delivered to the consumer.",Bug
AMQ-151,12481131,,The requestMap in TransportChannelSupport isn't syncrhonized which in some cases can lead to indefinite freezes when sending packets syncrhonously. This is most likely to occur while using VMTransport.,Bug
AMQ-187,12481130,,"Due to a Problem with Version 1.5 (see other Commit) we tried using Version 2.0. Using Version 2.0 we permanently get an ""failed to build body from bytes"" Error. 

As fas as we analyzed, this normally seems to happen if there is a serilalisation/deserialisation Problem .. but in this Case the Broker, the ""Client"" and the ""Server"" are using all the Same machine/jdk/classes. 

We are simply ""transporting"" an Array of Tile-Requests as the Body of an ObjectMessage (see the Class below). In the Error-Case it seems that the Object-Body of the Message itself is being lost. 
The Message sent by the Client still contains the Object .. the Message received by the Server seems to have lost it's contents.

Any comments/ideas ??


8<-----------------8<----------------8<----------------8<----------
public class TileRequest implements Serializable {
  private Serializable segmentHandle;
  private RenderContext renderContext;
  private Rectangle tile;

public TileRequest(Serializable segmentHandle, RenderContext    
      renderContext, Rectangle tile) {
    this.segmentHandle = segmentHandle;
    this.renderContext = renderContext;
    this.tile = tile;
  }

  public RenderContext getRenderContext() {
    return renderContext;
  }

  public Serializable getSegmentHandle() {
    return segmentHandle;
  }

  public Rectangle getTileRectangle() {
    return tile;
  }
}",Bug
AMQ-188,12481183,,"We implemented a Communication-Protocol handling a Simple Client/Server Connection (using temp-queues) .. we are transporting image-tiles through this Queues. It seems that, if the images reacg a certain size (not specified at the moment) the whole Broker seems to block and does not accept any messages anymore .. therefore the client seems to block too .. 
Any ideas what this could cause ??",Bug
AMQ-208,12481232,,"When running an embedded broker in a Java app which acts as a message producer, I see (via JMX console for the whole app) that some activeMQ broker-related threads, dedicated to handling a TcpTransportChannel, remain alive whereas no client is connected to the broker.

As shown by the stack trace for these threads (see below) it seems that, after the remote client has disconnected, the thread is waiting to be notified by another object so that it can terminate. This issue does not happen every time a client disconnects.

Here is the waiting thread stack trace :

Name: Thread-11
State: WAITING on EDU.oswego.cs.dl.util.concurrent.PooledExecutor@f03c46
Total blocked: 162  Total waited: 10 152

Stack trace: 
java.lang.Object.wait(Native Method)
java.lang.Object.wait(Object.java:474)
EDU.oswego.cs.dl.util.concurrent.PooledExecutor.awaitTerminationAfterShutdown(Unknown Source)
org.codehaus.activemq.util.ExecutorHelper.stopExecutor(ExecutorHelper.java:50)
org.codehaus.activemq.transport.TransportChannelSupport.stopExecutor(TransportChannelSupport.java:472)
org.codehaus.activemq.transport.tcp.TcpTransportChannel.stop(TcpTransportChannel.java:196)
org.codehaus.activemq.broker.impl.BrokerClientImpl.close(BrokerClientImpl.java:658)
org.codehaus.activemq.broker.impl.BrokerClientImpl.onException(BrokerClientImpl.java:134)
org.codehaus.activemq.transport.TransportChannelSupport.onAsyncException(TransportChannelSupport.java:430)
org.codehaus.activemq.transport.tcp.TcpTransportChannel.doAsyncSend(TcpTransportChannel.java:438)
org.codehaus.activemq.transport.tcp.TcpTransportChannel$1.run(TcpTransportChannel.java:233)
EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(Unknown Source)
java.lang.Thread.run(Thread.java:595)

",Bug
AMQ-210,12481098,,"Steps to reproduce:

2 instances of tomcat 5.0.30, jdk 1.4.2, call it tomcat1 and tomcat2
Each instance is running a webapp with the following config: brokerURL=""peer://someService"", embeddedBroker=(true or false, the behaviour is the same with either setting )

Kill tomcat1:    tomcat2's webapp detects the disconnect and successfully removes the client.
Restart tomcat1: tomcat2's webapp DOES NOT detect the reconnect of tomcat1's webapp or any other peer but continues to hear its own messages. In activemq2.0 it's unable to hear even its own messages.  

When there are at least 3 peers in a cluster this does not occur and peers seem to detect membership changes correctly.

If I am using the peer protocol incorrectly I would greatly appreciate if you let me know. All I am trying to have is 
a network of peers, each with an embedded broker to achieve transparent failover. Thanks a lot.

Igor Kaplansky",Bug
AMQ-189,12481090,,"Attempting to build by executing
> maven
in main project directory.

Receive the following...

==================================================================
==================================================================
ActiveMQ :: Assembly
+----------------------------------------
| Executing default ActiveMQ :: Integration Tests :: Ejb
| Memory: 6M/10M
+----------------------------------------
Attempting to download geronimo-spec-ejb-2.1-rc3.jar.
WARNING: Failed to download geronimo-spec-ejb-2.1-rc3.jar.

BUILD FAILED
File...... C:\Documents and Settings\bconlon\.maven\cache\maven-multiproject-plugin-1.3.1\plugin.jelly
Element... maven:reactor
Line...... 217
Column.... 9
The build cannot continue because of the following unsatisfied dependency:

geronimo-spec-ejb-2.1-rc3.jar; version override doesn't exist: 2.1-rc3

Total time: 22 seconds
Finished at: Mon Feb 07 11:35:18 CST 2005
==================================================================
==================================================================

This version of geronimo-spec-ejb isn't in ibiblio or in any obvious place on apache or codehaus.  If I remove the ""ejb"" module, the build
will fail as follows:

==================================================================
==================================================================
+----------------------------------------
| Executing default ActiveMQ :: Transport :: HTTP
| Memory: 10M/12M
+----------------------------------------
Attempting to download geronimo-spec-servlet-2.4-rc3.jar.
WARNING: Failed to download geronimo-spec-servlet-2.4-rc3.jar.
Attempting to download org.mortbay.jetty-5.1-SNAPSHOT.jar.

BUILD FAILED
File...... C:\Documents and Settings\bconlon\.maven\cache\maven-multiproject-plu
gin-1.3.1\plugin.jelly
Element... maven:reactor
Line...... 217
Column.... 9
The build cannot continue because of the following unsatisfied dependency:

geronimo-spec-servlet-2.4-rc3.jar; version override doesn't exist: 2.4-rc3

Total time: 42 seconds
Finished at: Mon Feb 07 11:44:28 CST 2005
==================================================================
==================================================================",Bug
AMQ-220,12481062,,"Please update JCAContainer to use ListableBeanFactory.getBeanNamesForType(Class) rather than blindly trying to instantiate every single bean in the context.

http://svn.activemq.org/trunk/activemq/modules/container/src/java/org/activemq/jca/JCAContainer.java?rev=1&view=auto


    [junit] Error creating bean with name 'abstractInboxCommand': Bean definition is abstract
    [junit] org.springframework.beans.factory.BeanIsAbstractException: Error creating bean with name
 'abstractInboxCommand': Bean definition is abstract
    [junit]     at org.springframework.beans.factory.support.AbstractBeanFactory.checkMergedBeanDefinition(AbstractBeanFactory.java:653)
    [junit]     at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:208)
    [junit]     at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:145)
    [junit]     at org.codehaus.activemq.jca.JCAContainer.afterPropertiesSet(JCAContainer.java:77)
    [junit]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1065)
    [junit]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:343)
    [junit]     at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:260)",Bug
AMQ-191,12481385,,"I have the following configuration
- 1 Producer (P)
- 1 Consumer (C)
- 1 Broker
- ActiveMQ 2.0
- DerbyDB Persistence

======================
With reliable protocol:
  P ----> sends 20000 messages ------> AMQ ----> Sends  1331 Messages  ----> C

  After the test I browsing the persistence with ij tool and don't see any messages!!!!

>java -Dderby.system.home=/export/home/jms/activemq/var -Dij.connection.derbydb=jdbc:derby:derbydb org.apache.derby.tools.ij
        ij version 10.0 (C) Copyright IBM Corp. 1997, 2004.
        DERBYDB* -      jdbc:derby:derbydb
        * = current connection
        ij> select container,COUNT(*) as quantity  from ACTIVEMQ_MSGS group by container;
        CONTAINER  |QUANTITY
        ------------------------------------
        0 rows selected
        ij> select * from  activemq_msgs;
        ID|CONTAINER |MSGID |MSG
        ------------------------------------
        0 rows selected

======================
Without reliable protocol
  P-->Sends 20000 messages-->AMQ-->Sends 20000 Messages--> C

the details logs from ActiveMQ 2.0, Consumer  and Producer are in http://www.gps.cl/logs.zip (133Kb)",Bug
AMQ-222,12481122,,"My application seems to be triggering a memory leak in the broker when using the Derby store under load with 2.1. I haven't been able to reproduce the condition, but here's a quick breakdown of how I'm using the broker:
- A single queue that passes large ObjectMessages from 11 writers to a single reader
- A topic that messages small ObjectMessages to 11 readers from a single writer

The message frequency is about 1 per second max, with normal rates being about 2 per minute (very low). I'm using the default derby store, with two connectors listening on two different interfaces. The clients all have a manual reconnect if they get a JMS exception, closing and re-opening the connection to the broker.

After about a week of production runtime, the broker seems to start generating OutOfMemoryErrors. It seems to keep accepting TCP connections when in this state, but the clients that connect to it hang during the connect. ",Bug
AMQ-209,12481030,,"Hello,

Use the configuration activemq.xml and jndi.properties attached in the test.zip file.

Compile the sources (package protojms).

Start the IMEISubscriber.
Start the IMEIPublisher.
Kill the IMEISubscriber then kill the IMEIPublisher.
Restart the IMEISubscriber: you will see that some of the persistent message have not been received by this durable subscriber !

Bug in activeMQ or in my program ? 

I have tested this within JORAM : no pb!


I have other questions:
   1) For persistence performance what is recommended ? (BerkeleyDB, ....)
   2) In order to use BerkeleyDB what are the optional jars that I have to put in the 
      classpath ?
   3) Using Joram it is not manadatory to set the clientID, I have read the spec but nothing 
      has been said regarding this API. Could you give me some explanations regarding this 
      API ?
",Bug
AMQ-227,12481017,,"ActiveMQ clients that ActiveMQ have the same client id, that is ""clientid"". This makes ActiveMQ complain about it.
Client is only using queues.
",Bug
AMQ-225,12481111,,"Hi Ben,

That's our db auto detection code not working right.  Seems like you  
oracle driver is reporting Oracle_JDBC_driver as the type of driver.   
But we were expecting to get Oracle_JDBC_Driver (case is different).
Since auto detection is not working for you (I'll work on getting this  
right for the next release), you should change the persistence config  
so it looks like:

 <persistence>
       <cachePersistence>
         <journalPersistence directory=""../var/journal/"">
           <jdbcPersistence dataSourceRef=""oracle-ds""   adapterClass=""org.codehaus.activemq.store.jdbc.adapter.OracleJDBCAdapter""/>
         </journalPersistence>
       </cachePersistence>
     </persistence>

Regards,
Hiram

On Mar 16, 2005, at 10:40 AM, Ben.Temperton@... wrote:

> Hi,
>
> I'm trying to set up active MQ to persist its message store in an  
> oracle
> database.
> I've added the following to my activemq.xml file:
>
> <bean id=""oracle-ds"" class=""org.apache.commons.dbcp.BasicDataSource""
> destroy-method=""close"">
>     <property name=""driverClassName"">
>       <value>oracle.jdbc.driver.OracleDriver</value>
>     </property>
>     <property name=""url"">
>       <value>jdbc:oracle:thin: <at> myserver:1521:mydb</value>
>     </property>
>     <property name=""username"">
>       <value>activemq</value>
>     </property>
>     <property name=""password"">
>       <value>activemq</value>
>     </property>
>     <property name=""poolPreparedStatements"">
>       <value>true</value>
>     </property>
>   </bean>
>
> and to my <broker> tag I have added the following:
>
> <persistence>
>       <cachePersistence>
>         <journalPersistence directory=""../var/journal/"">
>           <jdbcPersistence dataSourceRef=""oracle-ds""/>
>         </journalPersistence>
>       </cachePersistence>
>     </persistence>
>
>
> When I start up activeMQ using ""activemq.bat"", ActiveMQ creates the  
> tables
> required in mydb. However, in full debug mode, it throws the following
> warning:
>
> 15:34:28 WARN  Unrecognized database type (Oracle_JDBC_driver).  Will  
> use
> default JDBC implementation.
> 15:34:28 DEBUG Reason: java.io.IOException: Could not find class for
> resource: META-INF/services/org
> /codehaus/activemq/store/jdbc/Oracle_JDBC_driver
> java.io.IOException: Could not find class for resource:
> META-INF/services/org/codehaus/activemq/store/jdbc/Oracle_JDBC_driver
>         at
> org.codehaus.activemq.util.FactoryFinder.doFindClass(FactoryFinder.java 
> :76)
",Bug
AMQ-207,12483911,,"The logic in CompositeTransportChannel.establishConnection appears incorrcet.

...
                if (incrementTimeout && time < maximumTimeout) {
                    time *= 2;
                    time = time > maximumTimeout ? maximumTimeout : timeout;
                }
...

should be:

...
                if (incrementTimeout && time < maximumTimeout) {
                    time *= 2;
                    time = time > maximumTimeout ? maximumTimeout : time;
                }

Otherwise if zeroconfig fails to get a connection, the sleep time is approx. 30s.
",Bug
AMQ-214,12481254,,"Our 

        protected Class resolveClass(ObjectStreamClass v) throws ClassNotFoundException{
            ClassLoader cl = Thread.currentThread().getContextClassLoader();
            try {
                if (cl != null){
                    return cl.loadClass(v.getName());
                } else {
                    return Class.forName(v.getName());
                }
            } catch ( ClassNotFoundException e ) {
                return ACTIVEMQ_CLASSLOADER.loadClass(v.getName());
            }
        }

The Serilaization helper class does not handle loading class arrays.  The class name will be something like ""[java.lang.String"" but cl.loadClass does not handle classes in that format.",Bug
AMQ-223,12481059,,"We are having OutOfMemoryErrors in the broker.  Its configured for vmPersistence, messages have 60 second TTL.  I have checked Queues using Hermes (what a bitch that is to setup with ActiveMQ) and they are empty as expected.  We are using RPC style messaging, with TemporaryQueues for responses, if that helps at all.

The broker can run for a week before running out of memory, but it is related to how many connections are made.  We run 2-3 batch processes each morning that create a few thousand Connections.  Our broker continually grows, even when all consumers and producers are shutdown.

Profiling with YourKit shows the 63% of the broker memory (after GC) is held by 3292 instances of TcpTransportChannel, held by TcpTransportServerChannel.  Note, as mentioned above there are no active connections, so this doesn't appear to be a bug in our code.

This is possibly related to AMQ-125 (fixed 1.2), and AMQ-222.  It seems to be the same problem as mentioned by Charles Anthony ""Possible Memory Leak ?"" on activemq-user.  I could not find any update on that thread.

We will workaround this, by holding connections in a ThreadLocal, since there are only a few threads in a few daily processes.  But regardless, we can expect this growth to continue albeit a much slower pace.",Bug
AMQ-216,12481179,,"> cd activemq-release-2.1
> maven
[...]
    [echo] Building EAR activemq-itest-ear-2.1 with appxml ""/uyn0/andrew/nsa/messaging-system/activemq/activemq-release-2.1/itests/ear/target/application.xml""

BUILD FAILED
File...... /user/andrew/.maven/cache/maven-multiproject-plugin-1.3.1/plugin.jelly
Element... maven:reactor
Line...... 217
Column.... 9
Unable to obtain goal [ear:ear] -- /user/andrew/.maven/cache/maven-ear-plugin-1.6/plugin.jelly:99:24: <ant:fail> Case-sensitive issue: The dependency activemq:activemq-itest-ejb has a case problem.  The dependency was either retrieved in the past with the wrong case or has been specified with the wrong case in your project.xml file.  Fix your project.xml or update your local repository with the properly-cased file and try again.
Total time: 23 minutes 56 seconds
",Bug
AMQ-313,12481297,,"While looking for another problem I pulled a Full Thread dump on the broker.  I found several dozen threads
with the following stack trace and they look very troublesome to me. If an error occurs on an async send, 
due to a broken client connection, the close is failing in such a manner as to lock up the pooled thread.

This looks to me like there could be some sort of bug in the concurrent-1.3.4.jar library code.  
""Thread-292"" daemon prio=1 tid=0x085b6008 nid=0x6663 in Object.wait() [5cd59000..5cd59cd8]
        at java.lang.Object.wait(Native Method)
        - waiting on <0x47eb41c0> (a EDU.oswego.cs.dl.util.concurrent.PooledExecutor)
        at java.lang.Object.wait(Object.java:429)
        at EDU.oswego.cs.dl.util.concurrent.PooledExecutor.awaitTerminationAfterShutdown(Unknown Source)
        - locked <0x47eb41c0> (a EDU.oswego.cs.dl.util.concurrent.PooledExecutor)
        at org.activemq.util.ExecutorHelper.stopExecutor(ExecutorHelper.java:50)
        at org.activemq.transport.TransportChannelSupport.stopExecutor(TransportChannelSupport.java:487)
        at org.activemq.transport.tcp.TcpTransportChannel.stop(TcpTransportChannel.java:218)
        at org.activemq.broker.impl.BrokerClientImpl.close(BrokerClientImpl.java:694)
        at org.activemq.broker.impl.BrokerClientImpl.onException(BrokerClientImpl.java:137)
        at org.activemq.transport.TransportChannelSupport.onAsyncException(TransportChannelSupport.java:445)
        at org.activemq.transport.tcp.TcpTransportChannel.doAsyncSend(TcpTransportChannel.java:489)
        at org.activemq.transport.tcp.TcpTransportChannel$1.run(TcpTransportChannel.java:261)
        at EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(Unknown Source)
        at java.lang.Thread.run(Thread.java:534)
 
",Bug
AMQ-261,12481295,,Cook reported that we have broker the wire Format.,Bug
AMQ-310,12481142,,"This may or may not be a bug.  I can not get a clear determination from the JMS specification, but from experience with a couple of other JMS products, I was suprized to find that destination names are case sensitive.  

myqueue != MYQUEUE

Can anyone comment on the intended policy for ActiveMQ.",Bug
AMQ-239,12481325,,"The ssl file in the META-INF directory doesn't exist in the 3.0 binary release jar file.  Simple example that uses SSL barfs:

javax.jms.JMSException: Could not load protocol: ssl. Reason: java.io.IOException: Could not find class for resource: META-INF/services/org/activemq/transport/server/ssl
	at org.activemq.transport.TransportServerChannelProvider.createJMSexception(TransportServerChannelProvider.java:85)
	at org.activemq.transport.TransportServerChannelProvider.getFactory(TransportServerChannelProvider.java:76)
	at org.activemq.transport.TransportServerChannelProvider.create(TransportServerChannelProvider.java:45)
	at org.activemq.broker.impl.BrokerConnectorImpl.createTransportServerChannel(BrokerConnectorImpl.java:415)
	at org.activemq.broker.impl.BrokerConnectorImpl.<init>(BrokerConnectorImpl.java:69)
	at org.activemq.broker.impl.BrokerContainerImpl.addConnector(BrokerContainerImpl.java:616)
	at org.activemq.broker.impl.BrokerContainerImpl.addConnector(BrokerContainerImpl.java:612)

",Bug
AMQ-325,12481429,,"Mark Lewis <mark.lewis at mir3.com> reported:

After running more or less without any problems for a couple of days, I
suddenly got this message on one of the brokers in my network as it
processed a moderately large (1-2MB) message.  After receiving this
message it appears to have broken the network connection without trying
to restart, even though I specified reliable: protocol for the network
channel. 

09:10:51 WARN  Async exception with no exception listener:
javax.jms.JMSException: Could not find parts for fragemented message:
ACTIVEMQ_TEXT_MESSAGE: id = 0 ActiveMQMessage{ , jmsMessageID = ID:r2-
d2-40063-1124130867102-118:0, bodyAsBytes =
org.activemq.io.util.ByteArray@aa098a, readOnlyMessage = true,
jmsClientID = 'qa_tahoe' , jmsCorrelationID = 'null' , jmsDestination =
qa_tahoe_data, jmsReplyTo = null, jmsDeliveryMode = 2, jmsRedelivered =
false, jmsType = 'null' , jmsExpiration = 0, jmsPriority = 4,
jmsTimestamp = 1124205464502, properties = null, readOnlyProperties =
true, entryBrokerName = 'ID:yoda-34917-1123719371107-0:0' ,
entryClusterName = 'default' , consumerNos = [0], transactionId =
'null' , xaTransacted = false, consumerIdentifer =
'ID:yoda-34923-1123719372923-0:0_NetworkChannel.14.14' , messageConsumed
= true, transientConsumed = false, sequenceNumber = 0, deliveryCount =
1, dispatchedFromDLQ = false, messageAcknowledge =
org.activemq.ActiveMQSession@1584a8b, jmsMessageIdentity = null,
producerKey = ID:r2-d2-40063-1124130867102-118: }, text = fragmented
message
javax.jms.JMSException: Could not find parts for fragemented message:
ACTIVEMQ_TEXT_MESSAGE: id = 0 ActiveMQMessage{ , jmsMessageID = ID:r2-
d2-40063-1124130867102-118:0, bodyAsBytes =
org.activemq.io.util.ByteArray@aa098a, readOnlyMessage = true,
jmsClientID = 'qa_tahoe' , jmsCorrelationID = 'null' , jmsDestination =
qa_tahoe_data, jmsReplyTo = null, jmsDeliveryMode = 2, jmsRedelivered =
false, jmsType = 'null' , jmsExpiration = 0, jmsPriority = 4,
jmsTimestamp = 1124205464502, properties = null, readOnlyProperties =
true, entryBrokerName = 'ID:yoda-34917-1123719371107-0:0' ,
entryClusterName = 'default' , consumerNos = [0], transactionId =
'null' , xaTransacted = false, consumerIdentifer =
'ID:yoda-34923-1123719372923-0:0_NetworkChannel.14.14' , messageConsumed
= true, transientConsumed = false, sequenceNumber = 0, deliveryCount =
1, dispatchedFromDLQ = false, messageAcknowledge =
org.activemq.ActiveMQSession@1584a8b, jmsMessageIdentity = null,
producerKey = ID:r2-d2-40063-1124130867102-118: }, text = fragmented
message
        at org.activemq.ActiveMQSession.sendMessageAck
(ActiveMQSession.java:1159)
        at org.activemq.ActiveMQSession.doAcknowledge
(ActiveMQSession.java:1092)        at
org.activemq.ActiveMQSession.acknowledge(ActiveMQSession.java:1082)
        at org.activemq.message.ActiveMQMessage.acknowledge
(ActiveMQMessage.java:1956)
        at org.activemq.transport.NetworkMessageBridge.onMessage
(NetworkMessageBridge.java:217)
        at org.activemq.ActiveMQMessageConsumer.processMessage
(ActiveMQMessageConsumer.java:447)
        at org.activemq.ActiveMQSessionExecutor.dispatch
(ActiveMQSessionExecutor.java:110)
        at org.activemq.ActiveMQSessionExecutor.run
(ActiveMQSessionExecutor.java:95)
        at java.lang.Thread.run(Thread.java:534)
09:10:51 INFO  channel status changed: Channel: tcp://localhost:61617
has stopped

",Bug
AMQ-230,12481066,,"This will either prove to be an incorrect assumption on my part, or a bug.  

Normally the reliable protocol is used to fail-over to a different broker if the 1st connected to broker dies.  However if one sets up a client connection using the reliable protocol to a one-and-only external/standalone broker that is alive, then dead, then alive, the reliable protocol does not reconnect to it.

This issue may be directly related to AMQ-211 which is marked as fixed, but this test case still fails for me.

The really interesting part is line 105 of my test case, that tries to send the 2nd message.  This line actually succeeds, but NOTHING actually happens.  By tracing through, I eventually get to ActiveMQSession, line 1458, where it calls asyncSendPacket(msg). Inside this method, it checks the isTransportOK property (which is false at this point), then does NOTHING, and returns.  

It is a silent failure.

Steps to Reproduce:

1. Using the 20050407 3.0 snapshot distribution, startup a standalone broker process using the below configuration file:

<?xml version=""1.0"" encoding=""UTF-8""?>
<!DOCTYPE beans PUBLIC  ""-//ACTIVEMQ//DTD//EN"" ""http://activemq.org/dtd/activemq.dtd"">
<beans>

  <broker>
    <connector>
      <tcpServerTransport uri=""tcp://localhost:61616""/>
    </connector>
<!--
    <discoveryAgent>
      <zeroconfDiscovery type=""_activemq.broker.development.""/>
    </discoveryAgent>

    <discoveryNetworkConnector/>
-->

    <persistence>
      <cachePersistence>
        <journalPersistence directory=""../var/journal"">
          <jdbcPersistence dataSourceRef=""derby-ds""/>
        </journalPersistence>
      </cachePersistence>
    </persistence>
  </broker>

  <!-- ==================================================================== -->
  <!-- JDBC DataSource Configurations -->
  <!-- ==================================================================== -->

  <!-- The Derby Datasource that will be used by the Broker -->
  <bean id=""derby-ds"" class=""org.apache.commons.dbcp.BasicDataSource"" destroy-method=""close"">
    <property name=""driverClassName"">
      <value>org.apache.derby.jdbc.EmbeddedDriver</value>
    </property>
    <property name=""url"">
      <!-- Use a URL like 'jdbc:hsqldb:hsql://localhost:9001' if you want to connect to a remote hsqldb -->
      <value>jdbc:derby:derbydb;create=true</value>
    </property>
    <property name=""username"">
      <value></value>
    </property>
    <property name=""password"">
      <value></value>
    </property>
    <property name=""poolPreparedStatements"">
      <value>true</value>
    </property>
  </bean>
</beans>

2. Run the attached unit test case, stopping & starting the external broker as requested in the log4j output to the console.  This unit test will wait for start/stop, but you'll have to trigger that manually.  I did not wish to try a fully automated test case because that did not represent the use-case we are trying to achieve.

",Bug
AMQ-324,12481060,,"When adding a new consumer to a queue, the DurableQueueBoundedMessageManager will try to create the queue container and start it if it hasn´t been created yet. The container startup process tries to recover messages from persistent storage into the MemoryBoundedQueue associated with the destination. If the MemoryBoundedQueue becomes full during the recorvery, a deadlock situation is reached: the enqueue method of MemoryBoundedQueue will keep waiting until a message is consumed so it can add a new message, but no messages will be consumed because the message consumer has not yet been added to the destination.
",Bug
AMQ-228,12481074,,"The .classpath file for the core module contains a classpath entry for <ACTIVEMQ_HOME>/src/class (absolute path), whereas the correct path would be <ACTIVEMQ_HOME>/modules/core/src/conf (absolute path) or just src/conf (rel. path).

The fix is as easy as adding ${basedir} in /modules/core/project.properties line 10:
maven.eclipse.classpath.include=${basedir}/src/conf",Bug
AMQ-238,12481068,,"We are using a Requestor for JMS RPC using a temporary queue.

We have a small number of clients, but each client potentially makes thousands of requests, and each request creates its own temporary queue.

We were seeing memory growth in 2.1 related to connections, this seems to be fixed in 3.0.

However, we now see memory growth in a different place.  YourKit shows 70% of the 240mb (currently) memory used, is in o.a.service.boundedvm.TransientQueueBoundedMessageManager.destinationMap (1 million objects), there are around 10,000 objects in TransientQueueBoundedMessageManager.destinations and TransientQueueBoundedMessageManager.containers.

We are opening and closing a connection for each Requestor, so the temporary queue, should be closing, and there is also a queue.delete() as in o.a.bean.Requestor.

If you want a YourKit snapshot, let me know, and I'll attach one.

We are looking at using a single topic with selectors as a workaround, but that complicates the logic, in order not to miss the response, before you start listening.  i.e. another thread is required.",Bug
AMQ-236,12481173,,"09:35:36 WARN  caught exception consuming packet: CONSUMER_INFO: id = 375 ConsumerInfo{ browser = false, destination = ActiveMQ.Advisory.TempDestinations.TemporaryQueue-{TD{ID:cyclops-4948-1113347143177-1284:0}TD}ID:cyclops-4948-1113347143177-1475:0, consumerIdentifier = 'ID:cyclops-4790-1113348862947-9:0.48.48' , clientId = 'ID:cyclops-4790-1113348862947-9:0' , sessionId = '48' , consumerName = '' , selector = '' , startTime = 1113348936040, started = true, consumerNo = 48, noLocal = false, prefetchNumber = 10, consumerKey = '[ID:cyclops-4790-1113348862947-9:0:]' }

java.util.ConcurrentModificationException
        at java.util.HashMap$HashIterator.nextEntry(Unknown Source)
        at java.util.HashMap$KeyIterator.next(Unknown Source)
        at org.activemq.broker.impl.AdvisorySupport.addAdvisory(AdvisorySupport.java:88)
        at org.activemq.broker.impl.DefaultBroker.addMessageConsumer(DefaultBroker.java:251)
        at org.activemq.broker.impl.BrokerContainerImpl.registerMessageConsumer(BrokerContainerImpl.java:355)
        at org.activemq.broker.impl.BrokerConnectorImpl.registerMessageConsumer(BrokerConnectorImpl.java:170)
        at org.activemq.broker.impl.BrokerClientImpl.consumeConsumerInfo(BrokerClientImpl.java:466)
        at org.activemq.broker.impl.BrokerClientImpl.consume(BrokerClientImpl.java:327)
        at org.activemq.transport.TransportChannelSupport.doConsumePacket(TransportChannelSupport.java:374)
        at org.activemq.transport.TransportChannelSupport.doConsumePacket(TransportChannelSupport.java:368)
        at org.activemq.transport.tcp.TcpTransportChannel.run(TcpTransportChannel.java:310)
        at java.lang.Thread.run(Unknown Source)",Bug
AMQ-262,12481341,,"I have been testing version 266 and found that request/reply test is not working at a 100% level across networked brokers.  At first I thought that the race condition that had been a prior release had be revived. This was where replier would try to use the temp destination before the bridge was established.  Before that was fixed I could just insert a delay after creating the temp destination and its use to get around the problem.  Now it seems that work-around does not work either.  The first attempt to send a message to the temp destination will fail.

I have found that repeated attempts will succeed.  It seems that the first failed attempt is trigger a completion of the temp definition setup?  Anyway if after the first request fails to receive the reply, another request is made, the replying process has no problem sending the second reply.

Could this be another problem introduced as a result of the AdvisorySupport changes? ",Bug
AMQ-265,12481233,,"Currently this event is fired from the TcpTransportChannel.initalizeStreams().  Since this method is called from the constructor before any listener could be registered, the event is never heard.  This even should be fired from the start() method.  ",Bug
AMQ-597,12481559,,"If you put two messages in the MemoryBoundedMessageCache with the same message id, the MemoryBoundedMessageCache puts itself into an inconsistent state, which causes a NullPointerException in removeOldest(), on the following line:

      CacheNode node = (CacheNode) messages.remove(messageID);
      decrementMemoryUsed(node.message);

This is because there is no corresponding CacheNode entry for the given messageID.

The problem is caused by the following block of code, in put(String, ActiveMQMessage):

            CacheNode oldNode = (CacheNode) messages.put(messageID, newNode);
            if( oldNode !=null ) {
                lruList.remove(oldNode);
                decrementMemoryUsed(oldNode.message);
            }  

When it removes the existing CacheNode from the messages map, it fails to remove it from the lruList, causing its entry to be left in the lruList. This means that the lruList will now contain two entries for the same message id.  The first one to be removed will remove the only entry in the messages map, and will be fine, but the second one to be removed will cause a NullPointerException, since there is now no corresponding CacheNode in the messages map.

To fix all that needs to be done is change the line:

                lruList.remove(oldNode);

to be

                lruList.remove(oldNode.entry);

so that the entry is correctly removed from the lruList.",Bug
AMQ-317,12481040,12481060,"I've been writing some quick test benchmarks and ran across a race condition that causes the DurableQueueBoundedMessageManager.add/removeMessageConsumer to deadlock.  relavent parts of the stack trace:


""Thread-15"" daemon prio=5 tid=0x0053ff80 nid=0x19dfc00 waiting for monitor entry [f1010000..f1010ac0]
        at org.activemq.service.boundedvm.DurableQueueBoundedMessageContainer.removeConsumer(DurableQueueBoundedMessageContainer.java:152)
        - waiting to lock <0x4c9a7048> (a java.lang.Object)
        at org.activemq.service.boundedvm.DurableQueueBoundedMessageManager.removeMessageConsumer(DurableQueueBoundedMessageManager.java:265)
        - locked <0x4c999048> (a org.activemq.service.boundedvm.DurableQueueBoundedMessageManager)
        at org.activemq.broker.impl.DefaultBroker.removeMessageConsumer(DefaultBroker.java:265)
        at org.activemq.broker.impl.BrokerContainerImpl.deregisterMessageConsumer(BrokerContainerImpl.java:367)
        at org.activemq.broker.impl.BrokerConnectorImpl.deregisterMessageConsumer(BrokerConnectorImpl.java:182)
        at org.activemq.broker.impl.BrokerClientImpl.cleanUp(BrokerClientImpl.java:619)
        - locked <0x4caa47a8> (a org.activemq.broker.impl.BrokerClientImpl)
        at org.activemq.broker.impl.BrokerConnectorImpl.removeClient(BrokerConnectorImpl.java:327)
        at org.activemq.transport.TransportChannelSupport.stop(TransportChannelSupport.java:119)
        at org.activemq.transport.tcp.TcpTransportChannel.stop(TcpTransportChannel.java:215)
        at org.activemq.broker.impl.BrokerClientImpl.close(BrokerClientImpl.java:710)
        at org.activemq.broker.impl.BrokerClientImpl.onException(BrokerClientImpl.java:146)
        at org.activemq.transport.TransportChannelSupport.onAsyncException(TransportChannelSupport.java:445)
        at org.activemq.transport.tcp.TcpTransportChannel.doAsyncSend(TcpTransportChannel.java:480)
        at org.activemq.transport.tcp.TcpTransportChannel$1.run(TcpTransportChannel.java:258)
        at EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(Unknown Source)
        at java.lang.Thread.run(Thread.java:552)

""Durable Queue Worker"" daemon prio=6 tid=0x00526320 nid=0x19c8a00 in Object.wait() [f0f0e000..f0f0eac0]
        at java.lang.Object.wait(Native Method)
        at java.lang.Object.wait(Object.java:429)
        at EDU.oswego.cs.dl.util.concurrent.BoundedBuffer.put(Unknown Source)
        - locked <0x4caa46f8> (a java.lang.Object)
        at EDU.oswego.cs.dl.util.concurrent.PooledExecutor$WaitWhenBlocked.blockedAction(Unknown Source)
        at EDU.oswego.cs.dl.util.concurrent.PooledExecutor.execute(Unknown Source)
        at org.activemq.transport.tcp.TcpTransportChannel.asyncSend(TcpTransportChannel.java:254)
        at org.activemq.broker.impl.BrokerClientImpl.send(BrokerClientImpl.java:676)
        at org.activemq.broker.impl.BrokerClientImpl.dispatchToClient(BrokerClientImpl.java:221)
        at org.activemq.broker.impl.BrokerClientImpl.dispatch(BrokerClientImpl.java:166)
        at org.activemq.service.boundedvm.DurableQueueSubscription.doDispatch(DurableQueueSubscription.java:93)
        at org.activemq.service.boundedvm.DurableQueueBoundedMessageContainer.run(DurableQueueBoundedMessageContainer.java:326)
        - locked <0x4c9a7048> (a java.lang.Object)
        - locked <0x4c9a7050> (a java.lang.Object)
        at EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(Unknown Source)
        at java.lang.Thread.run(Thread.java:552)


subsequent attempts to addConsumers will also hang until the server broker is killed and restarted

the code that causes this to happen is as follows:

          final long[] received = new long[1];

        Connection connection = connectionFactory.createConnection();
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        Destination destination = new ActiveMQQueue(""testQueue"");
        MessageConsumer consumer = session.createConsumer(destination);
        consumer.setMessageListener(new MessageListener() {
            public void onMessage(Message message) {
                synchronized(received) {
                    received[0]++;
                }
            }
        });
        connection.start();

        final int total = 1000000;


        new Thread(new Runnable() {
            public void run() {
                for(int i=0;i<total;i++) {
                    template.convertAndSend(""testQueue"", ""test message"");
                }
            }
        }).start();

        long last = 0;
        long cur = 0;

        do {
            synchronized(received) {
                cur = received[0];
            }
            System.out.println(""received = "" + cur + "" diff = "" + (cur - last));
            last = cur;
            Thread.sleep(1000);
        } while(cur < total);


(the template object is just a normal spring JmsTemplate configured in the app context in the test client)

If I run the above code and stop/kill/interupt the process while its still sending messages the server broker will go into this deadlock about 1 out of every 3 tries in my test setup, otherwise it just spits out an IOException and removes the messageConsumer just fine

",Bug
AMQ-399,12481423,,"
javax.jms.JMSException: Failed to build body from bytes. Reason: java.io.EOFException: Unexpected end of ZLIB input stream
        at org.activemq.message.ActiveMQObjectMessage.createFailedToBuildBodyException(ActiveMQObjectMessage.java:232)
        at org.activemq.message.ActiveMQObjectMessage.getObject(ActiveMQObjectMessage.java:164)
        at com.hb.jms.api.util.JmsSessionWrapper.handleMessage(JmsSessionWrapper.java:342)
        at com.hb.jms.api.util.JmsSessionWrapper.driveWrapperInner(JmsSessionWrapper.java:511)
        at com.hb.jms.api.util.JmsSessionWrapper$InnerRunner.run(JmsSessionWrapper.java:619)
        at java.lang.Thread.run(Thread.java:595)",Bug
AMQ-387,12481420,,"DeadLetterPolicy.java method getDeadLetterNameFromDestination(ActiveMQDestination destination)

has member variable String deadLetterName that mirrors an instance variable of the same name, private String deadLetterName = DEFAULT_DEAD_LETTER_NAME;

This results in incorrect dlq naming.",Bug
AMQ-338,12481048,,"Rudolf Holler reported that he has problems consuming fragmented messages using the jca connector.  I think he correctly summerized that ""Perhapbs if the message parts are send with different threads to the MDBean, my MDBean is not able to receive all parts and put it together to one message.""",Bug
AMQ-366,12481483,,"This code crashes broker sooner or later regardless of the memory given to the broker. Broker run with 1Mb of heap crashes after ~2850 attempts (processed in several seconds only).

        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(""tcp://192.168.0.2:62002"");
        QueueConnection connection = connectionFactory.createQueueConnection();
        connection.start();
        QueueSession session = connection.createQueueSession(true, Session.AUTO_ACKNOWLEDGE);
        int n = 1;
        while (true) {
            System.out.println(""attempt "" + n++);
            TemporaryQueue temporaryQueue = session.createTemporaryQueue();
            temporaryQueue.delete();
        }

",Bug
AMQ-357,12481362,,"I have developped a little application. It's goal is to send and recieve message on a queue.
I use an EJBStateful deploy on WebSphere.
I have configure an QueueConnectionFactory on WAS Ressource Adapter.

I have two services on the EJB :
                       open (Queue) where 
                                            I retrieve QueueConnectionFactory with JNDI Look up :

InitialContext ictx = new InitialContext();
qFactory =(QueueConnectionFactory) ictx.lookup(CONNECTION_JNDI_QUEUE);


                                            I create Connection, Session, Destination and producer:

	try {
				staticQueueConnection = qFactory.createConnection();
				staticQueueConnection.start();
				staticQueueSession = staticQueueConnection.createSession(transacted, ackMode);
				if (staticQueueSession!=null)
				{
					staticQueueDestination = staticQueueSession.createQueue(queueName);
					log.info(""Created destination: "" + staticQueueDestination);
				
					staticQueueProducer = staticQueueSession.createProducer(staticQueueDestination);
					log.info(""Created producer: "" + staticQueueProducer);
					
					
				}
			} catch (JMSException e1) {
				
				throw new NotificationException(e1.toString());
			}

                        publish(MEssage)  where 
                                            I just send message on queue:

messages = staticQueueSession.createTextMessage(notification.getText());
staticQueueProducer.send(messages);




I stock the producer on the session.

So my application do :
              Call open() so we can see on ActiveMQ log that a connection is created with a client but just after this exécution the client is removed!!!
             So when applicatiion call publish() I have the message ""Connection is closed"" adn publish failed.

I meet this problem only if I retrieve the QueueConnectionFactory on WebSphere if I create directly on classe the QueueConnectionFactory I don't met any probleme, every thing work:

	aFactory = new ActiveMQConnectionFactory();
	aFactory.setBrokerURL(URL_BROKER);
  
So If you have an idea it will be great...
",Bug
AMQ-393,12481474,,"When a PooledConnectionFactory is stopped, ObjectPools created by the SessionPools aren't closed, and therefore PooledSessions remain running.  Since the underlying ActiveMQSession isn't actually closed when the PooledSession is closed, the ActiveMQSessionExecutor and its worker threads are never stopped.  I added a method to PooledConnection called ""destroyPools"" which will close the ObjectPools associated with a connection.  The differences are pasted below.

diff oldpool/PooledConnection.java pool/PooledConnection.java
21a22
> import java.util.Iterator;
154a156,163
>     protected void destroyPools() {
>         Iterator i = cache.values().iterator();
>         while (i.hasNext()) {
>             SessionPool pool = (SessionPool) i.next();
>             i.remove();
>             pool.close();
>         }
>     }
diff oldpool/PooledConnectionFactory.java pool/PooledConnectionFactory.java
95a96
>             connection.destroyPools();
diff oldpool/SessionPool.java pool/SessionPool.java
98c98,104
<
---
>     protected void close() {
>         if (sessionPool != null) {
>             try {
>                 sessionPool.close();
>             } catch (Exception e) {}
>         }
>     }",Bug
AMQ-405,12481596,,"When using the peer:// protocol with the resource adapter, each activated endpoint creates an embedded broker, which leads to a lot of traffic and thread used. Maybe only one broker could be used for a connection factory, instead of one broker per connection.

For temporary queues, each temporary destination creates a thread for advisory that is never stopped, so that the jvm quickly runs out of memory.",Bug
AMQ-408,12481555,,"*configure the broker to have one persistence that is a datasource which is pointing to mysql.
*do not put in the journal persistence.
*making a 500 connections and kill the client VM.
*continue the above step and you will see activemq build up memory.",Bug
AMQ-402,12481528,,"I am waiting for one hour to recive message,but can't recive message.

How to set journal size in conf file?",Bug
AMQ-344,12481534,,"ManagedConnectionFactoryTest fails. The test was run on a Dell Inspiron 8600 with Windows XP:

Testcase: testConnectionFactoryConnectionMatching(org.activemq.ra.ManagedConnectionFactoryTest): Caused an ERROR
Journal is closed.
javax.jms.JMSException: Journal is closed.
at org.activemq.util.JMSExceptionHelper.newJMSException(JMSExceptionHelper.java:49)
at org.activemq.util.ExceptionTemplate.throwJMSException(ExceptionTemplate.java:72)
at org.activemq.broker.impl.DefaultBroker.stop(DefaultBroker.java:210)
at org.activemq.broker.impl.BrokerContainerImpl.stop(BrokerContainerImpl.java:266)
at org.activemq.ra.ManagedConnectionFactoryTest.tearDown(ManagedConnectionFactoryTest.java:92)
Caused by: java.lang.IllegalStateException: Journal is closed.
at org.activemq.store.journal.JournalPersistenceAdapter.checkpoint(JournalPersistenceAdapter.java:314)
at org.activemq.store.journal.JournalPersistenceAdapter.stop(JournalPersistenceAdapter.java:214)
at org.activemq.store.cache.CachePersistenceAdapter.stop(CachePersistenceAdapter.java:85)
at org.activemq.broker.impl.DefaultBroker$3.execute(DefaultBroker.java:206)
at org.activemq.util.ExceptionTemplate.run(ExceptionTemplate.java:41)
at org.activemq.broker.impl.DefaultBroker.stop(DefaultBroker.java:204)
... 11 more ",Bug
AMQ-403,12481645,,JMS client was Connected but not recive message and I query the database that it has data.,Bug
AMQ-401,12481431,,"When I use derbydb and hsqldb to store data.I always send data and not recive data.
Then will report memory limit,and then I close activeMq,and then run activeMQ,then will recover data.

But,when activeMQ print Start recover data,it will stop.I have wait 2 hours and repleace other database.Always stop.
",Bug
AMQ-412,12481432,,"11:03:12 WARN  stop dispatching
java.lang.NullPointerException
        at java.util.Hashtable.putAll(Hashtable.java:467)
        at org.activemq.transport.stomp.FrameBuilder.addHeaders(FrameBuilder.jav                                                a:56)
        at org.activemq.transport.stomp.Subscription.receive(Subscription.java:6                                                1)
        at org.activemq.transport.stomp.StompWireFormat.writePacket(StompWireFor                                                mat.java:121)
        at org.activemq.transport.tcp.TcpTransportChannel.doAsyncSend(TcpTranspo                                                rtChannel.java:474)
        at org.activemq.transport.tcp.TcpTransportChannel.asyncSend(TcpTransport                                                Channel.java:290)
        at org.activemq.broker.impl.BrokerClientImpl.send(BrokerClientImpl.java:                                                689)
        at org.activemq.broker.impl.BrokerClientImpl.dispatchToClient(BrokerClie                                                ntImpl.java:221)
        at org.activemq.broker.impl.BrokerClientImpl.dispatch(BrokerClientImpl.j                                                ava:166)
        at org.activemq.service.boundedvm.DurableQueueSubscription.doDispatch(Du                                                rableQueueSubscription.java:93)
        at org.activemq.service.boundedvm.DurableQueueBoundedMessageContainer.ru                                                n(DurableQueueBoundedMessageContainer.java:337)
        at EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(Unknown So                                                urce)
        at java.lang.Thread.run(Thread.java:595)",Bug
AMQ-674,12481621,,"well, we've just got bit by something huge.  

Previously we have been shipping messages from producer to consumer via a named Queue 'Index2.EntityIncrementalIndexer', where the machine index2 has a consumer called ""EntityIncrementalIndexer"" using persisted messages.

The design used Composite destinations so that the destination could be:

""Index1.EntityIncrementalIndexer,Index2.EntityIncrementalIndexer"" 

and have the 2 hosts get sent the same message simply, and if one goes down, it'll catch up later.  This gave us the ability to have a mirrored configuration, and go tertiary later if we want simply by adding a new name in the composite destation.

With a single name, this works great, been working fine for months.  Yesterday we activated the _true_ composite destination, and both machines started getting their messages fine.  

no problems so far, BUT, 12 hours later we have noticed that the broker has now stopped accepting messages, and a look at the activemq_msgs table shows 33228 messages ",Bug
AMQ-508,12481664,,"When I start with activemq.bat script following error occurs. Please note that my current and default locale is Turkish. When I changed to English US it was started without any error.

C:\activemq-3.2.1\bin>
C:\activemq-3.2.1\bin>
C:\activemq-3.2.1\bin>activemq
ActiveMQ Message Broker (http://activemq.org/)

Loading Mesaage Broker from activemq.xml on the CLASSPATH
java.lang.RuntimeException: Instruction unknown: load²nstruction
        at com.sun.org.apache.bcel.internal.util.InstructionFinder.mapName(InstructionFinder.java:138)
        at com.sun.org.apache.bcel.internal.util.InstructionFinder.compilePattern(InstructionFinder.java:170)
        at com.sun.org.apache.bcel.internal.util.InstructionFinder.search(InstructionFinder.java:218)
        at com.sun.org.apache.bcel.internal.util.InstructionFinder.search(InstructionFinder.java:264)
        at com.sun.org.apache.xalan.internal.xsltc.compiler.Mode.peepHoleOptimization(Mode.java:1444)
        at com.sun.org.apache.xalan.internal.xsltc.compiler.Mode.compileApplyTemplates(Mode.java:1058)
        at com.sun.org.apache.xalan.internal.xsltc.compiler.Stylesheet.compileModes(Stylesheet.java:615)
        at com.sun.org.apache.xalan.internal.xsltc.compiler.Stylesheet.translate(Stylesheet.java:730)
        at com.sun.org.apache.xalan.internal.xsltc.compiler.XSLTC.compile(XSLTC.java:335)
        at com.sun.org.apache.xalan.internal.xsltc.compiler.XSLTC.compile(XSLTC.java:410)
        at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl.newTemplates(TransformerFactoryImpl.java:791)
        at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl.newTransformer(TransformerFactoryImpl.java:619)
        at org.activemq.spring.ActiveMQBeanDefinitionReader.createTransformer(ActiveMQBeanDefinitionReader.java:63)
        at org.activemq.spring.ActiveMQBeanDefinitionReader.transformDocument(ActiveMQBeanDefinitionReader.java:94)
        at org.activemq.spring.ActiveMQBeanDefinitionReader.registerBeanDefinitions(ActiveMQBeanDefinitionReader.java:53)
        at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:155)
        at org.activemq.spring.ActiveMQBeanFactory.<init>(ActiveMQBeanFactory.java:86)
        at org.activemq.spring.ActiveMQBeanFactory.<init>(ActiveMQBeanFactory.java:57)
        at org.activemq.spring.SpringBrokerContainerFactory.createBrokerContainer(SpringBrokerContainerFactory.java:86)
        at org.activemq.spring.Main.main(Main.java:71)
ERROR:  'Instruction unknown: load²nstruction'
FATAL ERROR:  'Could not compile stylesheet'
Caught: org.activemq.spring.ConfigurationParseException: Could not parse resource: class path resource [activemq.xml]. Reason: javax.xml.transform.TransformerConfigurationException: Could not compile stylesheet; nested exception is javax.xml.transform.TransformerConfigurationException: Could not compile stylesheet
org.activemq.spring.ConfigurationParseException: Could not parse resource: class path resource [activemq.xml]. Reason: javax.xml.transform.TransformerConfigurationException: Could not compile stylesheet; nested exception is javax.xml.transform.TransformerConfigurationException: Could not compile stylesheet
javax.xml.transform.TransformerConfigurationException: Could not compile stylesheet
        at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl.newTemplates(TransformerFactoryImpl.java:824)
        at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl.newTransformer(TransformerFactoryImpl.java:619)
        at org.activemq.spring.ActiveMQBeanDefinitionReader.createTransformer(ActiveMQBeanDefinitionReader.java:63)
        at org.activemq.spring.ActiveMQBeanDefinitionReader.transformDocument(ActiveMQBeanDefinitionReader.java:94)
        at org.activemq.spring.ActiveMQBeanDefinitionReader.registerBeanDefinitions(ActiveMQBeanDefinitionReader.java:53)
        at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:155)
        at org.activemq.spring.ActiveMQBeanFactory.<init>(ActiveMQBeanFactory.java:86)
        at org.activemq.spring.ActiveMQBeanFactory.<init>(ActiveMQBeanFactory.java:57)
        at org.activemq.spring.SpringBrokerContainerFactory.createBrokerContainer(SpringBrokerContainerFactory.java:86)
        at org.activemq.spring.Main.main(Main.java:71)
C:\activemq-3.2.1\bin>
C:\activemq-3.2.1\bin>
C:\activemq-3.2.1\bin>",Bug
AMQ-489,12481414,,"But ,If unilateralism channel it can be resumed.

I used bidirectional channel.

I have test one way channel that's no bug.but bidirectional channel cann't resume.

config one:
<?xml version=""1.0"" encoding=""UTF-8""?>
<!DOCTYPE beans PUBLIC ""-//ACTIVEMQ//DTD//EN"" ""http://activemq.org/dtd/activemq.dtd"">
<beans>

<!-- ==================================================================== -->
<!-- ActiveMQ Broker Configuration -->
<!-- ==================================================================== -->
<broker name =""tao-111"">

<connector >
<tcpServerTransport uri=""tcp://localhost:61616"" backlog=""1000"" useAsyncSend=""true"" maxOutstandingMessages=""50"" />
</connector>
<connector>
<tcpServerTransport uri=""tcp://128.64.7.64:62001"" />
</connector>
<connector>
<serverTransport uri=""stomp://localhost:61626""/>
</connector>


<networkConnector>
<networkChannel uri=""reliable:tcp://128.64.7.27:62001"" />
<localPrefetchPolicy queuePrefetch=""100"" queueBrowserPrefetch=""100"" topicPrefetch=""100"" durableTopicPrefetch=""100""/>
<remotePrefetchPolicy topicPrefetch=""100"" durableTopicPrefetch=""100"" queuePrefetch=""100"" queueBrowserPrefetch=""100"" />
</networkConnector>


config two:

<?xml version=""1.0"" encoding=""UTF-8""?>
<!DOCTYPE beans PUBLIC ""-//ACTIVEMQ//DTD//EN"" ""http://activemq.org/dtd/activemq.dtd"">
<beans>

<!-- ==================================================================== -->
<!-- ActiveMQ Broker Configuration -->
<!-- ==================================================================== -->
<broker name =""tao-1"">

<connector >
<tcpServerTransport uri=""tcp://localhost:61616"" backlog=""1000"" useAsyncSend=""true"" maxOutstandingMessages=""50""/>
</connector>
<connector>
<tcpServerTransport uri=""tcp://128.64.7.27:62001"" />
</connector>
<connector>
<serverTransport uri=""stomp://localhost:61626"" />
</connector>


<networkConnector>
<networkChannel uri=""reliable:tcp://128.64.7.64:62001""/>
<localPrefetchPolicy queuePrefetch=""100"" queueBrowserPrefetch=""100"" topicPrefetch=""100"" durableTopicPrefetch=""100""/>
<remotePrefetchPolicy topicPrefetch=""100"" durableTopicPrefetch=""100"" queuePrefetch=""100"" queueBrowserPrefetch=""100"" />

</networkConnector>
.... 

",Bug
AMQ-466,12481395,,The ActiveMQ networkchannel cann't resume when network is interrupt and rescume.,Bug
AMQ-436,12481393,,"STOMP C client send message,JMS Client cann't received. Also JMS Client Send Message that cann't be reiceived by stomp client.

I used physicalName to communicate.",Bug
AMQ-559,12481437,,"The file org/activemq/activemq.dtd in activemq-core-3.2.2.jar contains some duplicate lines.  My XML parser (OC4J) 
complains about these.  Here are the duplicated lines:

<!--
	Default values for all bean definitions. Can be overridden at
	the ""bean"" level. See those attribute definitions for details.
-->
<!ATTLIST beans default-lazy-init (true | false) ""false"">
<!ATTLIST beans default-dependency-check (none | objects | simple | all) ""none"">
<!ATTLIST beans default-autowire (no | byName | byType | constructor | autodetect) ""no"">

These lines appear starting a line 21 and line 539.  Removing the second set of duplicate lines should resolve the issue.

",Bug
AMQ-641,12481566,,"If I use failover:tcp//.... in the jms client,
That all method will be blocked when net or activemq error.
This  is not a good idea.My application will be blocked. 

And If I use tcp//.... in the jms client,Sometimes ,send(message) method will be blocked,also not return.

 JMS is a asynchronous interface ,blocking is not allow at any condition.",Bug
AMQ-533,12481557,,"I received the following error when trying to run ActiveMQ for the first time in the above environment:

""Specified key was too long; max key length is 1024 bytes...""

when ActiveMQ tries to create the ACTIVEMQ_ACKS table. It looks like the pk for that table involves two columns which are defined in DefaultStatementProvider.java as being VARCHAR(250)s. In in UTF-8 characterset each char is composed of 3 bytes such that in this case the pk will be 1500 bytes which exceeds the max length for a InnoDB primary key.

Is there a spec. which stipulates that containernameDataType and subscriptionIdDataType should be VARCHAR(250)? Could these be changed to say VARCHAR(128) or some such so that the pk on that table will fall within the 1024 byte limit?
",Bug
AMQ-541,12481556,,"It appears that the activemq.xml configuration file contains a typo with respect to the adapterClass attribute settings on the jdbcPersistence element with dataSourceRef=""mysql-ds"". The default value of the adapterClass attribute is 

org.activemq.store.jdbc.adapter.BlobJDBCAdaptor

However, the class name is actually

org.activemq.store.jdbc.adapter.BlobJDBCAdapter
                                                                                        ^

This manifests itself as an error on startup when you try to use this adapter class.



",Bug
AMQ-612,12481493,,"This would be an edge case, since it would be odd that the endpoint factory never creates and endpoint, but it could happen if the endpoint factory is invalid for some reason.",Bug
AMQ-671,12481197,,"A connection URL with list configuration options (maximumRetries, failureSleepTime, etc ...) which doesn't put it parens around it's connection string as in '(tcp://localhost:61616)' is not processed properly because URI.getQuery method return null instead of the configuration options.

CompositeTransportChannelFactory.java:            answer = uri.getQuery();

For example:
reliable:(tcp://foo:61699,tcp://bar:61617,tcp://whatnot:61698)?maximumRetries=5
will work but:
reliable:tcp://foo:61699?maximumRetries=5
will not work.",Bug
AMQ-756,12481716,,"
On windows server when trying to create a Topic Session code just hangs, here is the Thread Dump, same code works fine Unix and Linux environment


""StackTrace Remote Thread"" prio=5 tid=0x0444a1a0 nid=0x15ac runnable [0..55dfb9c]

 

""tcp://dubxww11hrxxxx/10.251.116.216:29258"" prio=5 tid=0x04454868 nid=0xcf4 runnable [550f000..550fd8c]

            at java.net.SocketInputStream.socketRead0(Native Method)

            at java.net.SocketInputStream.read(SocketInputStream.java:129)

            at org.apache.activemq.transport.tcp.TcpBufferedInputStream.fill(TcpBufferedInputStream.java:48)

            at org.apache.activemq.transport.tcp.TcpBufferedInputStream.read(TcpBufferedInputStream.java:55)

            at java.io.DataInputStream.readInt(DataInputStream.java:443)

            at org.apache.activemq.openwire.OpenWireFormat.unmarshal(OpenWireFormat.java:180)

            at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:135)

            at java.lang.Thread.run(Thread.java:534)

 

""Thread-0"" daemon prio=5 tid=0x03733c30 nid=0x508 in Object.wait() [42df000..42dfd8c]

            at java.lang.Object.wait(Native Method)

            - waiting on <0x12cb01c8> (a java.util.TaskQueue)

            at java.util.TimerThread.mainLoop(Timer.java:429)

            - locked <0x12cb01c8> (a java.util.TaskQueue)

            at java.util.TimerThread.run(Timer.java:382)

 

""Signal Dispatcher"" daemon prio=10 tid=0x008ad9f0 nid=0xf8c runnable [0..0]

 

""Finalizer"" daemon prio=9 tid=0x008aafa0 nid=0x1328 in Object.wait() [2faf000..2fafd8c]

            at java.lang.Object.wait(Native Method)

            - waiting on <0x12d6cac0> (a java.lang.ref.ReferenceQueue$Lock)

            at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:111)

            - locked <0x12d6cac0> (a java.lang.ref.ReferenceQueue$Lock)

            at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:127)

            at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:159)

 

""Reference Handler"" daemon prio=10 tid=0x008a9c20 nid=0x760 in Object.wait() [2eaf000..2eafd8c]

            at java.lang.Object.wait(Native Method)

            - waiting on <0x12d6cb28> (a java.lang.ref.Reference$Lock)

            at java.lang.Object.wait(Object.java:429)

            at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:115)

            - locked <0x12d6cb28> (a java.lang.ref.Reference$Lock)

 

""main"" prio=5 tid=0x00037c50 nid=0x1650 in Object.wait() [7e000..7fc3c]

            at java.lang.Object.wait(Native Method)

            - waiting on <0x101deeb0> (a edu.emory.mathcs.backport.java.util.concurrent.CountDownLatch)

            at java.lang.Object.wait(Object.java:429)

            at edu.emory.mathcs.backport.java.util.concurrent.CountDownLatch.await(CountDownLatch.java:173)

            - locked <0x101deeb0> (a edu.emory.mathcs.backport.java.util.concurrent.CountDownLatch)

            at org.apache.activemq.transport.WireFormatNegotiator.oneway(WireFormatNegotiator.java:61)

            at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:44)

            - locked <0x101efb00> (a java.lang.Object)

            at org.apache.activemq.transport.ResponseCorrelator.asyncRequest(ResponseCorrelator.java:62)

            at org.apache.activemq.transport.ResponseCorrelator.request(ResponseCorrelator.java:67)

            at org.apache.activemq.ActiveMQConnection.syncSendPacket(ActiveMQConnection.java:1068)

            at org.apache.activemq.ActiveMQConnection.ensureConnectionInfoSent(ActiveMQConnection.java:1132)

            at org.apache.activemq.ActiveMQConnection.createSession(ActiveMQConnection.java:251)

            at org.apache.activemq.ActiveMQConnection.createTopicSession(ActiveMQConnection.java:845)

            at com.sterlingcommerce.woodstock.event.RemoteEventProcessorImpl.<init>(RemoteEventProcessorImpl.java:103)

            at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)

            at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)

            at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)

            at java.lang.reflect.Constructor.newInstance(Constructor.java:274)

            at com.sterlingcommerce.woodstock.event.EventProcessorFactory.getProcessor(EventProcessorFactory.java:86)

            - locked <0x3147e190> (a java.lang.Class)

            at com.sterlingcommerce.woodstock.event.EventProcessorFactory.getProcessor(EventProcessorFactory.java:63)

            at com.sterlingcommerce.woodstock.bi.util.BIEventHelper.fireEvent(BIEventHelper.java:65)

            at com.sterlingcommerce.woodstock.bi.util.BIEventHelper.sendStraightThroughEvent(BIEventHelper.java:103)

            at com.sterlingcommerce.woodstock.bi.util.BIEventHelper.sendStraightThroughEvent(BIEventHelper.java:93)

            at com.sterlingcommerce.woodstock.util.frame.log.EventLog.write(EventLog.java:62)

            at com.sterlingcommerce.test.bi.BIEventFwdListenerTester.fireLoggerEvent(BIEventFwdListenerTester.java:665)

            at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

            at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)

            at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)

            at java.lang.reflect.Method.invoke(Method.java:324)

            at junit.framework.TestCase.runTest(TestCase.java:154)

            at junit.framework.TestCase.runBare(TestCase.java:127)

            at junit.framework.TestResult$1.protect(TestResult.java:106)

            at junit.framework.TestResult.runProtected(TestResult.java:124)

            at junit.framework.TestResult.run(TestResult.java:109)

            at junit.framework.TestCase.run(TestCase.java:118)

            at junit.framework.TestSuite.runTest(TestSuite.java:208)

            at junit.framework.TestSuite.run(TestSuite.java:203)

            at junit.framework.TestSuite.runTest(TestSuite.java:208)

            at junit.framework.TestSuite.run(TestSuite.java:203)

            at com.sterlingcommerce.ant.taskdefs.junit.XMLJUnitTestRunner.run(XMLJUnitTestRunner.java:439)

            at com.sterlingcommerce.ant.taskdefs.junit.GISJUnitTask.executeInVM(GISJUnitTask.java:984)

            at com.sterlingcommerce.ant.taskdefs.junit.GISJUnitTask.execute(GISJUnitTask.java:662)

            at com.sterlingcommerce.ant.taskdefs.junit.GISJUnitTask.execute(GISJUnitTask.java:637)

            at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)

            at org.apache.tools.ant.Task.perform(Task.java:364)

            at org.apache.tools.ant.Target.execute(Target.java:341)

            at org.apache.tools.ant.Target.performTasks(Target.java:369)

            at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1216)

            at org.apache.tools.ant.helper.SingleCheckExecutor.executeTargets(SingleCheckExecutor.java:37)

            at org.apache.tools.ant.Project.executeTargets(Project.java:1068)

            at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:382)

            at org.apache.tools.ant.taskdefs.CallTarget.execute(CallTarget.java:107)

            at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)

            at org.apache.tools.ant.Task.perform(Task.java:364)

            at org.apache.tools.ant.Target.execute(Target.java:341)

            at org.apache.tools.ant.Target.performTasks(Target.java:369)

            at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1216)

            at org.apache.tools.ant.Project.executeTarget(Project.java:1185)

            at com.sterlingcommerce.woodstock.install.deployer.AntDeployer.executeScript(AntDeployer.java:220)

            at com.sterlingcommerce.woodstock.install.deployer.AntDeployer.deploy(AntDeployer.java:173)

            at com.sterlingcommerce.woodstock.install.deployer.AntDeployer.main(AntDeployer.java:167)

            at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)

            at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)

            at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)

            at java.lang.reflect.Method.invoke(Method.java:324)

            at com.sterlingcommerce.woodstock.noapp.NoAppLoader.main(NoAppLoader.java:75)

 

""VM Thread"" prio=5 tid=0x009446c0 nid=0xb24 runnable 

 

""VM Periodic Task Thread"" prio=10 tid=0x008bdb50 nid=0xe48 waiting on condition 

""Suspend Checker Thread"" prio=10 tid=0x008acf58 nid=0x3c8 runnabl
",Bug
AMQ-627,12481445,,"There are a bunch of these in the code:

                try {
                        ...
                } catch (InterruptedException e) {
                }

Which should be

                try {
                        ...
                } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                }

... or 

                try {
                        ...
                } catch (InterruptedException e) {
                        throw JMSExceptionSupport.create(e);
                }

... or whatever. Just don't throw away my interrupts.",Bug
AMQ-605,12481473,12481938,"There have been some *scary* bugfixes in b.u.c as described here:
http://dcl.mathcs.emory.edu/util/backport-util-concurrent/changelog.php
Upgrading will probably solve some very obscure bugs, most importantly related to ReentrantReadWriteLock, Condition & livelocks (some JIRA issues sound like that). I recently upgraded mule to buc-2.1 and have not observed any regressions.
",Bug
AMQ-534,12481599,,"OpenWireScript.java contains a package declaration for org.apache.activemq.openwire.tool but is in the directory hierarchy for org.activemq.openwire.tool.

I've no idea if it's important, but it's the only thing preventing me from compiling all activemq in Eclipse (after using 'maven eclipse' to generate the .classpath and .project files). ",Bug
AMQ-617,12481597,12481626,"The exceptions are always along these lines...
16:20:30,864 INFO [STDOUT] java.lang.ClassCastException: org.apache.activemq.command.XATransactionId 
16:20:30,865 INFO [STDOUT] at org.apache.activemq.openwire.v1.TransactionInfoMarshaller.unmarshal(TransactionInfoMarshaller.java:67) 
16:20:30,865 INFO [STDOUT] at org.apache.activemq.openwire.OpenWireFormat.doUnmarshal(OpenWireFormat.java:214) 
16:20:30,865 INFO [STDOUT] at org.apache.activemq.openwire.OpenWireFormat.unmarshal(OpenWireFormat.java:181) 
16:20:30,865 INFO [STDOUT] at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:135) 
16:20:30,865 INFO [STDOUT] at java.lang.Thread.run(Thread.java:595) 

see the test case MarshallingWithCachingTest for how to reproduce the problem.
",Bug
AMQ-621,12481622,,"setup: (1) activemq up running with ssl
            (2) JMS client (application) was compiled purely used sun solaris environment with jdk1.5.0_03 and jms1.1.jar. Debugging mode was turned on.
            (3) use jndi.properties file provided at activemq.

Execution:
         Producer simply sent 1000 text messages with 46 characters each on a queue.
         Consumer use synchrouse receive mode: receive()

Observation:
         (1) Both producer and receiver successfully handsaked with activemq (by looking into logs about ssl certification verification and negociation.
         (2) Producer continuously pushed messages into queue and consumer received messages.
         (3) After several hundred message delivered and received, consumer got null pointer exception as below:
       
         ....
         main, WRITE: TLSv1 Application Data, length = 46
         Client received: No. 450:Sever message: abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz
         Socket Connection: /127.0.0.1:55693 -> localhost/127.0.0.1:61618, READ: TLSv1 Application Data, length = 161
         main, WRITE: TLSv1 Application Data, length = 46
         Client received: No. 451:Sever message: abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz
         Socket Connection: /127.0.0.1:55693 -> localhost/127.0.0.1:61618, READ: TLSv1 Application Data, length = 161
         Mar 8, 2006 2:38:10 PM org.apache.activemq.ActiveMQConnection onAsyncException
         WARNING: Async exception with no exception listener: java.io.IOException: Unexpected Error: java.lang.NullPointerException
        java.io.IOException: Unexpected Error: java.lang.NullPointerException
        at org.activeio.adapter.SyncToAsyncChannel.run(SyncToAsyncChannel.java:161)
        at edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:643)
        at edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:668)
        at java.lang.Thread.run(Thread.java:595)
Caused by: java.lang.NullPointerException
        at org.apache.activemq.openwire.OpenWireFormat.unmarshal(OpenWireFormat.java:146)
        at org.activeio.command.AsyncChannelToAsyncCommandChannel$1.onPacket(AsyncChannelToAsyncCommandChannel.java:69)
        at org.apache.activemq.transport.activeio.PacketAggregatingAsyncChannel.onPacket(PacketAggregatingAsyncChannel.java:92)
        at org.activeio.FilterAsyncChannel.onPacket(FilterAsyncChannel.java:87)
        at org.apache.activemq.transport.activeio.ActivityMonitor.onPacket(ActivityMonitor.java:42)
        at org.activeio.adapter.SyncToAsyncChannel.run(SyncToAsyncChannel.java:155)
        ... 3 more
Socket Connection: /127.0.0.1:55693 -> localhost/127.0.0.1:61618, called close()
Socket Connection: /127.0.0.1:55693 -> localhost/127.0.0.1:61618, called closeInternal(true)
Socket Connection: /127.0.0.1:55693 -> localhost/127.0.0.1:61618, SEND TLSv1 ALERT:  warning, description = close_notify
Socket Connection: /127.0.0.1:55693 -> localhost/127.0.0.1:61618, WRITE: TLSv1 Alert, length = 18
Socket Connection: /127.0.0.1:55693 -> localhost/127.0.0.1:61618, called close()
Socket Connection: /127.0.0.1:55693 -> localhost/127.0.0.1:61618, called closeInternal(true)
Socket Connection: /127.0.0.1:55693 -> localhost/127.0.0.1:61618, called close()
Socket Connection: /127.0.0.1:55693 -> localhost/127.0.0.1:61618, called closeInternal(true)

 







",Bug
AMQ-623,12481586,,"I got exceptions from time to time when I close connections,

---------------------------------------------------------------------------------------------------------------------------------------------
2006-3-9 11:42:11 org.apache.activemq.ActiveMQConnection transportFailed
Warn: Cleanup failed
javax.jms.JMSException: Cannot write to the stream any more it has already been closed
	at org.apache.activemq.util.JMSExceptionSupport.create(JMSExceptionSupport.java:57)
	at org.apache.activemq.ActiveMQConnection.asyncSendPacket(ActiveMQConnection.java:1043)
	at org.apache.activemq.ActiveMQConnection.cleanup(ActiveMQConnection.java:1191)
	at org.apache.activemq.ActiveMQConnection.transportFailed(ActiveMQConnection.java:1585)
	at org.apache.activemq.ActiveMQConnection.onException(ActiveMQConnection.java:1338)
	at org.apache.activemq.transport.TransportFilter.onException(TransportFilter.java:102)
	at org.apache.activemq.transport.TransportFilter.onException(TransportFilter.java:102)
	at org.apache.activemq.transport.TransportFilter.onException(TransportFilter.java:102)
	at org.apache.activemq.transport.TransportSupport.onException(TransportSupport.java:90)
	at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:149)
	at java.lang.Thread.run(Unknown Source)
Caused by: java.io.EOFException: Cannot write to the stream any more it has already been closed
	at org.apache.activemq.transport.tcp.TcpBufferedOutputStream.checkClosed(TcpBufferedOutputStream.java:131)
	at org.apache.activemq.transport.tcp.TcpBufferedOutputStream.write(TcpBufferedOutputStream.java:69)
	at java.io.DataOutputStream.writeInt(Unknown Source)
	at org.apache.activemq.openwire.OpenWireFormat.marshal(OpenWireFormat.java:169)
	at org.apache.activemq.transport.tcp.TcpTransport.oneway(TcpTransport.java:117)
	at org.apache.activemq.transport.TransportFilter.oneway(TransportFilter.java:90)
	at org.apache.activemq.transport.WireFormatNegotiator.oneway(WireFormatNegotiator.java:65)
	at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:44)
	at org.apache.activemq.transport.ResponseCorrelator.oneway(ResponseCorrelator.java:54)
	at org.apache.activemq.ActiveMQConnection.asyncSendPacket(ActiveMQConnection.java:1041)
	... 9 more
---------------------------------------------------------------------------------------------------------------------------------------------

It seems that things happened in this order:

1. On client, in user thread, connection.close() is called.

2. On server, shutdown info is received  and socket is closed.

3. On client, in consumer thread, TcpTransport got an EOFException because socket is closed before TcpTransport.closed is set to true.

4. On client, ActiveMQConnection.cleanup() is called becauseof EOFException happend in 3. But isConnectionInfoSentToBroker is still true, another Exception is raised when sending packet to broker through the already closed socket.


",Bug
AMQ-547,12481548,,"My current broker has a consumer that sends email when requested. I connect to it with a producer that pushes a single message onto the queue. I just ran that 70 times and told it to send 70 messages, which I then received. To the best of my knowledge, active should be idle. 

Browsing in jconsole, I see the following data for the broker itself: 

totalConsumerCount 1 - check - my one consumer 

totalDequeueCount 70 - check - I put 70 on the queue. 

totalEnqueueCount 768 - hmmm. Are there 689 somethings waiting to be cleared? 

totalMessage 0 - makes sense, as I got every email that I asked for. There should be no messages left. 

Looking in the connection and connector mbeans, I see 70 messages enqueued, and 70 dequeued, which would fit with 70 being sent since I started the broker. Further, there were 140 connections. 

The other anomaly I saw was the number of connections. Every time I queue up another twenty, I appear to get another connection. They have nothing enqueued, and nothing dequeued, and they are instances of org.apache.activemq.broker.jmx.ConnectionView. Even after everything is done, they show as active and connected, but not waiting. Anyone seen this behavior? 

So, my question is why are there so many enqueues on the broker? As a side question, are there cases where the connection list just grows?",Bug
AMQ-694,12481657,,"I am using 4.0 M3 and create a durable consumer with JMS API ""createDurableSubscriber(Topic topic, java.lang.String name, java.lang.String messageSelector, boolean noLocal)"". I found that ActiveMQ behaves very strange when too long string is assigned to ""messageSelector"". The ActiveMQ is Ok if I cut the string to short.

Anyone had this experience before? Any solution fo it? Here is my long string:

ehs.handler.event.type.email_sp=event_type\='email_unsub_promotion' or event_type\='email_unsub_promotion_dne' or event_type\='email_user_sign_up' or event_type\='email_user_sign_up_er' or event_type\='email_registration_confirm' or event_type\='email_client_approved_offerr' or event_type\='email_certificate_received' or event_type\='email_gift_card_redeemed' or event_type\='email_password_lost' or event_type\='email_resend_sign_up'
",Bug
AMQ-709,12481652,,"values for dependencies are using interpolation that isn't defined.

therefore all dependent jars are breaking on the download",Bug
AMQ-530,12481322,,"
The method in DefaultThreadPools should be called getDefaultPool() not getDeaultPool().
",Bug
AMQ-585,12483261,,"I am using ActiveMQ as part of a web-app deployed to Tomcat. Active MQ is configured via spring and follows the spring examples that you ship with the source in M4. If I configure the broker to use JMX (  <broker useJmx=""true""> ) and deploy the app to tomcat, everything goes fine. However, when I deploy a newer version of the app (hot deploy) I get the following error when the JMS consumer is created from spring:

006-02-20 15:16:17,378 ERROR org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:205) Context initialization failed
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'smsResponseConsumer' defined in ServletContext resource [/WEB-INF/applicationContext-messaging.xml]: Initialization of bean failed; nested exception is javax.jms.JMSException: org.apache.activemq:Type=Topic,Destination=ActiveMQ.Advisory.Connection,BrokerName=localhost
javax.jms.JMSException: org.apache.activemq:Type=Topic,Destination=ActiveMQ.Advisory.Connection,BrokerName=localhost

And the root cause of this exception is:

Caused by: javax.management.InstanceAlreadyExistsException: org.apache.activemq:Type=Topic,Destination=ActiveMQ.Advisory.Connection,BrokerName=localhost
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:274)
	at org.apache.activemq.openwire.DataStreamMarshaller.createThrowable(DataStreamMarshaller.java:199)
	at org.apache.activemq.openwire.DataStreamMarshaller.unmarsalThrowable(DataStreamMarshaller.java:159)
	at org.apache.activemq.openwire.v1.ExceptionResponseMarshaller.unmarshal(ExceptionResponseMarshaller.java:67)
	at org.apache.activemq.openwire.OpenWireFormat.doUnmarshal(OpenWireFormat.java:214)
	at org.apache.activemq.openwire.OpenWireFormat.unmarshal(OpenWireFormat.java:181)
	at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:135)
	... 1 more

So it appears as if the JMX entry isn't ""unbound"" when the applicaiton restarts on a redeploy.

If I set JMX to false then I can redeploy the application without any errors. 
",Bug
AMQ-713,12481687,,"investigate possible bug with LastImageRecoveryPolicy .  A unit test for this would also help. 

http://www.nabble.com/Special-Topic-Queue...-t1558344.html",Bug
AMQ-696,12481745,,"While using the new Spring-2.0 DefaultMessageListenerContainer I can reliably reproduce the following exception on the broker side which usually results in a hang on the client side:
 
The broker logs the following exception:
 
INFO  Service                        - Sync error occurred: javax.jms.InvalidClientIDException: Broker: localhost - Client: ID:inspiron-1410-114619274
7453-2:1 already connected
javax.jms.InvalidClientIDException: Broker: localhost - Client: ID:inspiron-1410-1146192747453-2:1 already connected
        at org.apache.activemq.broker.region.RegionBroker.addConnection(RegionBroker.java:154)
        at org.apache.activemq.broker.BrokerFilter.addConnection(BrokerFilter.java:65)
        at org.apache.activemq.advisory.AdvisoryBroker.addConnection(AdvisoryBroker.java:69)
        at org.apache.activemq.broker.BrokerFilter.addConnection(BrokerFilter.java:65)
        at org.apache.activemq.broker.MutableBrokerFilter.addConnection(MutableBrokerFilter.java:77)
        at org.apache.activemq.broker.AbstractConnection.processAddConnection(AbstractConnection.java:500)
        at org.apache.activemq.broker.jmx.ManagedTransportConnection.processAddConnection(ManagedTransportConnection.java:82)
        at org.apache.activemq.command.ConnectionInfo.visit(ConnectionInfo.java:106)
        at org.apache.activemq.broker.AbstractConnection.service(AbstractConnection.java:196)
        at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:62)
        at org.apache.activemq.transport.ResponseCorrelator.onCommand(ResponseCorrelator.java:93)
        at org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:70)
        at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:114)
        at org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:122)
        at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:87)
        at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:139)
        at java.lang.Thread.run(Thread.java:595)
 
I have extrapolated the sequence of calls that DefaultMessageListenerContainer is making and managed to produce a simple test case that reproduces the problem:
 
import junit.framework.TestCase;
import org.apache.activemq.ActiveMQConnectionFactory;
import org.apache.activemq.command.ActiveMQQueue;
 
import javax.jms.*;
 
public class TestActiveMQ extends TestCase {
 
    public void testConnectionFactory() throws Exception {
        final ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory(""tcp://localhost:61616"");
        final ActiveMQQueue queue = new ActiveMQQueue(""testqueue"");
        final Connection conn = cf.createConnection();
 
        Runnable r = new Runnable() {
            public void run() {
                try {
                    Session session = conn.createSession(false, 1);
                    MessageConsumer consumer = session.createConsumer(queue, null);
                    Message msg = consumer.receive(1000);
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        };
        new Thread(r).start();
        conn.start();
 
        try {
            synchronized (this) {
                wait(3000);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
 
Let us know if you need anymore information. Dont want to scrub ActiveMQ from my list of candidates If I can help it.
 
cheers
craig
 

",Bug
AMQ-684,12481594,,RC1 not have this bug.,Bug
AMQ-1278,12482004,,"When we attempt to create a temporary queue, the connection hangs:

""http-8080-Processor1"" daemon prio=10 tid=0x00127650 nid=0xd in Object.wait() [0x340fe000..0x340ffc28]
        at java.lang.Object.wait(Native Method)
        at java.lang.Object.wait(Unknown Source)
        at edu.emory.mathcs.backport.java.util.concurrent.FutureTask.waitFor(FutureTask.java:267)
        at edu.emory.mathcs.backport.java.util.concurrent.FutureTask.get(FutureTask.java:117)
        - locked <0x4cfc65c0> (a org.apache.activemq.transport.FutureResponse)
        at org.apache.activemq.transport.FutureResponse.getResult(FutureResponse.java:44)
        - locked <0x4cfc65c0> (a org.apache.activemq.transport.FutureResponse)
        at org.apache.activemq.transport.ResponseCorrelator.request(ResponseCorrelator.java:69)
        at org.apache.activemq.ActiveMQConnection.syncSendPacket(ActiveMQConnection.java:1108)
        at org.apache.activemq.ActiveMQConnection.createTempDestination(ActiveMQConnection.java:1453)
        at org.apache.activemq.ActiveMQSession.createTemporaryQueue(ActiveMQSession.java:1103)
        at es.tid.geremias.planb.QueryTask.getTask(QueryTask.java:198)
        at es.tid.geremias.planb.QueryTask.doGet(QueryTask.java:157)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:689)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:802)
        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:237)
        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:157)
        at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:214)
        at org.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:104)
        at org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:520)
        at org.apache.catalina.core.StandardContextValve.invokeInternal(StandardContextValve.java:198)
        at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:152)
        at org.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:104)
        at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:540)
        at org.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:102)
        at org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:520)
        at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:137)
        at org.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:104)
        at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:118)
        at org.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:102)
        at org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:520)
        at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)
        at org.apache.catalina.core.StandardValveContext.invokeNext(StandardValveContext.java:104)
        at org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:520)
        at org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:929)
        at org.apache.coyote.tomcat5.CoyoteAdapter.service(CoyoteAdapter.java:160)
        at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:799)
        at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.processConnection(Http11Protocol.java:705)
        at org.apache.tomcat.util.net.TcpWorkerThread.runIt(PoolTcpEndpoint.java:577)
        at org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:683)
        at java.lang.Thread.run(Unknown Source)",Bug
AMQ-689,12481637,,"I have redelivery configured, but when it fails in all attempts (through a RuntimeException), I get the following message:

11:00:54,775 DEBUG [ServerSessionImpl:0] Endpoint failed to process message.
java.lang.NullPointerException
	at org.apache.activemq.ra.ServerSessionImpl.afterDelivery(ServerSessionImpl.java:218)
	at org.apache.activemq.ActiveMQSession.run(ActiveMQSession.java:723)
	at org.apache.activemq.ra.ServerSessionImpl.run(ServerSessionImpl.java:163)
	at org.apache.geronimo.connector.work.WorkerContext.run(WorkerContext.java:291)
	at EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
11:00:54,775 INFO  [ServerSessionImpl:0] Endpoint failed to process message. Reason: java.lang.NullPointerException
11:00:54,775 DEBUG [ServerSessionImpl:0] run loop end
11:00:54,775 DEBUG [ServerSessionImpl:0] Endpoint did not release properly: org.apache.activemq.ra.InvalidMessageEndpointException
org.apache.activemq.ra.InvalidMessageEndpointException
	at org.apache.activemq.ra.MessageEndpointProxy$MessageEndpointDead.release(MessageEndpointProxy.java:156)
	at org.apache.activemq.ra.MessageEndpointProxy.release(MessageEndpointProxy.java:68)
	at org.apache.activemq.ra.ServerSessionImpl.close(ServerSessionImpl.java:250)
	at org.apache.activemq.ra.ServerSessionPoolImpl.removeFromPool(ServerSessionPoolImpl.java:180)
	at org.apache.activemq.ra.ServerSessionImpl.run(ServerSessionImpl.java:177)
	at org.apache.geronimo.connector.work.WorkerContext.run(WorkerContext.java:291)
	at EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
11:00:54,775 DEBUG [ServerSessionImpl:0] Run finished
11:00:54,775 DEBUG [ServerSessionImpl:0] Work completed: javax.resource.spi.work.WorkEvent[source=Work :ServerSessionImpl:0]
11:00:54,790 DEBUG [ServerSessionPoolImpl] ServerSession requested.

The code that throws this NPE is ServerSessionImpl, whose excerpt I send below. There are more reports of this 

            try {
                endpoint.afterDelivery();
            } catch (Throwable e) {
                throw new RuntimeException(""Endpoint after delivery notification failure"", e);
            } finally {
                if( session.getTransactionContext().isInLocalTransaction() ) { <<<<--------------------------- NPE
                    if( !useRAManagedTx ) {
                        // Sanitiy Check: If the local transaction has not been commited..
                        // Commit it now.
                        log.warn(""Local transaction had not been commited.  Commiting now."");
                    }
                    try {
                        session.commit();
                    } catch (JMSException e) {
                        log.info(""Commit failed:"", e);
                    }
                }
            }",Bug
AMQ-679,12481396,,"If start broker  i get this message:

WARNING: Database driver NOT recognized: 
[ibm_db2_jdbc_universal_driver_architecture].  Will use default JDBC 
implementation.

But this seems to be o.k. so far, because after starting the broker, two new 
tables (activemq_msgs/acks) get created. 

Testing a Consumer to receive Messages
the broker throws this exception:

2006-04-05 17:13:03,304 [.168.1.52:52134] 
INFO  Service                        - Sync error occurred: java.io.IOException: Non-atomic batch failure.  The batch was submitted, but at least one exception occurred on an individual member of the batch. Use getNextException() to retrieve the exceptions for specific batched elements.
java.io.IOException: Non-atomic batch failure.  The batch was submitted, but at least one exception occurred on an individual member of the batch. Use getNextException() to retrieve the exceptions for specific batched elements.
	at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:42)
	at org.apache.activemq.store.jdbc.TransactionContext.close(TransactionContext.java:125)
	at org.apache.activemq.store.jdbc.JDBCMessageStore.addMessage(JDBCMessageStore.java:73)
	at org.apache.activemq.store.memory.MemoryTransactionStore.addMessage(MemoryTransactionStore.java:223)
	at org.apache.activemq.store.memory.MemoryTransactionStore$1.addMessage(MemoryTransactionStore.java:116)
	at org.apache.activemq.broker.region.Queue.send(Queue.java:246)
	at org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:196)
	at org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:307)
	at org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:192)
	at org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:108)
	at org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:97)
	at org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:120)
	at org.apache.activemq.broker.AbstractConnection.processMessage(AbstractConnection.java:346)
	at org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:590)
	at org.apache.activemq.broker.AbstractConnection.service(AbstractConnection.java:196)
	at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:62)
	at org.apache.activemq.transport.ResponseCorrelator.onCommand(ResponseCorrelator.java:88)
	at org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:70)
	at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:114)
	at org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:122)
	at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:87)
	at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:136)
	at java.lang.Thread.run(Thread.java:570)",Bug
AMQ-770,12481670,,"Seems like there was a change between 4.0-RC3 and incubator-4.0(.1) with regards to the default value for the destination option ""consumer.dispatchAsync"".  According to the web documentation for destination options, as well as behavior in RC3, the default is true.  However, it looks like incubator-4.0(.1) defaults to false.  I have to explicitly give the consumer.dispatchAsync=true for a destination option, in order to get async dispatch in the Broker.

Is this a code bug, or documentation bug?
",Bug
AMQ-419,12481453,,"With the removal of the TransportStatusListener interface the client lost the ability to obtain useful information from connection/disconnect events.  Similar information can be garnered by creating a TransportListener object and chaining it to the ActiveMQConnection class.  Connection detection can be determined by trapping the BrokerInfo object in the onCommand method and disconnect detected in the onException method. However the BrokerInfo object does not contain the brokerName defined in the configuration file.

",Bug
AMQ-528,12481938,,"Setup: 

3 networked brokers, B1, B2, and B3, on 3 servers, connected using multicast discovery. activemq.xml: 

 <broker useJmx=""false"" brokerName=""B1""> 
  
 <persistenceAdapter> 
        <journaledJDBC journalLogFiles=""5"" dataDirectory=""foo"" dataSource=""#mysql-ds""/> 
 </persistenceAdapter> 
  
 <transportConnectors> 
 <transportConnector uri=""tcp://localhost:61616"" discoveryUri=""multicast://default""/> 
 </transportConnectors> 
  
 <networkConnectors> 
 <networkConnector uri=""multicast://default""/> 
 </networkConnectors> 
  
 </broker> 
  
 <bean id=""mysql-ds"" class=""org.apache.commons.dbcp.BasicDataSource"" destroy-method=""close""> 
           <property name=""driverClassName"" value=""com.mysql.jdbc.Driver""/> 
           <property name=""url"" value=""jdbc:mysql://localhost/activemq?relaxAutoCommit=true""/> 
                 <property name=""username"" value=""activemqUser""/> 
                 <property name=""password"" value=""activemqPwd""/> 
                 <property name=""poolPreparedStatements"" value=""true""/> 
 </bean> 

Similar for B2 and B3. 

Two queues: Q1 and Q2. 

Two producers, one for each queue, both producers connected to B1. 

One Q1 cosumer connected to B1, another Q1 consumer on B2. 

One Q2 consumer connected to B2, another Q2 consumer connected to B3. 

Steps: 

Start the brokers and start sending messages to the queue. 

After a while, stop the brokers (Sequence does not matter) 

See the errors in catalina.out of the Tomcat that has a broker with both producers and consumers connected 

The problems:

1. 

Exception in thread ""ActiveMQ Scheduler"" java.lang.NullPointerException
         at edu.emory.mathcs.backport.java.util.concurrent.helpers.Utils$SunPerfProvider.nanoTime(Utils.java:219)
         at edu.emory.mathcs.backport.java.util.concurrent.helpers.Utils.nanoTime(Utils.java:99)
         at edu.emory.mathcs.backport.java.util.concurrent.ScheduledThreadPoolExecutor.now(ScheduledThreadPoolExecutor.java:88)
         at edu.emory.mathcs.backport.java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.getDelay(ScheduledThreadPoolExecutor.java:137)
 Exception in thread ""ActiveMQ Scheduler"" Exception in thread ""ActiveMQ Scheduler"" Exception in thread ""ActiveMQ Scheduler""      at edu.emory.mathcs.backport.java.util.concurrent.DelayQueue.take(DelayQueue.java:154)
         at edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:470)
         at edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:667)
         at java.lang.Thread.run(Thread.java:595)
 java.lang.NullPointerException
         at edu.emory.mathcs.backport.java.util.concurrent.helpers.Utils$SunPerfProvider.nanoTime(Utils.java:219)
 Exception in thread ""ActiveMQ Scheduler"" Exception in thread ""ActiveMQ Scheduler"" Exception in thread ""ActiveMQ Scheduler""      at edu.emory.mathcs.backport.java.util.concurrent.helpers.Utils.nanoTime(Utils.java:99)
         at edu.emory.mathcs.backport.java.util.concurrent.ScheduledThreadPoolExecutor.now(ScheduledThreadPoolExecutor.java:88)
         at edu.emory.mathcs.backport.java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.getDelay(ScheduledThreadPoolExecutor.java:137)
         at edu.emory.mathcs.backport.java.util.concurrent.DelayQueue.take(DelayQueue.java:154)
         at edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:470)
 Exception in thread ""ActiveMQ Scheduler"" Exception in thread ""ActiveMQ Scheduler""       at edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:667)
         at java.lang.Thread.run(Thread.java:595)

2. The same exception is logged to the log file (in my case catalina.out) for hundreds of times, resulting a log file exceeding 150 MB in 2 minutes. ",Bug
AMQ-647,12481595,,"I'm currently testing the openwire .NET JMS implementation to communicate with a activemq java broker ; the aim of this test is to evaluate the possibilty to deploy the solution in live environment.

My test platform is quite simple :

* A java JMS publisher publishes 100messages / 1s on a test topic
* A java consumer is listening to this topic
* A openwire consumer listens to the same topic

After a few hundreds messages (about 10-20 seconds of publish), the openwire client hangs and receives no more message. Using the Visual Studio debugger, it appears that the client is waiting on a ""read"" from the socket. The side effect of this is that after a few more seconds, the publisher itself stops to emit messages as if some internal queue becomes full or someting.

I'm fully aware that Openwire is always in a development process but I want to point out that this issue already existed in the previous versions I had tested. This problem prevents using the openwire implementation in a live environment in the current state.",Bug
AMQ-500,12481535,,"I have not started to look at unix based start script, but I am finding some interesting issues with the one for use under Windows (activemq.bat).

This script is using the java jar option that points to the ACTIVEMQ_HOME/bin/run.jar file.  The manifest points to the o.a.a.broker.Main class.  

Use of this execution option and review of the o.a.a.broker.Main class (where it sets up a classloader with classpath pointing to the conf, lib and lib/optional directories would lead one to believe that the o.a.a.broker.Main class would be loaded from run.jar.  This is not the case as the script also defines the java property of java.ext.dirs to append the activemq directories.  While it also sets the command line classpath option, this is useless as including all the activemq directories will already include all activemq classes at the base classloader. This also includes a copy of the o.a.a.broker.Main class that is include in the uber activemq-4.0.jar in the ACTIVEMQ_HOME directory.

Also with the definition java.ext.dirs this will total obviate any setting of classpath information on the classloader  (auto or parameter specified) by the o.a.a.broker.Main class.

Obviously something is not right here.  If  o.a.a.broker.Main class is suppose to be setting up the class loader, why is the script setting the java.ext.dir property and the classpath option on the command line?
",Bug
AMQ-418,12481539,,"I think I can answer my own question.  The test of the command should be in the ControlCommand.visit() method.  The CommandVisitor interface of implemented by the TransportConnection already has a processShutdown() method, but I don't think this was meant for JVM level termination.

Dennis Cook wrote:

> Okay I thought I had figured out how to cause a broker shutdown.
>
> I found the onControlCommand method in the ActiveMQConnection class. Great figured just asyncSendPacket() a ControlCommand with ""shutdown"" as command.
>
> First problem found and fixed was command member of ControlCommand was not marshalled.  Next found that the ActiveMQConnection is not part of the filter chain on the broker side.
>
> It seems that an anonymous TransportListener is created, in the TransportConnection contructor, to perform the dispatch. On the surface this seems to me like the appropriate place to replicate the onControlCommand method that I found in the ActiveMQConnection class.
>
> Is the the correct approach or am I off base here?
>
>
>
> Dennis Cook wrote:
>
>> I had added the terminateBrokerVM() method to ActiveMQConnetion in v3 until there was a better way to terminate, from a remote location, the JVM running a broker.  This has been removed from v4 source, but still I cannot find a way to tell the broker JVM to shutdown cleanly.
>>
>> What is the intention for this this vesion? Is it intended that this be accomplished via JMX? I have already tried JConsole and issued STOP on both the broker and connector objects, but the JVM did not stop.
>>
",Bug
AMQ-588,12481658,,"When using a static+failover list for network connections, Broker shutdown is no longer working as of the 02/21/2006 SNAPSHOT release.  If a broker is attempting to connect to another broker which is not currently running, the shutdown blocks waiting for the failover connect thread to complete the connection.  Since the other broker is not running, the shutdown then hangs.

This scenario worked fine with the 02/17/2006 SNAPSHOT release.",Bug
AMQ-719,12481641,,The payload content for a JMS message contains initial bytes for the length of the text string.  The payload content for an dotNet openwire content does not contain this information.  This mismatch in payload results in invalid payloads when passing jms messages between technologies.,Bug
AMQ-799,12481668,,,Bug
AMQ-721,12481878,,"Openwire client hangs after receiving 999 messages
changing Session.Prefetch postpone the  problem...

Current code is :
   public class Session : ISession
    {
       :
       :
        private int prefetchSize = 1000;

this block at message #999

changing         private int prefetchSize = 2000 ==>  blocks at message #1999
",Bug
AMQ-1066,12481876,,"Hi

We use ActiveMQ in a productive environment. Yesterday, one of our application wasn't able to connect to the Broker. I found the following exception in the logfile:  (After I restarted the broker, everything was runnig again.)

-----

2006-10-09 12:05:37,986 [.27.81.119:1741] INFO  Service                        - Sync error occurred: java.lang.NullPointerException
java.lang.NullPointerException
	at org.apache.activemq.util.SubscriptionKey.<init>(SubscriptionKey.java:35)
	at org.apache.activemq.broker.jmx.ManagedRegionBroker.registerSubscription(ManagedRegionBroker.java:161)
	at org.apache.activemq.broker.jmx.ManagedTopicRegion.createSubscription(ManagedTopicRegion.java:44)
	at org.apache.activemq.broker.region.AbstractRegion.addConsumer(AbstractRegion.java:145)
	at org.apache.activemq.broker.region.TopicRegion.addConsumer(TopicRegion.java:113)
	at org.apache.activemq.broker.region.RegionBroker.addConsumer(RegionBroker.java:296)
	at org.apache.activemq.broker.BrokerFilter.addConsumer(BrokerFilter.java:73)
	at org.apache.activemq.advisory.AdvisoryBroker.addConsumer(AdvisoryBroker.java:77)
	at org.apache.activemq.broker.BrokerFilter.addConsumer(BrokerFilter.java:73)
	at org.apache.activemq.broker.MutableBrokerFilter.addConsumer(MutableBrokerFilter.java:86)
	at org.apache.activemq.broker.AbstractConnection.processAddConsumer(AbstractConnection.java:427)
	at org.apache.activemq.command.ConsumerInfo.visit(ConsumerInfo.java:295)
	at org.apache.activemq.broker.AbstractConnection.service(AbstractConnection.java:201)
	at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:62)
	at org.apache.activemq.transport.ResponseCorrelator.onCommand(ResponseCorrelator.java:97)
	at org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:63)
	at org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:114)
	at org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:122)
	at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:87)
	at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:143)
	at java.lang.Thread.run(Unknown Source)

",Bug
AMQ-413,12481412,,"The org.activemq.broker.Main class automatically adds the <activemq.home>/conf, <activemq.home>/lib and <activemq.home>/lib/optional directories to the extentions to be added to the context classloader.  While adding the library directories does not really cause a problem, automaticalling including the conf directory will insure that the configuration file is always found in that directory.  I had previously used an explicit ordering of the -classpath to locate the configuration file in an alternate location.

I would suggest removal of the auto add of the conf directory and use the -classpath entry in the script to add this directory.  That at least give the option of changing the script. ",Bug
AMQ-882,12481748,,"Scenario:
ActiveMQ and the publisher process running on the same server.
Several clients are running on several Windows-XP clients

Publisher code:
{code}
// initializing
connection = msgFactory.createTopicConnection();
connection.setExceptionListener(new JMSExceptionListener());
connection.start();

topicSession = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
topic = topicSession.createTopic(MFS_LOCATION_CHANGE_EVENT_TOPIC);

publisher = topicSession.createPublisher(topic);
publisher.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
[...]
// sending several times with the same topic
try {
  publisher.publish(topicSession.createTextMessage(location.getName()));
} catch (JMSException e) {
  log.fatal(""Problems during informing Workplace topic:"" + location.getName(), e);
  [...]
{code}

Subscriber code:
{code}
topicConnection = msgFactory.createTopicConnection();
topicConnection.start();
topicConnection.setExceptionListener(new JMSExceptionListener(listeners, this));

topicSession = topicConnection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);
Topic topic = topicSession.createTopic(EventSender.MFS_LOCATION_CHANGE_EVENT_TOPIC);

topicSubscriber = topicSession.createSubscriber(topic);
topicSubscriber.setMessageListener(new MessageListener() {
        public void onMessage(Message message) {
          if (message instanceof TextMessage) {
[...]
      topicConnection.start();
{code}

After some thound of messages publish hangs for more than 1 minute and then throws a JMSException (see logs below). After searching in ActiveMQ mailing lists I changed the broker url of the publisher from:
* tcp://arvwms:61616
to 
* tcp://arvwms:61616?soTimeout=2000&connectionTimeout=10000&socketBufferSize=1024&wireFormat.maxInactivityDuration=0

This works some days fine, but now we get the exceptions again.

Is this a problem between topic publisher and ActiveMQ or could it be also a problem between ActiveMQ and topic subscriber? If it is real a problem between publisher and ActiveMQ it can't be a network problem, becuase it is the same server.

This problems occur about 10 times the day. With the exception and losing of 10 messages the day I could live, but the hanging about 1 minute is terrible for our application.

The Exception:
{code}
DEBUG 2006-08-17 12:45:53.738 portConfirmationDefaultHandler :    -:     - handle telegram: com.ssn.acx.extensions.logistics.mfsadapter.telegram.receiving.TransportOrderCompletionTelegram@1385c9f[ID=139887884,loadUnit=01900,lastLocation=SCS_CS,weight=<null>,orientation=0,infoType=COMPLETE,wmsID=1039340,reason=OK]
FATAL 2006-08-17 12:47:12.534 EventSender                    :    -:     - Problems during informing Workplace topic:SCS_CS
javax.jms.JMSException: Broken pipe
  at org.apache.activemq.util.JMSExceptionSupport.create(JMSExceptionSupport.java:57)
  at org.apache.activemq.ActiveMQConnection.asyncSendPacket(ActiveMQConnection.java:1094)
  at org.apache.activemq.ActiveMQSession.send(ActiveMQSession.java:1553)
  at org.apache.activemq.ActiveMQMessageProducer.send(ActiveMQMessageProducer.java:462)
  at org.apache.activemq.ActiveMQMessageProducer.send(ActiveMQMessageProducer.java:356)
  at org.apache.activemq.ActiveMQTopicPublisher.publish(ActiveMQTopicPublisher.java:128)
  at com.ssn.acx.extensions.logistics.mfsadapter.event.EventSender.sendLocationChangeEvent(EventSender.java:150)
  at com.ssn.acx.extensions.logistics.mfsadapter.MFSTransactionWithSendingTrigger.commit(MFSTransactionWithSendingTrigger.java:109)
  at com.ssn.acx.core.common.transaction.GlobalTransactionImpl.commit(GlobalTransactionImpl.java:198)
  at com.ssn.acx.core.common.adapterservice.TelegramDispatcher.handleTelegram(TelegramDispatcher.java:306)
  at com.ssn.acx.core.common.adapterservice.TelegramDispatcher.dispatch(TelegramDispatcher.java:180)
  at com.ssn.acx.core.common.adapterservice.AbstractCollector.dispatch(AbstractCollector.java:81)
  at com.ssn.acx.api.common.adapterservice.TriggeredCollector.dispatch(TriggeredCollector.java:87)
  at com.ssn.acx.core.logistics.mfsadapter.MFSCollector.collectTelegrams(MFSCollector.java:122)
  at com.ssn.acx.core.logistics.mfsadapter.WakeUpListener.run(WakeUpListener.java:142)
  at java.lang.Thread.run(Thread.java:595)
Caused by: java.net.SocketException: Broken pipe
  at java.net.SocketOutputStream.socketWrite0(Native Method)
  at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:92)
  at java.net.SocketOutputStream.write(SocketOutputStream.java:136)
  at org.apache.activemq.transport.tcp.TcpBufferedOutputStream.flush(TcpBufferedOutputStream.java:108)
  at java.io.DataOutputStream.flush(DataOutputStream.java:106)
  at org.apache.activemq.transport.tcp.TcpTransport.oneway(TcpTransport.java:125)
  at org.apache.activemq.transport.InactivityMonitor.oneway(InactivityMonitor.java:141)
  at org.apache.activemq.transport.TransportFilter.oneway(TransportFilter.java:78)
  at org.apache.activemq.transport.WireFormatNegotiator.oneway(WireFormatNegotiator.java:77)
  at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:44)
  at org.apache.activemq.transport.ResponseCorrelator.oneway(ResponseCorrelator.java:60)
  at org.apache.activemq.ActiveMQConnection.asyncSendPacket(ActiveMQConnection.java:1092)
  ... 14 more
WARN  2006-08-17 12:47:12.555 EventSender                    :    -:     - Destroy EventSender and cleanup JMS resources failed! Caught: javax.jms.JMSException: Cannot write to the stream any more it has already been closed
javax.jms.JMSException: Cannot write to the stream any more it has already been closed
  at org.apache.activemq.util.JMSExceptionSupport.create(JMSExceptionSupport.java:57)
  at org.apache.activemq.ActiveMQConnection.asyncSendPacket(ActiveMQConnection.java:1094)
  at org.apache.activemq.ActiveMQSession.asyncSendPacket(ActiveMQSession.java:1655)
  at org.apache.activemq.ActiveMQMessageProducer.close(ActiveMQMessageProducer.java:315)
  at com.ssn.acx.extensions.logistics.mfsadapter.event.EventSender.destroy(EventSender.java:84)
  at com.ssn.acx.extensions.logistics.mfsadapter.event.EventSender.sendLocationChangeEvent(EventSender.java:155)
  at com.ssn.acx.extensions.logistics.mfsadapter.MFSTransactionWithSendingTrigger.commit(MFSTransactionWithSendingTrigger.java:109)
  at com.ssn.acx.core.common.transaction.GlobalTransactionImpl.commit(GlobalTransactionImpl.java:198)
  at com.ssn.acx.core.common.adapterservice.TelegramDispatcher.handleTelegram(TelegramDispatcher.java:306)
  at com.ssn.acx.core.common.adapterservice.TelegramDispatcher.dispatch(TelegramDispatcher.java:180)
  at com.ssn.acx.core.common.adapterservice.AbstractCollector.dispatch(AbstractCollector.java:81)
  at com.ssn.acx.api.common.adapterservice.TriggeredCollector.dispatch(TriggeredCollector.java:87)
  at com.ssn.acx.core.logistics.mfsadapter.MFSCollector.collectTelegrams(MFSCollector.java:122)
  at com.ssn.acx.core.logistics.mfsadapter.WakeUpListener.run(WakeUpListener.java:142)
  at java.lang.Thread.run(Thread.java:595)
Caused by: java.io.EOFException: Cannot write to the stream any more it has already been closed
  at org.apache.activemq.transport.tcp.TcpBufferedOutputStream.checkClosed(TcpBufferedOutputStream.java:131)
  at org.apache.activemq.transport.tcp.TcpBufferedOutputStream.write(TcpBufferedOutputStream.java:69)
  at java.io.DataOutputStream.writeInt(DataOutputStream.java:180)
  at org.apache.activemq.openwire.OpenWireFormat.marshal(OpenWireFormat.java:238)
  at org.apache.activemq.transport.tcp.TcpTransport.oneway(TcpTransport.java:124)
  at org.apache.activemq.transport.InactivityMonitor.oneway(InactivityMonitor.java:141)
  at org.apache.activemq.transport.TransportFilter.oneway(TransportFilter.java:78)
  at org.apache.activemq.transport.WireFormatNegotiator.oneway(WireFormatNegotiator.java:77)
  at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:44)
  at org.apache.activemq.transport.ResponseCorrelator.oneway(ResponseCorrelator.java:60)
  at org.apache.activemq.ActiveMQConnection.asyncSendPacket(ActiveMQConnection.java:1092)
  ... 13 more
INFO  2006-08-17 12:47:12.555 EventSender                    :    -:     - Destroyed event sender{code}
",Bug
AMQ-839,12481762,,"If a client closes a connection, and then fairly quicly tries to open a connection with the same clientid, this sometimes fails.  Apparently, the connection is not completely closed on the broker when the close on the connection completes.  This allows the client to try to open a conection and receive a client already connected exception.   The close connection should not return until the connection is actually closed, or at least an attribute on the collection should allow for setting if you want to wait or not.
",Bug
AMQ-835,12481760,,"when connection closing, connection doesn't remove itself from factoryStats. so every opened connection cause to grow memory. this can be fixed by adding factoryStats.removeConnection(this); in the close() method.",Bug
AMQ-962,12481939,,"Using Spring, configured a VM message broker (non-persistant) and a message consumer that reads messages from queue.

Messages are read from queue, but despite calling message.acknowledge(); messages remain on the queue (and consume memory).

I turned off optimiseAcknowledge.

May be related to bug# AMQ-716.

	  <amq:broker id=""broker"" useJmx=""true"" persistent=""false"">
	    <amq:transportConnectors>
	      <amq:transportConnector uri=""tcp://localhost:0"" />
	    </amq:transportConnectors>
	  </amq:broker>

	 <!-- a pooling based JMS provider -->
	  <bean id=""jmsFactory"" class=""org.apache.activemq.pool.PooledConnectionFactory"">
	    <property name=""connectionFactory"">
	      <bean class=""org.apache.activemq.ActiveMQConnectionFactory"">
	        <property name=""brokerURL"">
	          <value>vm://localhost</value>
	        </property>
	        <property name=""optimizeAcknowledge"">
	          <value>false</value>
	        </property>	        
	      </bean>
	    </property>
	  </bean>

	  <bean id=""simpleJmsTemplate"" class=""org.springframework.jms.core.JmsTemplate"">
	    <property name=""connectionFactory"">
	    	<ref local=""jmsFactory"" />
	    </property>
	  </bean>

",Bug
AMQ-1089,12481912,,"When using a transportconnector with a multicast discoveryagent a warning is shown.

config: <transportConnector  name=""default"" uri=""tcp://localhost:61616"" discoveryUri=""multicast://default""/>

WARN  MulticastDiscoveryAgent          -brokerName not set

When the transportconnector is started the MulticastDiscoveryAgent is created if it does not exist,
but the brokerName for this MulticastDiscoveryAgent is not set by the transportconnector.

See the code and the suggested modification to prevent this warning:

org.apache.activemq.broker.TransportConnector.java

<snip>
public void start() throws Exception {
        getServer().start();
        DiscoveryAgent da = getDiscoveryAgent();
        if( da!=null ) {
            da.registerService(getConnectUri().toString());
            //suggested modification start
            if(da.getBrokerName() == null || da.getBrokerName().length == 0) {
                   da.setBrokerName(this.getBroker().getBrokerName());
            }
            //suggested modification end
            da.start();
        }
        this.statusDector.start();
        log.info(""Connector ""+getName()+"" Started"");
    }
<snap>",Bug
AMQ-852,12482238,,"When you run ""my test program"" and end this process  with Ctrl+C/ kill/ kill -9 ( i mostly used Ctrl+C) sometimes during let say 100 iteration ""communication between client and broker is damaged"". This results in situation when after restart ( new pid ) client program is unable to create producer.  call to   consumer = rec_session->createConsumer( rec_queue );
 hangs client program. Sometimes this results with exception as you can see in output of my program. I think that this only occurs when the session is in ClienAckMode. From my point of view is there incorrect handling of situation when client receives message from broker and than terminates connection without ack/nack this receive in certatin circumstances ...

output:
 ./amqtest tcp://lxstaflik:61616 PH_Q_IN_10 PH_Q_OUT_10
Setting connection URL to 'tcp://lxstaflik:61616'
Setting receive queue name to 'PH_Q_IN_10'
Setting send queue name to 'PH_Q_OUT_10'
Init ...
Creating connection factory ...
Connection factory created, creating connection ...
Connection created, creating receive session...
receive session created, creating sending session ...
send session created, creating receive queue...'PH_Q_IN_10'
receive queue created, creating consumer for this queue ...
setting listener ...
Error on connection Unmarshal failed; unknown data structure type 49, at src/main/cpp/activemq/protocol/openwire/OpenWireMarshaller.cpp line 711Exiting read loop due to exception: Unmarshal failed; unknown data structure type 49, at src/main/cpp/activemq/protocol/openwire/OpenWireMarshaller.cpp line 711


Here is source code of my example:
#include <stdio.h>
#include <unistd.h>

#include <exception>
#include <iostream>
#include <map>
#include <string>

#include ""cms/IConnection.hpp""
#include ""cms/IConnectionFactory.hpp""
#include ""activemq/ConnectionFactory.hpp""
#include ""activemq/Connection.hpp""
#include ""activemq/Session.hpp""
#include ""ppr/TraceException.hpp""
#include ""ppr/net/Uri.hpp""
#include ""ppr/util/ifr/p""

using namespace apache::activemq;
using namespace apache::cms;
using namespace apache::ppr;
using namespace apache::ppr::net;
using namespace ifr;
using namespace std;


class ActiveMQTest : public IExceptionListener, public IMessageListener {
  private:
        p<Uri>                  uri;
        p<IConnectionFactory>   factory;
        p<IConnection>          connection;
        p<ISession>             rec_session;
        p<ISession>             snd_session;
        p<IQueue>               rec_queue;
        p<IQueue>               snd_queue;
        p<IMessageProducer>     producer;
        p<IMessageConsumer>     consumer;
        p<ITextMessage>         txtmsg;
        char szRecQueue[128];
        char szSndQueue[128];
  public:
        ActiveMQTest();
        virtual ~ActiveMQTest();
        virtual void setUri(const char *);
        virtual void init();
        virtual void done();
        virtual void onException(exception& error);
        virtual void onMessage(p<IMessage> message);
        virtual void ActiveMQTest::setSndQueue(const char *szQueue);
        virtual void ActiveMQTest::setRecQueue(const char *szQueue);
};

void ActiveMQTest::onMessage( p<IMessage> message) {
   p<ITextMessage>      snd_message;

   this->txtmsg = p_dyncast<ITextMessage>(message);

   p<string> string_request = txtmsg->getText();

   if (string_request != NULL ) {
     printf(""Received message : %s"",string_request->c_str());
   }

   sleep(10);

   message->acknowledge();

   snd_message = snd_session->createTextMessage() ;
   snd_message->setText(""TEST\n"") ;
   snd_message->setJMSPersistent(1);
   // Send message
   producer->send(message) ;
}

void ActiveMQTest::done() {
   rec_session->close();
   snd_session->close();
}

void ActiveMQTest::setUri(const char * uri) {
    this->uri = new Uri(uri) ;
}

void ActiveMQTest::setSndQueue(const char *szQueue) {
  strcpy(szSndQueue,szQueue);
}

void ActiveMQTest::setRecQueue(const char *szQueue) {
  strcpy(szRecQueue,szQueue);
}

ActiveMQTest::ActiveMQTest() {
  this->connection = NULL;
  this->rec_session = NULL;
  this->snd_session = NULL;
  memset(szRecQueue,0x0,sizeof(szRecQueue));
  memset(szSndQueue,0x0,sizeof(szSndQueue));
}

ActiveMQTest::~ActiveMQTest() {
}

void ActiveMQTest::init() {
  try {
    cout.rdbuf(cerr.rdbuf());
    printf(""1 Creating connection factory ... \n"");
    factory = new ConnectionFactory( uri );

    printf(""Connection factory created, creating connection ...\n"");
    connection = factory->createConnection();

    printf(""Connection created, creating receive session...\n"");
    p_cast<Connection>(connection)->setExceptionListener( smartify( this ) );
    //rec_session = connection->createSession(AutoAckMode);
    rec_session = connection->createSession(ClientAckMode);

    printf(""receive session created, creating sending session ...\n"");
    snd_session = connection->createSession(AutoAckMode);

    printf(""send session created, creating receive queue...'%s'\n"",szRecQueue);
    rec_queue = rec_session->getQueue( szRecQueue );


    printf(""receive queue created, creating consumer for this queue ...\n"");
    consumer = rec_session->createConsumer( rec_queue );


    printf(""setting listener ...\n"");
    snd_queue = snd_session->getQueue( szSndQueue );
    consumer->setMessageListener( smartify( this ) );
    producer = snd_session->createProducer( snd_queue );

    (p_dyncast<apache::activemq::Session>(rec_session))->dispatch(0);

    printf(""Init Ok.\n"");

  } catch ( TraceException& e ) {
    printf(""Error during init  ... \n"");
  }
}

void ActiveMQTest::onException( exception& error ) {
  printf(""Error on connection %s"", error.what() );
}


int main(int argc,char *argv[]) {
  ActiveMQTest* myAq;


  if ( argc < 3 ) {
    printf(""Usage: amqtest <connection_url> <receive_queue> <send_queue>\n"");
    exit(0);
  }

  myAq = new ActiveMQTest;

  printf(""Setting connection URL to '%s'\n"",argv[1]);
  myAq->setUri(argv[1]);

  printf(""Setting receive queue name to '%s'\n"",argv[2]);
  myAq->setRecQueue( argv[2] );

  printf(""Setting send queue name to '%s'\n"",argv[3]);
  myAq->setSndQueue( argv[3] );

  printf(""Init ...\n"");
  myAq->init();


int i=0;
  while( i < 3000 ) {
    printf(""Idle ... \n"");
    sleep( 1 );
    i++;
  }

  myAq->done();

  return 0;
}


",Bug
AMQ-1114,12481015,,"ActiveMQ: Through 'jconsole' we can view all the java components which ever is active. So by this way, we can see the particular queue and also we can able to find how many customers are listening.

But I want to manage the queue, like I want to kill a particular queue.  Can anybody help me how to proceed with?

It's pleasure to explain more if you are not clear.

Thanks in advance
Shekar",Bug
AMQ-898,12481864,,"We routinely have our message distribution locked up permanently and without means of recovery by a socketWrite0 call that hangs indefinitely in a thread holding a number of the Active MQ locks.  Here is a stack trace of such a locked up thread:

        at java.net.SocketOutputStream.socketWrite0(Native Method)
        at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:92)
        at java.net.SocketOutputStream.write(SocketOutputStream.java:136)
        at org.apache.activemq.transport.tcp.TcpBufferedOutputStream.write(TcpBufferedOutputStream.java:95)
        at java.io.DataOutputStream.write(DataOutputStream.java:90)
        - locked <0x4bc298c8> (a java.io.DataOutputStream)
        at org.apache.activemq.openwire.v1.BaseDataStreamMarshaller.tightMarshalByteSequence2(BaseDataStreamMarshaller.java:403)
        at org.apache.activemq.openwire.v1.MessageMarshaller.tightMarshal2(MessageMarshaller.java:160)
        at org.apache.activemq.openwire.v1.ActiveMQMessageMarshaller.tightMarshal2(ActiveMQMessageMarshaller.java:88)
        at org.apache.activemq.openwire.v1.ActiveMQObjectMessageMarshaller.tightMarshal2(ActiveMQObjectMessageMarshaller.java:88)
        at org.apache.activemq.openwire.OpenWireFormat.marshal(OpenWireFormat.java:240)
        at org.apache.activemq.transport.tcp.TcpTransport.oneway(TcpTransport.java:124)
        at org.apache.activemq.transport.InactivityMonitor.oneway(InactivityMonitor.java:141)
        at org.apache.activemq.transport.TransportFilter.oneway(TransportFilter.java:78)
        at org.apache.activemq.transport.WireFormatNegotiator.oneway(WireFormatNegotiator.java:77)
        at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:44)
        - locked <0x4bac2b80> (a java.lang.Object)
        at org.apache.activemq.transport.ResponseCorrelator.oneway(ResponseCorrelator.java:60)
        at org.apache.activemq.ActiveMQConnection.asyncSendPacket(ActiveMQConnection.java:1111)
        at org.apache.activemq.ActiveMQSession.send(ActiveMQSession.java:1553)
        at org.apache.activemq.ActiveMQMessageProducer.send(ActiveMQMessageProducer.java:462)
        at com.hb.jms.api.util.JmsSession.sendObjects(JmsSession.java:345)
        - locked <0x4aca1230> (a org.apache.activemq.ActiveMQSession)
        at com.hb.jms.api.util.JmsSession.sendObjects(JmsSession.java:307)
        at com.hb.jms.api.util.JmsSession$QueueProcessor.sendFromSessionQueue(JmsSession.java:1002)
        - locked <0x6adc9f80> (a com.hb.jms.api.util.JmsSession$SessionQueue)
        at com.hb.jms.api.util.JmsSession$QueueProcessor.run(JmsSession.java:981)
        at java.lang.Thread.run(Thread.java:595)",Bug
AMQ-774,12482963,,"I've been through the doc:

http://www.activemq.org/site/how-to-deploy-activemq-ra-versionrar-to-weblogic.html

However, when I attempt to deploy the broker on Weblogic 9.1 (actually, when i click on ""activate changes""), i get the following error:

weblogic.connector.exception.RAException: There are 1 nested errors: javax.resource.spi.ResourceAdapterInternalException: Failed to startup an embedded broker: file://../broker-config.xml, due to: java.io.IOException: Could load file factory:java.io.IOException: Could not find factory class for resource: META-INF/services/org/apache/activemq/broker/file at org.apache.activemq.ra.ActiveMQResourceAdapter.start(ActiveMQResourceAdapter.java:82) at weblogic.connector.security.layer.AdapterLayer.start(AdapterLayer.java:979) at weblogic.connector.common.RAInstanceManager.initialize(RAInstanceManager.java:1139) at weblogic.connector.common.RAInstanceManager.<init>(RAInstanceManager.java:333) at weblogic.connector.deploy.ConnectorModule.prepare(ConnectorModule.java:178) at weblogic.application.internal.flow.ModuleListenerInvoker.prepare(ModuleListenerInvoker.java:90) at weblogic.application.internal.flow.DeploymentCallbackFlow$1.next(DeploymentCallbackFlow.java:318) at weblogic.application.utils.StateMachineDriver.nextState(StateMachineDriver.java:26) at weblogic.application.internal.flow.DeploymentCallbackFlow.prepare(DeploymentCallbackFlow.java:53) at weblogic.application.internal.flow.DeploymentCallbackFlow.prepare(DeploymentCallbackFlow.java:43) at weblogic.application.internal.BaseDeployment$1.next(BaseDeployment.java:620) at weblogic.application.utils.StateMachineDriver.nextState(StateMachineDriver.java:26) at weblogic.application.internal.BaseDeployment.prepare(BaseDeployment.java:231) at weblogic.application.internal.DeploymentStateChecker.prepare(DeploymentStateChecker.java:147) at weblogic.deploy.internal.targetserver.AppContainerInvoker.prepare(AppContainerInvoker.java:61) at weblogic.deploy.internal.targetserver.operations.ActivateOperation.createAndPrepareContainer(ActivateOperation.java:183) at weblogic.deploy.internal.targetserver.operations.ActivateOperation.doPrepare(ActivateOperation.java:84) at weblogic.deploy.internal.targetserver.operations.AbstractOperation.prepare(AbstractOperation.java:219) at weblogic.deploy.internal.targetserver.DeploymentManager.handleDeploymentPrepare(DeploymentManager.java:750) at weblogic.deploy.internal.targetserver.DeploymentManager.prepareDeploymentList(DeploymentManager.java:1209) at weblogic.deploy.internal.targetserver.DeploymentManager.handlePrepare(DeploymentManager.java:246) at weblogic.deploy.internal.targetserver.DeploymentServiceDispatcher.prepare(DeploymentServiceDispatcher.java:157) at weblogic.deploy.service.internal.targetserver.DeploymentReceiverCallbackDeliverer.doPrepareCallback(DeploymentReceiverCallbackDeliverer.java:157) at weblogic.deploy.service.internal.targetserver.DeploymentReceiverCallbackDeliverer.access$000(DeploymentReceiverCallbackDeliverer.java:12) at weblogic.deploy.service.internal.targetserver.DeploymentReceiverCallbackDeliverer$1.run(DeploymentReceiverCallbackDeliverer.java:45) at weblogic.work.ServerWorkManagerImpl$WorkAdapterImpl.run(ServerWorkManagerImpl.java:518) at weblogic.work.ExecuteThread.execute(ExecuteThread.java:207) at weblogic.work.ExecuteThread.run(ExecuteThread.java:179) Caused by: java.io.IOException: Could load file factory:java.io.IOException: Could not find factory class for resource: META-INF/services/org/apache/activemq/broker/file at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:24) at org.apache.activemq.broker.BrokerFactory.createBrokerFactoryHandler(BrokerFactory.java:42) at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:55) at org.apache.activemq.ra.ActiveMQResourceAdapter.start(ActiveMQResourceAdapter.java:79) ... 27 more Caused by: java.io.IOException: Could not find factory class for resource: META-INF/services/org/apache/activemq/broker/file at org.apache.activeio.util.FactoryFinder.doFindFactoryProperies(FactoryFinder.java:87) at org.apache.activeio.util.FactoryFinder.newInstance(FactoryFinder.java:57) at org.apache.activeio.util.FactoryFinder.newInstance(FactoryFinder.java:46) at org.apache.activemq.broker.BrokerFactory.createBrokerFactoryHandler(BrokerFactory.java:40) ... 29 more",Bug
AMQ-832,12482981,,"I'm sending and receiving messages entirely through STOMP and messages are getting stuck in the queue (using 4.0.1).

This is pretty inconvenient as when I restart my processes and they re-subscribe, the messages get re-delivered to them.

incubator-activemq-4.0.1/bin$ ./browse --amqurl tcp://localhost:61616 something/game/0
JMS_CUSTOM_FIELD:_timestamp = 2006-07-19 10:23:43.847049
JMS_HEADER_FIELD:JMSDestination = something/game/0
JMS_HEADER_FIELD:JMSDeliveryMode = non-persistent
JMS_HEADER_FIELD:JMSMessageID = ID:hotei-60326-1153156802410-3:589:-1:1:8
JMS_BODY_FIELD:JMSBytes:1 =
JMS_HEADER_FIELD:JMSExpiration = 0
JMS_HEADER_FIELD:JMSPriority = 0
JMS_HEADER_FIELD:JMSRedelivered = false
JMS_HEADER_FIELD:JMSTimestamp = 0

JMS_CUSTOM_FIELD:_timestamp = 2006-07-19 10:23:45.535995
JMS_HEADER_FIELD:JMSDestination = something/game/0
JMS_HEADER_FIELD:JMSDeliveryMode = non-persistent
JMS_HEADER_FIELD:JMSMessageID = ID:hotei-60326-1153156802410-3:589:-1:1:9
JMS_BODY_FIELD:JMSBytes:1 =
JMS_HEADER_FIELD:JMSExpiration = 0
JMS_HEADER_FIELD:JMSPriority = 0
JMS_HEADER_FIELD:JMSRedelivered = false
JMS_HEADER_FIELD:JMSTimestamp = 0

I'm not using durable subscriptions, persistence messaging, etc.

Is there something that I'm doing wrong that might cause this?

The messages randomly get stuck .. it isn't always repeatable and is much less frequent with 4.0.1 than it was with 4.0 prereleases.

This software is going into production soon, so would it be safe to try out a 4.0.2 or 4.1 snapshot?  Would they be likely to fix this given the current sets of changes in them?
",Bug
AMQ-1035,12483141,,"Hi,

We have an AMQ Broker [4.1.0 incubator SNAPSHOT] running as a standalone java application.
 
The AMQ Broker has Authentication and Authorization plugins installed by virtue of which only users with the correct credentials may get authenticated onto the Broker, and further Access roles and permissions with respect to users and admin have been set up using the Authorization plugin.

The above broker supports both TCP and STOMP.


CASE 1:

When we connect using TCP and a JAVA written client, both the plugins work correctly and as expected.


CASE 2:

When we connect using STOMP and the Java written client:

 - The program stalls at ""connection.start(); Does not proceed further from here...


CASE 3:

When we use C++ and STOMP following are our observations:


[1] When connecting using the STOMP client with incorrect credentials, the AMQ Broker throws SecurityException [which is expected], however the STOMP client receives a message 'CONNECTED'

[2] The STOMP client does not get notified that there was a SecurityException while connecting [when connecting using wrong credentials].



Questions are:

[1] Why does the program execution not proceed in case of CASE 2 ?

[2] How does the C++ STOMP client get notified of any Authentication or Authorization exceptions that may be generated at the AMQ Broker end ?

Thanks in anticipation.

Aditya",Bug
AMQ-1604,12483410,,"
(1) Please rename the activemq-all-<version>.jar to just activemq-all.jar. It will make it easier for users to switch version. We would generally put the activemq release on a shared drive and change the pointer ""prod"", ""dev"" or ""staging"" to point to the new directory. It would be nice if the activemq-all.jar was present in all releases so the link would be the only thing I would need to change.

(2) Please change the log4j appender:
log4j.appender.out.file=${activemq.base}/data/activemq.log 
Oftentimes activemq is in a protected directory on a network drive (${activemq.base}/) so many machines can use it. It would be better if the log file would log to /tmp  or something else the user can configure. Maybe it can be configured in the activemq.xml file? (I always have to change this every time we upgrade to a new version)",Bug
AMQ-1256,12482043,,"On the bulletin board I was told that I can turn off advisory topics because the advisory topics don't disappear for temporary queues and it was impacting performance. Turning off advisory queues DISABLES access to temporary queues. When advisorySupport=""false"" any publishing to a temporary queue results in the following exception (even though the queue is open & available):

javax.jms.JMSException: Cannot publish to a deleted Destination: temp-queue://ID:rpc9-4350-1180554015568-0:0:1
	at org.apache.activemq.ActiveMQSession.send(ActiveMQSession.java:1498)
	at org.apache.activemq.ActiveMQMessageProducer.send(ActiveMQMessageProducer.java:465)
	at org.apache.activemq.ActiveMQMessageProducer.send(ActiveMQMessageProducer.java:415)",Bug
AMQ-1239,12481262,,"Seems like not committed file :(
Build log

H:\workspace\activemq-4.1>mvn -Dmaven.test.skip=true install
[INFO] Scanning for projects...
[INFO] Reactor build order:
[INFO]   ActiveMQ
[INFO]   ActiveMQ :: JAAS
[INFO]   ActiveMQ :: Core
[INFO]   ActiveMQ :: Console
[INFO]   Openwire Generator
[INFO]   ActiveMQ :: Optional
[INFO]   ActiveMQ :: RA
[INFO]   ActiveMQ :: RAR
[INFO]   ActiveMQ :: Atomikos System Test
[INFO]   ActiveMQ Tooling
[INFO]   ActiveMQ :: Memory Usage Test Plugin
[INFO]   ActiveMQ :: Performance Test Plugin
[INFO]   ActiveMQ :: StartUp Plugin
[INFO]   ActiveMQ :: Web
[INFO]   ActiveMQ :: Web Demo
[INFO]   ActiveMQ :: XMPP
[INFO]   ActiveMQ :: Web Console
[INFO]   ActiveMQ :: Assembly
[INFO] ----------------------------------------------------------------------------
[INFO] Building ActiveMQ
[INFO]    task-segment: [install]
[INFO] ----------------------------------------------------------------------------
[INFO] [site:attach-descriptor]
[INFO] [install:install]
[INFO] Installing H:\workspace\activemq-4.1\pom.xml to C:\Documents and Settings\Mykola Palienko\.m2\repository\org\apa
he\activemq\activemq-parent\4.1-SNAPSHOT\activemq-parent-4.1-SNAPSHOT.pom
[INFO] [maven-one-plugin:install-maven-one-repository {execution: default}]
[INFO] Installing H:\workspace\activemq-4.1\pom.xml to C:\Documents and Settings\Mykola Palienko\.maven\repository\org.
pache.activemq\poms\activemq-parent-4.1-SNAPSHOT.pom
[INFO] ----------------------------------------------------------------------------
[INFO] Building ActiveMQ :: JAAS
[INFO]    task-segment: [install]
[INFO] ----------------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
Downloading: http://people.apache.org/repo/m2-incubating-repository/directory-protocols/kerberos-protocol/0.5/kerberos-
rotocol-0.5.pom
Downloading: http://repo1.maven.org/maven2/directory-protocols/kerberos-protocol/0.5/kerberos-protocol-0.5.pom
Downloading: http://people.apache.org/repo/m2-incubating-repository/directory-protocols/ldap-protocol/0.9.2/ldap-protoc
l-0.9.2.pom
Downloading: http://repo1.maven.org/maven2/directory-protocols/ldap-protocol/0.9.2/ldap-protocol-0.9.2.pom
[INFO] [compiler:compile]
[INFO] Nothing to compile - all classes are up to date
[INFO] [resources:testResources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:testCompile]
[INFO] Not compiling test sources
[INFO] [surefire:test]
[INFO] Tests are skipped.
[INFO] [jar:jar]
[INFO] Building jar: H:\workspace\activemq-4.1\activemq-jaas\target\activemq-jaas-4.1-SNAPSHOT.jar
[INFO] [install:install]
[INFO] Installing H:\workspace\activemq-4.1\activemq-jaas\target\activemq-jaas-4.1-SNAPSHOT.jar to C:\Documents and Set
ings\Mykola Palienko\.m2\repository\org\apache\activemq\activemq-jaas\4.1-SNAPSHOT\activemq-jaas-4.1-SNAPSHOT.jar
[INFO] [maven-one-plugin:install-maven-one-repository {execution: default}]
[INFO] Installing H:\workspace\activemq-4.1\activemq-jaas\target\activemq-jaas-4.1-SNAPSHOT.jar to C:\Documents and Set
ings\Mykola Palienko\.maven\repository\org.apache.activemq\jars\activemq-jaas-4.1-SNAPSHOT.jar
[INFO] ----------------------------------------------------------------------------
[INFO] Building ActiveMQ :: Core
[INFO]    task-segment: [install]
[INFO] ----------------------------------------------------------------------------
[INFO] artifact org.codehaus.mojo:build-helper-maven-plugin: checking for updates from apache.incubating.releases
[WARNING] While downloading javacc:javacc:3.2
  This artifact has been relocated to net.java.dev.javacc:javacc:3.2.


[INFO] [javacc:javacc {execution: default}]
[INFO] Nothing to process - all grammars are up to date
[INFO] [xbean:mapping {execution: default}]
Checking: org.apache.activemq.memory.UsageManager
Checking: org.apache.activemq.store.rapid.RapidPersistenceAdapter
Checking: org.apache.activemq.store.jdbc.adapter.ImageBasedJDBCAdaptor
Checking: org.apache.activemq.store.jdbc.adapter.InformixJDBCAdapter
Checking: org.apache.activemq.store.jdbc.adapter.StreamJDBCAdapter
Checking: org.apache.activemq.store.jdbc.adapter.AxionJDBCAdapter
Checking: org.apache.activemq.store.jdbc.adapter.BlobJDBCAdapter
Checking: org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter
Checking: org.apache.activemq.store.jdbc.adapter.OracleJDBCAdapter
Checking: org.apache.activemq.store.jdbc.adapter.BytesJDBCAdapter
Checking: org.apache.activemq.store.jdbc.adapter.DB2JDBCAdapter
Checking: org.apache.activemq.store.jdbc.Statements
Checking: org.apache.activemq.store.jdbc.JDBCPersistenceAdapter
Checking: org.apache.activemq.store.memory.MemoryPersistenceAdapter
Checking: org.apache.activemq.store.journal.JournalPersistenceAdapter
Checking: org.apache.activemq.store.journal.QuickJournalPersistenceAdapter
Checking: org.apache.activemq.store.kahadaptor.KahaPersistenceAdapter
Checking: org.apache.activemq.store.PersistenceAdapterFactoryBean
Checking: org.apache.activemq.xbean.XBeanBrokerService
Checking: org.apache.activemq.spring.ActiveMQConnectionFactory
Checking: org.apache.activemq.spring.ActiveMQXAConnectionFactory
Checking: org.apache.activemq.security.LDAPAuthorizationMap
Checking: org.apache.activemq.security.JaasCertificateAuthenticationPlugin
Checking: org.apache.activemq.security.DefaultAuthorizationMap
Checking: org.apache.activemq.security.SimpleAuthenticationPlugin
Checking: org.apache.activemq.security.SimpleAuthorizationMap
Checking: org.apache.activemq.security.AuthorizationPlugin
Checking: org.apache.activemq.security.AuthorizationEntry
Checking: org.apache.activemq.security.JaasAuthenticationPlugin
Checking: org.apache.activemq.proxy.ProxyConnector
Checking: org.apache.activemq.broker.region.virtual.CompositeTopic
Checking: org.apache.activemq.broker.region.virtual.VirtualTopic
Checking: org.apache.activemq.broker.region.virtual.CompositeQueue
Checking: org.apache.activemq.broker.region.virtual.VirtualDestinationInterceptor
Checking: org.apache.activemq.broker.region.group.SimpleMessageGroupMapFactory
Checking: org.apache.activemq.broker.region.group.MessageGroupHashBucketFactory
Checking: org.apache.activemq.broker.region.policy.FixedSizedSubscriptionRecoveryPolicy
Checking: org.apache.activemq.broker.region.policy.StrictOrderDispatchPolicy
Checking: org.apache.activemq.broker.region.policy.TimedSubscriptionRecoveryPolicy
Checking: org.apache.activemq.broker.region.policy.VMPendingQueueMessageStoragePolicy
Checking: org.apache.activemq.broker.region.policy.PrefetchRatePendingMessageLimitStrategy
Checking: org.apache.activemq.broker.region.policy.QueryBasedSubscriptionRecoveryPolicy
Checking: org.apache.activemq.broker.region.policy.IndividualDeadLetterStrategy
Checking: org.apache.activemq.broker.region.policy.LastImageSubscriptionRecoveryPolicy
Checking: org.apache.activemq.broker.region.policy.FixedCountSubscriptionRecoveryPolicy
Checking: org.apache.activemq.broker.region.policy.OldestMessageWithLowestPriorityEvictionStrategy
Checking: org.apache.activemq.broker.region.policy.NoSubscriptionRecoveryPolicy
Checking: org.apache.activemq.broker.region.policy.FilePendingDurableSubscriberMessageStoragePolicy
Checking: org.apache.activemq.broker.region.policy.PolicyEntry
Checking: org.apache.activemq.broker.region.policy.RoundRobinDispatchPolicy
Checking: org.apache.activemq.broker.region.policy.OldestMessageEvictionStrategy
Checking: org.apache.activemq.broker.region.policy.VMPendingDurableSubscriberMessageStoragePolicy
Checking: org.apache.activemq.broker.region.policy.ConstantPendingMessageLimitStrategy
Checking: org.apache.activemq.broker.region.policy.SharedDeadLetterStrategy
Checking: org.apache.activemq.broker.region.policy.SimpleDispatchPolicy
Checking: org.apache.activemq.broker.region.policy.PolicyMap
Checking: org.apache.activemq.broker.region.policy.StorePendingDurableSubscriberMessageStoragePolicy
Checking: org.apache.activemq.broker.jmx.ManagementContext
Checking: org.apache.activemq.broker.ft.MasterConnector
Checking: org.apache.activemq.broker.view.ConnectionDotFilePlugin
Checking: org.apache.activemq.broker.view.DestinationDotFilePlugin
Checking: org.apache.activemq.broker.util.TimeStampingBrokerPlugin
Checking: org.apache.activemq.broker.util.MulticastTraceBrokerPlugin
Checking: org.apache.activemq.broker.util.LoggingBrokerPlugin
Checking: org.apache.activemq.broker.util.UDPTraceBrokerPlugin
Checking: org.apache.activemq.broker.util.CommandAgent
Checking: org.apache.activemq.broker.TransportConnector
Checking: org.apache.activemq.network.jms.InboundQueueBridge
Checking: org.apache.activemq.network.jms.OutboundQueueBridge
Checking: org.apache.activemq.network.jms.JmsTopicConnector
Checking: org.apache.activemq.network.jms.JmsQueueConnector
Checking: org.apache.activemq.network.jms.InboundTopicBridge
Checking: org.apache.activemq.network.jms.SimpleJmsMessageConvertor
Checking: org.apache.activemq.network.jms.OutboundTopicBridge
Checking: org.apache.activemq.network.ForwardingBridge
Checking: org.apache.activemq.network.DemandForwardingBridge
Checking: org.apache.activemq.network.MulticastNetworkConnector
Checking: org.apache.activemq.network.CompositeDemandForwardingBridge
Checking: org.apache.activemq.network.DiscoveryNetworkConnector
Checking: org.apache.activemq.command.ActiveMQQueue
Checking: org.apache.activemq.command.ActiveMQTopic
Checking: org.apache.activemq.filter.DefaultDestinationMapEntry
Checking: org.apache.activemq.ActiveMQPrefetchPolicy
Checking: org.apache.activemq.RedeliveryPolicy
[INFO] Generating META-INF properties file: H:\workspace\activemq-4.1\activemq-core\target\xbean\META-INF\services\org\
pache\xbean\spring\http\activemq.org\config\1.0 for namespace: http://activemq.org/config/1.0
[INFO] Generating Spring 2.0 handler mapping: H:\workspace\activemq-4.1\activemq-core\target\xbean\META-INF\spring.hand
ers for namespace: http://activemq.org/config/1.0
[INFO] Generating Spring 2.0 schema mapping: H:\workspace\activemq-4.1\activemq-core\target\xbean\META-INF\spring.schem
s for namespace: http://activemq.org/config/1.0
[INFO] Generating HTML documentation file: H:\workspace\activemq-4.1\activemq-core\target\xbean\activemq.xsd.html for n
mespace: http://activemq.org/config/1.0
Warning, could not load class: org.apache.activemq.command.ActiveMQDestination: java.lang.ClassNotFoundException: org.a
ache.activemq.command.ActiveMQDestination
Warning, could not load class: org.apache.activemq.security.AuthorizationEntry: java.lang.ClassNotFoundException: org.a
ache.activemq.security.AuthorizationEntry
Warning, could not load class: org.apache.activemq.broker.BrokerService: java.lang.ClassNotFoundException: org.apache.a
tivemq.broker.BrokerService
Warning, could not load class: org.apache.activemq.command.ActiveMQDestination: java.lang.ClassNotFoundException: org.a
ache.activemq.command.ActiveMQDestination
Warning, could not load class: org.apache.activemq.network.jms.JmsConnector: java.lang.ClassNotFoundException: org.apac
e.activemq.network.jms.JmsConnector
Warning, could not load class: org.apache.activemq.network.jms.JmsConnector: java.lang.ClassNotFoundException: org.apac
e.activemq.network.jms.JmsConnector
Warning, could not load class: org.apache.activemq.broker.BrokerService: java.lang.ClassNotFoundException: org.apache.a
tivemq.broker.BrokerService
Warning, could not load class: org.apache.activemq.broker.BrokerService: java.lang.ClassNotFoundException: org.apache.a
tivemq.broker.BrokerService
Warning, could not load class: org.apache.activemq.broker.BrokerService: java.lang.ClassNotFoundException: org.apache.a
tivemq.broker.BrokerService
Warning, could not load class: org.apache.activemq.broker.BrokerService: java.lang.ClassNotFoundException: org.apache.a
tivemq.broker.BrokerService
Warning, could not load class: org.apache.activemq.network.DemandForwardingBridgeSupport: java.lang.ClassNotFoundExcept
on: org.apache.activemq.network.DemandForwardingBridgeSupport
Warning, could not load class: org.apache.activemq.network.jms.JmsConnector: java.lang.ClassNotFoundException: org.apac
e.activemq.network.jms.JmsConnector
Warning, could not load class: org.apache.activemq.network.jms.JmsConnector: java.lang.ClassNotFoundException: org.apac
e.activemq.network.jms.JmsConnector
Warning, could not load class: org.apache.activemq.command.ActiveMQDestination: java.lang.ClassNotFoundException: org.a
ache.activemq.command.ActiveMQDestination
Warning, could not load class: org.apache.activemq.broker.region.policy.PolicyEntry: java.lang.ClassNotFoundException:
rg.apache.activemq.broker.region.policy.PolicyEntry
Warning, could not load class: org.apache.activemq.command.ActiveMQDestination: java.lang.ClassNotFoundException: org.a
ache.activemq.command.ActiveMQDestination
[INFO] Generating XSD file: H:\workspace\activemq-4.1\activemq-core\target\xbean\activemq.xsd for namespace: http://act
vemq.org/config/1.0
[INFO] Generating WIKI documentation file: H:\workspace\activemq-4.1\activemq-core\target\xbean\activemq.xsd.wiki for n
mespace: http://activemq.org/config/1.0
Warning, could not load class: org.apache.activemq.command.ActiveMQDestination: java.lang.ClassNotFoundException: org.a
ache.activemq.command.ActiveMQDestination
Warning, could not load class: org.apache.activemq.network.jms.JmsConnector: java.lang.ClassNotFoundException: org.apac
e.activemq.network.jms.JmsConnector
Warning, could not load class: org.apache.activemq.network.NetworkConnector: java.lang.ClassNotFoundException: org.apac
e.activemq.network.NetworkConnector
Warning, could not load class: org.apache.activemq.command.ActiveMQDestination: java.lang.ClassNotFoundException: org.a
ache.activemq.command.ActiveMQDestination
Warning, could not load class: org.apache.activemq.command.ActiveMQDestination: java.lang.ClassNotFoundException: org.a
ache.activemq.command.ActiveMQDestination
Warning, could not load class: org.apache.activemq.command.ActiveMQDestination: java.lang.ClassNotFoundException: org.a
ache.activemq.command.ActiveMQDestination
Warning, could not load class: org.apache.activemq.command.ActiveMQDestination: java.lang.ClassNotFoundException: org.a
ache.activemq.command.ActiveMQDestination
Warning, could not load class: org.apache.activemq.command.ActiveMQDestination: java.lang.ClassNotFoundException: org.a
ache.activemq.command.ActiveMQDestination
Warning, could not load class: org.apache.activemq.command.ActiveMQDestination: java.lang.ClassNotFoundException: org.a
ache.activemq.command.ActiveMQDestination
Warning, could not load class: org.apache.activemq.command.ActiveMQDestination: java.lang.ClassNotFoundException: org.a
ache.activemq.command.ActiveMQDestination
Warning, could not load class: org.apache.activemq.command.ActiveMQDestination: java.lang.ClassNotFoundException: org.a
ache.activemq.command.ActiveMQDestination
Warning, could not load class: org.apache.activemq.network.jms.InboundQueueBridge: java.lang.ClassNotFoundException: or
.apache.activemq.network.jms.InboundQueueBridge
Warning, could not load class: org.apache.activemq.network.jms.OutboundQueueBridge: java.lang.ClassNotFoundException: o
g.apache.activemq.network.jms.OutboundQueueBridge
Warning, could not load class: org.apache.activemq.command.ActiveMQDestination: java.lang.ClassNotFoundException: org.a
ache.activemq.command.ActiveMQDestination
Warning, could not load class: org.apache.activemq.command.ActiveMQDestination: java.lang.ClassNotFoundException: org.a
ache.activemq.command.ActiveMQDestination
[INFO] ...done.
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Compiling 329 source files to H:\workspace\activemq-4.1\activemq-core\target\classes
[INFO] ------------------------------------------------------------------------
[ERROR] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Compilation failure

H:\workspace\activemq-4.1\activemq-core\src\main\java\org\apache\activemq\thread\Scheduler.java:[55,34] cannot find sym
ol
symbol  : class RunnableScheduledFuture
location: class org.apache.activemq.thread.Scheduler

H:\workspace\activemq-4.1\activemq-core\src\main\java\org\apache\activemq\thread\Scheduler.java:[56,33] cannot find sym
ol
symbol  : class RunnableScheduledFuture
location: class org.apache.activemq.thread.Scheduler


[INFO] ------------------------------------------------------------------------
[INFO] For more information, run Maven with the -e switch
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2 minutes 28 seconds
[INFO] Finished at: Tue May 01 13:15:49 EEST 2007
[INFO] Final Memory: 26M/55M
[INFO] ------------------------------------------------------------------------",Bug
AMQ-1090,12482837,,"When running ActiveMQ as a service using the Java Wrapper Service, the CPU usage is 100%.  My logging levels are set to ERROR and there is nothing in the log.  I have tried both methods of JWS: WrapperSimpleApp and WrapperStartStopApp.  Perhaps this is a JWS issue but I've been searching around and anything I've found points back to the application.

The workaround is to not run ActiveMQ as a service but that is not the optimal solution in a production environment where ActiveMQ needs to start upon re-boot of the machine.",Bug
AMQ-941,12481948,,"Exception in thread ""ActiveMQ Transport Server: tcp://localhost:61616"" java.lang.OutOfMemoryError: Java heap space
        at org.apache.activemq.openwire.OpenWireFormat.<init>(OpenWireFormat.java:60)
        at org.apache.activemq.openwire.OpenWireFormat.<init>(OpenWireFormat.java:65)
        at org.apache.activemq.openwire.OpenWireFormatFactory.createWireFormat(OpenWireFormatFactory.java:58)
        at org.apache.activemq.transport.tcp.TcpTransportServer.run(TcpTransportServer.java:164)
        at java.lang.Thread.run(Thread.java:619)

Java heap histogram (top 50 only):

num   #instances    #bytes  class name
--------------------------------------
  1:       650    42603600  [Lorg.apache.activemq.command.DataStructure;
  2:      7388     9818352  [B
  3:     32554     3305656  <constMethodKlass>
  4:     32554     2866464  <methodKlass>
  5:     26761     2321496  [Ljava.util.HashMap$Entry;
  6:     41208     1935824  <symbolKlass>
  7:     26582     1605224  [Ljava.lang.Object;
  8:     14316     1573672  [C
  9:      2777     1528528  <constantPoolKlass>
 10:     38976     1247232  edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap$Segment
 11:      2777     1237080  <instanceKlassKlass>
 12:     26731     1069240  java.util.HashMap
 13:      2458      992592  <constantPoolCacheKlass>
 14:     24395      780640  org.apache.activemq.filter.DestinationMapNode
 15:     32011      768264  java.util.HashMap$Entry
 16:     38976      651464  [Ledu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap$HashEntry;
 17:     38984      623744  edu.emory.mathcs.backport.java.util.concurrent.locks.ReentrantLock$NonfairSync
 18:     25303      607272  java.util.ArrayList
 19:     23150      555600  java.lang.String
 20:      3100      297600  java.lang.Class
 21:      3536      266144  [I
 22:        61      250832  [Lorg.apache.activemq.command.ConsumerId;
 23:      3452      226136  [S
 24:      4446      207928  [[I
 25:      2436      194880  [Ledu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap$Segment;
 26:      2436      116928  edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap
 27:       314      100480  <objArrayKlassKlass>
 28:      3593       86232  edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap$HashEntry
 29:       464       77952  org.apache.activemq.command.ActiveMQMessage
 30:      2328       71616  [Ljava.lang.String;
 31:      1453       69744  org.apache.activemq.command.ProducerId
 32:      1434       68832  org.apache.activemq.management.CountStatisticImpl
 33:      1645       65800  org.apache.activemq.command.SessionId
 34:      1257       60336  org.apache.activemq.command.ActiveMQTempQueue
 35:       658       52640  java.lang.reflect.Method
 36:      3251       52016  edu.emory.mathcs.backport.java.util.concurrent.atomic.AtomicBoolean
 37:      1235       49400  org.apache.activemq.command.ProducerInfo
 38:      1928       46272  java.util.Hashtable$Entry
 39:      1382       44224  java.lang.ref.SoftReference
 40:       334       40080  java.net.SocksSocketImpl
 41:       350       39200  java.lang.Thread
 42:       647       36232  edu.emory.mathcs.backport.java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask
 43:       853       34120  org.apache.activemq.command.MessageId
 44:       526       33664  java.lang.reflect.Constructor
 45:       323       33592  org.apache.activemq.broker.jmx.ManagedTransportConnection
 46:      1365       32760  javax.management.ObjectName$Property
 47:       322       30912  org.apache.activemq.transport.tcp.TcpTransport
 48:      1196       28704  org.apache.activemq.state.ProducerState
 49:       390       28080  org.apache.activemq.broker.region.IndirectMessageReference
 50:       348       27840  [Ljava.lang.ThreadLocal$ThreadLocalMap$Entry;
",Bug
AMQ-1137,12481933,,"h2. USE CASE
# Take 4.1.0 Release from http://people.apache.org/repo/m2-incubating-repository/org/apache/activemq/apache-activemq/4.1.0-incubator/apache-activemq-4.1.0-incubator.zip and unzip on a Linux box (SuSE 10.1, Kernel 2.6.16 with 2GB RAM and  Xeon(TM) CPU 2.80GHz
# Edit {{conf/activemq.xml}} and disable ssl and stomp transport
# Start broker: {{apache-activemq-4.1.0-incubator/bin> java -jar run.jar}}
# Edit {{example/build.xml}} and set max=1000 (send 1000 messages to queue) and *transacted=true*
# Run producer: {{ant producer}}

h2. Results

{code:title=broker logfile}
ACTIVEMQ_HOME: /home/janknecht/tmp/apache-activemq-4.1.0-incubator
Loading message broker from: xbean:activemq.xml
INFO  BrokerService                  - ActiveMQ 4.1.0-incubator JMS Message Broker (localhost) is starting
INFO  BrokerService                  - For help or more information please see: http://incubator.apache.org/activemq/
INFO  ManagementContext              - JMX consoles can connect to service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi
INFO  JDBCPersistenceAdapter         - Database driver recognized: [apache_derby_embedded_jdbc_driver]
INFO  DefaultDatabaseLocker          - Attempting to acquire the exclusive lock to become the Master broker
INFO  DefaultDatabaseLocker          - Becoming the master on dataSource: org.apache.derby.jdbc.EmbeddedDataSource@14627a
INFO  JournalPersistenceAdapter      - Journal Recovery Started from: Active Journal: using 5 x 20.0 Megs at: /home/janknecht/tmp/apache-activemq-4.1.0-incubator/activemq-data/journal
INFO  JournalPersistenceAdapter      - Journal Recovered: 0 message(s) in transactions recovered.
INFO  TransportServerThreadSupport   - Listening for connections at: tcp://acxlin.wu.ssn:61616
INFO  TransportConnector             - Connector openwire Started
INFO  NetworkConnector               - Network Connector default-nc Started
INFO  BrokerService                  - ActiveMQ JMS Message Broker (localhost, ID:acxlin.wu.ssn-60609-1169619821670-1:0) started
{code} 


{code:title=producer output}
producer:
     [echo] Running producer against server at $url = tcp://localhost:61616 for subject $subject = TEST.FOO
     [java] Connecting to URL: tcp://localhost:61616
     [java] Publishing a Message with size 1000 to queue: TEST.FOO
     [java] Using non-persistent messages
     [java] Sleeping between publish 0 ms
     [java] Sending message: Message: 0 sent at: Wed Jan 24 07:28:14 CET 2007  ...
     [java] Sending message: Message: 1 sent at: Wed Jan 24 07:28:14 CET 2007  ...
     [java] Sending message: Message: 2 sent at: Wed Jan 24 07:28:14 CET 2007  ...
     [java] Sending message: Message: 3 sent at: Wed Jan 24 07:28:15 CET 2007  ...
     [java] Sending message: Message: 4 sent at: Wed Jan 24 07:28:15 CET 2007  ...
     [java] Sending message: Message: 5 sent at: Wed Jan 24 07:28:15 CET 2007  ...
...
     [java] Sending message: Message: 998 sent at: Wed Jan 24 07:28:55 CET 2007...
     [java] Sending message: Message: 999 sent at: Wed Jan 24 07:28:55 CET 2007...
     [java] Done.
     [java] connection {
     [java]   session {
     [java]     messageCount{ count: 1000 unit: count startTime: 1169620094893 lastSampleTime: 1169620135606 description: Number of messages exchanged }
     [java]     messageRateTime{ count: 1000 maxTime: 126 minTime: 4 totalTime: 40688 averageTime: 40.688 averageTimeExMinMax: 40.63927855711423 averagePerSecond: 24.57727093983484 averagePerSecondExMinMax: 24.606736032348735 unit: millis startTime: 1169620094893 lastSampleTime: 1169620135606 description: Time taken to process a message (thoughtput rate) }
     [java]     pendingMessageCount{ count: 0 unit: count startTime: 1169620094893 lastSampleTime: 1169620094893 description: Number of pending messages }
     [java]     expiredMessageCount{ count: 0 unit: count startTime: 1169620094893 lastSampleTime: 1169620094893 description: Number of expired messages }
     [java]     messageWaitTime{ count: 0 maxTime: 0 minTime: 0 totalTime: 0 averageTime: 0.0 averageTimeExMinMax: 0.0 averagePerSecond: 0.0 averagePerSecondExMinMax: 0.0 unit: millis startTime: 1169620094893 lastSampleTime: 1169620094893 description: Time spent by a message before being delivered }
     [java]     durableSubscriptionCount{ count: 0 unit: count startTime: 1169620094893 lastSampleTime: 1169620094893 description: The number of durable subscriptions }

     [java]     producers {
     [java]       producer queue://TEST.FOO {
     [java]         messageCount{ count: 1000 unit: count startTime: 1169620094918 lastSampleTime: 1169620135606 description: Number of messages processed }
     [java]         messageRateTime{ count: 1000 maxTime: 126 minTime: 4 totalTime: 40688 averageTime: 40.688 averageTimeExMinMax: 40.63927855711423 averagePerSecond: 24.57727093983484 averagePerSecondExMinMax: 24.606736032348735 unit: millis startTime: 1169620094918 lastSampleTime: 1169620135606 description: Time taken to process a message (thoughtput rate) }
     [java]         pendingMessageCount{ count: 0 unit: count startTime: 1169620094918 lastSampleTime: 1169620094918 description: Number of pending messages }
     [java]         messageRateTime{ count: 1000 maxTime: 126 minTime: 4 totalTime: 40688 averageTime: 40.688 averageTimeExMinMax: 40.63927855711423 averagePerSecond: 24.57727093983484 averagePerSecondExMinMax: 24.606736032348735 unit: millis startTime: 1169620094918 lastSampleTime: 1169620135606 description: Time taken to process a message (thoughtput rate) }
     [java]         expiredMessageCount{ count: 0 unit: count startTime: 1169620094918 lastSampleTime: 1169620094918 description: Number of expired messages }
     [java]         messageWaitTime{ count: 0 maxTime: 0 minTime: 0 totalTime: 0 averageTime: 0.0 averageTimeExMinMax: 0.0 averagePerSecond: 0.0 averagePerSecondExMinMax: 0.0 unit: millis startTime: 1169620094918 lastSampleTime: 1169620094918 description: Time spent by a message before being delivered }
     [java]       }
     [java]     }
     [java]     consumers {
     [java]     }
     [java]   }
     [java] }
{code} 

As you can see very bad performace, ot took about 40s to send this 1000 transacted queue messages :-(
",Bug
AMQ-1166,12481985,,"Following configuration throws exception because the placeholder is not replaced with system property com.barra.activemq.MEMORY_SIZE. Spring placeholders work in all other places in the configration, except the memory manager, because it is customized by AMQ.

<beans>   
    <bean class=""org.springframework.beans.factory.config.PropertyPlaceholderConfigurer""/>  <!-- Allows us to use system properties as variables in this configuration file -->
    <broker useJmx=""true"" deleteAllMessagesOnStartup=""false"" persistent=""true"" xmlns=""http://activemq.org/config/1.0"">
        <memoryManager>
            <usageManager id=""memory-manager"" limit=""${com.barra.activemq.MEMORY_SIZE} MB""/>
        </memoryManager>
        <managementContext>
            <managementContext connectorPort=""${com.barra.activemq.jmx.PORT}"" jmxDomainName=""apache.activemq""/> 
        </managementContext>
",Bug
AMQ-1188,12481802,,"On a machine where the hostname contains underscores (e.g. HS_RH64_A3_1) ActiveMQ fails to initialize with the stack trace below. This seems to be a problem with the TCP protocol handler since doing new URL(""http://HS_RH64_A3_1.godzilla.local:61616"") works fine.

2007-03-05 08:30:20,076 [WrapperSimpleAppMain] ERROR (BrokerService.java:412) - Failed to start ActiveMQ JMS Message Broker. Reason: java.io.IOException: Transp
ort Connector could not be registered in JMX: Illegal character in hostname at index 8: tcp://HS_RH64_A3_1.godzilla.local:61616
java.io.IOException: Transport Connector could not be registered in JMX: Illegal character in hostname at index 8: tcp://HS_RH64_A3_1.godzilla.local:61616
        at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:25)
        at org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:1079)
        at org.apache.activemq.broker.BrokerService.startTransportConnector(BrokerService.java:1508)
        at org.apache.activemq.broker.BrokerService.startAllConnectors(BrokerService.java:1468)
        at org.apache.activemq.broker.BrokerService.start(BrokerService.java:402)
        at org.apache.activemq.xbean.XBeanBrokerService.afterPropertiesSet(XBeanBrokerService.java:47)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1062)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1029)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:420)
        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:245)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:141)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:242)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:156)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:290)
        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:348)
        at org.apache.xbean.spring.context.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:161)
        at org.apache.xbean.spring.context.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:51)
        at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:41)
        at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:57)
        at org.apache.activemq.console.command.StartCommand.startBroker(StartCommand.java:82)
        at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:47)
        at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:50)
        at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:82)
        at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:50)
        at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:46)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.apache.activemq.console.Main.runTaskClass(Main.java:159)
        at org.apache.activemq.console.Main.main(Main.java:91)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:197)
        at java.lang.Thread.run(Thread.java:595)
Caused by: java.io.IOException: Illegal character in hostname at index 8: tcp://HS_RH64_A3_1.godzilla.local:61616
        at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:43)
        at org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:94)
        at org.apache.activemq.transport.tcp.TcpTransportFactory.doBind(TcpTransportFactory.java:56)
        at org.apache.activemq.transport.TransportFactory.bind(TransportFactory.java:109)
        at org.apache.activemq.broker.TransportConnector.createTransportServer(TransportConnector.java:270)
        at org.apache.activemq.broker.TransportConnector.getServer(TransportConnector.java:122)
        at org.apache.activemq.broker.TransportConnector.asManagedConnector(TransportConnector.java:100)
        at org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:1072)
        ... 35 more
Caused by: java.net.URISyntaxException: Illegal character in hostname at index 8: tcp://HS_RH64_A3_1.godzilla.local:61616
        at java.net.URI$Parser.fail(URI.java:2816)
        at java.net.URI$Parser.parseHostname(URI.java:3355)
        at java.net.URI$Parser.parseServer(URI.java:3204)
        at java.net.URI$Parser.parseAuthority(URI.java:3123)
        at java.net.URI$Parser.parseHierarchical(URI.java:3065)
        at java.net.URI$Parser.parse(URI.java:3021)
        at java.net.URI.<init>(URI.java:663)
        at org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:91)
        ... 41 more
",Bug
AMQ-1093,12481828,,"In 4.1.0 there's deadlock on connection failover. There is the scenario: 
1. Client consumes message using message listener 
2. Conection is lost 
3. Client sends message to another queue from messagle listener and waits until connection is restored. 
4. Reconnect task blocks on reconnecting. 
 
This bug is new to 4.1.0. The problem is in ActiveMQMessageConsumre.dispatch . There is new lock on unconsumedMessages.getMutex() . So the reconnect task cannot invoke ActiveMQMessageConsumre.clearMessagesInProgress(), because lock is acquired by message listener, which waits untill message is sent (untill connection is resumed). Here is stack traces: 
 
""ActiveMQ Session Task"" daemon prio=1 tid=0x0000002b27774260 nid=0x4778 in Object.wait() [0x0000000040ef3000..0x0000000040ef4db0] 
        at java.lang.Object.wait(Native Method) 
        - waiting on <0x0000002b0020a7c8> (a edu.emory.mathcs.backport.java.util.concurrent.locks.CondVar) 
        at java.lang.Object.wait(Object.java:474) 
        at edu.emory.mathcs.backport.java.util.concurrent.locks.CondVar.await(CondVar.java:75) 
        - locked <0x0000002b0020a7c8> (a edu.emory.mathcs.backport.java.util.concurrent.locks.CondVar) 
        at edu.emory.mathcs.backport.java.util.concurrent.ArrayBlockingQueue.take(ArrayBlockingQueue.java:318) 
        at org.apache.activemq.transport.FutureResponse.getResult(FutureResponse.java:42) 
        at org.apache.activemq.transport.ResponseCorrelator.request(ResponseCorrelator.java:75) 
        at org.apache.activemq.ActiveMQConnection.syncSendPacket(ActiveMQConnection.java:1171) 
        at org.apache.activemq.ActiveMQSession.send(ActiveMQSession.java:1548) 
        at org.apache.activemq.ActiveMQMessageProducer.send(ActiveMQMessageProducer.java:465) 
        at org.apache.activemq.pool.PooledProducer.send(PooledProducer.java:75) 
        - locked <0x0000002b173fa480> (a org.apache.activemq.ActiveMQMessageProducer) 
        at org.apache.activemq.pool.PooledProducer.send(PooledProducer.java:60) 
        at org.springframework.jms.core.JmsTemplate.doSend(JmsTemplate.java:537) 
        at org.springframework.jms.core.JmsTemplate.doSend(JmsTemplate.java:513) 
        at org.springframework.jms.core.JmsTemplate$2.doInJms(JmsTemplate.java:479) 
        at org.springframework.jms.core.JmsTemplate.execute(JmsTemplate.java:430) 
        at org.springframework.jms.core.JmsTemplate.send(JmsTemplate.java:477) 
        at lt.elitnet.dbp.das.impl.storage.HI2StorageImpl.storeHI2Message(HI2StorageImpl.java:57) 
        at lt.elitnet.dbp.das.impl.hi2.HI2PersistanceBase.saveIRIContent(HI2PersistanceBase.java:77) 
        at sun.reflect.GeneratedMethodAccessor185.invoke(Unknown Source) 
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 
        at java.lang.reflect.Method.invoke(Method.java:585) 
        at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:318) 
        at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:203) 
        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:162) 
        at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:107) 
        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185) 
        at org.springframework.orm.hibernate3.HibernateInterceptor.invoke(HibernateInterceptor.java:104) 
        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185) 
        at lt.elitnet.dbp.das.impl.alarming.DataBaseConnectionAlarmsPublisher.invoke(DataBaseConnectionAlarmsPublisher.java:59) 
        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185) 
        at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:209) 
        at $Proxy24.saveIRIContent(Unknown Source) 
        at lt.elitnet.dbp.das.impl.hi2.HI2MessageListener.onMessage(HI2MessageListener.java:40) 
        at lt.elitnet.dbp.commons.messaging.TextMessageListener.deliverMessage(TextMessageListener.java:84) 
        at lt.elitnet.dbp.commons.messaging.TextMessageListener.onMessage(TextMessageListener.java:50) 
        at org.springframework.jms.listener.AbstractMessageListenerContainer.doInvokeListener(AbstractMessageListenerContainer.java:854) 
        at org.springframework.jms.listener.AbstractMessageListenerContainer.invokeListener(AbstractMessageListenerContainer.java:793) 
        at org.springframework.jms.listener.AbstractMessageListenerContainer.doExecuteListener(AbstractMessageListenerContainer.java:763) 
        at org.springframework.jms.listener.AbstractMessageListenerContainer.executeListener(AbstractMessageListenerContainer.java:743) 
        at org.springframework.jms.listener.SimpleMessageListenerContainer$2.onMessage(SimpleMessageListenerContainer.java:190) 
        at org.apache.activemq.ActiveMQMessageConsumer.dispatch(ActiveMQMessageConsumer.java:840) 
        - locked <0x0000002b1771ddc0> (a java.lang.Object) 
        at org.apache.activemq.ActiveMQSessionExecutor.dispatch(ActiveMQSessionExecutor.java:96) 
        at org.apache.activemq.ActiveMQSessionExecutor.iterate(ActiveMQSessionExecutor.java:165) 
        at org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:111) 
        at org.apache.activemq.thread.PooledTaskRunner.access$100(PooledTaskRunner.java:26) 
        at org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:44) 
        at edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:650) 
        at edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:675) 
        at java.lang.Thread.run(Thread.java:595) 
 
""ActiveMQ Transport: tcp:///192.168.2.55:61616"" prio=1 tid=0x0000002b2e814660 nid=0x4773 waiting for monitor entry [0x0000000040e82000..0x0000000040e82c30] 
        at org.apache.activemq.MessageDispatchChannel.clear(MessageDispatchChannel.java:135) 
        - waiting to lock <0x0000002b1771ddc0> (a java.lang.Object) 
        at org.apache.activemq.ActiveMQMessageConsumer.clearMessagesInProgress(ActiveMQMessageConsumer.java:546) 
        at org.apache.activemq.ActiveMQSession.clearMessagesInProgress(ActiveMQSession.java:524) 
        at org.apache.activemq.ActiveMQConnection.transportInterupted(ActiveMQConnection.java:1547) 
        at org.apache.activemq.transport.TransportFilter.transportInterupted(TransportFilter.java:100) 
        at org.apache.activemq.transport.TransportFilter.transportInterupted(TransportFilter.java:100) 
        at org.apache.activemq.transport.failover.FailoverTransport.handleTransportFailure(FailoverTransport.java:236) 
        at org.apache.activemq.transport.failover.FailoverTransport.access$300(FailoverTransport.java:55) 
        at org.apache.activemq.transport.failover.FailoverTransport$1.onException(FailoverTransport.java:120) 
        at org.apache.activemq.transport.TransportFilter.onException(TransportFilter.java:96) 
        at org.apache.activemq.transport.WireFormatNegotiator.onException(WireFormatNegotiator.java:147) 
        at org.apache.activemq.transport.InactivityMonitor.onException(InactivityMonitor.java:150) 
        at org.apache.activemq.transport.TransportSupport.onException(TransportSupport.java:97) 
        at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:150) 
        at java.lang.Thread.run(Thread.java:595)",Bug
AMQ-950,12483915,,"
On Tiger, activemq always creates a rmi connector on port 1099 no matter what I do with -Djavax.management... and <managementContext/>
In particular, setting createConnector=""false"" should prevent AMQ from setting up its own connector, but it does not.

The problem is in the findMBeanServer() method:
            if (result == null && createMBeanServer) {
                result = createMBeanServer();
            }
            else {
                createConnector(result);
            }

result is not null on Tiger with useJmx=""true"", and createConnector is not protected by if(createConnector) like it is on the non-Tiger flow.
The fix (I think) is simply to do this:
            if (result == null && createMBeanServer) {
                result = createMBeanServer();
            }
            else {
                if(createConnector){
                      createConnector(result);
                }
            }",Bug
AMQ-1220,12482527,,"2007-04-05 08:46:47,241 [ActiveMQ Transport: tcp://mymachinename:61616] WARN  org.apache.activemq.ActiveMQConnection - Async exception with no exception listener: java.io.EOFException
java.io.EOFException
	at java.io.DataInputStream.readInt(Unknown Source)
	at org.apache.activemq.openwire.OpenWireFormat.unmarshal(OpenWireFormat.java:267)
	at org.apache.activemq.transport.tcp.TcpTransport.readCommand(TcpTransport.java:156)
	at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:136)
	at java.lang.Thread.run(Unknown Source)

This error occurs after the synchronous messaging is complete and successful.  It occurs after about 5 minutes of the application finishing the receive.  The error is not seen when the same send/receive methods are looped continuously.  The application is a very simple send and receive application that uses Serialization methods for send and receive of objects. 



// Sample send/receive
client.send(Request);
response = (Response) client.receive();

Spring code used for send:

        // Send Request
        jmsTemplate.convertAndSend(requestQueue, req, new MessagePostProcessor()
        {
            public Message postProcessMessage(Message message) throws JMSException
            {
                message.setJMSCorrelationID(myMessageID);
                return message;
            }
        });

Spring code used for receive:

// Wait for Synchronous Response
        // Use a Message Selector to only receive responses to the request you
        // sent
        String resSelectorId = ""JMSCorrelationID='"" + getCurrentJMSMessageID() + ""'"";
        Response resp = (Response) jmsTemplate.receiveSelectedAndConvert(responseQueue,
                resSelectorId);


Here is the shared-context.xml for the connectionFactory:

<?xml version=""1.0"" encoding=""UTF-8""?>
<beans xmlns=""http://www.springframework.org/schema/beans""
       xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""
       xsi:schemaLocation=""http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd"">
       
    <bean id=""RequestQueue"" class=""org.apache.activemq.command.ActiveMQQueue"">
        <constructor-arg value=""RequestQueue""/>
    </bean>
 
    <bean id=""ResponseQueue"" class=""org.apache.activemq.command.ActiveMQQueue"">
        <constructor-arg value=""ResponseQueue""/>
    </bean>
    
    <!--  A Pooled Based JMS Provider -->
    <bean id=""jmsFactory"" class=""org.apache.activemq.pool.PooledConnectionFactory"">
        <property name=""connectionFactory"">
        	<bean class=""org.apache.activemq.ActiveMQConnectionFactory"">
        		<property name=""brokerURL"" value=""tcp://mymachinename:61616""/>
        	</bean>
        </property>
    </bean>
 
</beans>

I am sure that it is something I have failed to configure correctly since I am very new the activeMQ product.  
Thanks for your time and effort!",Bug
AMQ-862,12481863,,"I'm trying to build jencks, which has a dependency on ActiveMQ 4.1-incubator-SNAPSHOT.  I get the following unresolved dependencies:

org.apache.activemq:activemq-core:jar:4.1-incubator-SNAPSHOT
org.apache.activemq:activemq-core:test-jar:tests:4.1-incubator-SNAPSHOT

What it's actually trying to download is:

http://people.apache.org/repo/m2-snapshot-repository/org/apache/activemq/activemq-core/4.1-incubator-SNAPSHOT/activemq-core-4.1-incubator-20060801.170356-6.jar
http://people.apache.org/repo/m2-snapshot-repository/org/apache/activemq/activemq-core/4.1-incubator-SNAPSHOT/activemq-core-4.1-incubator-20060801.170356-2-tests.jar

Those are invalid versions.  When I asked about this on the maven IRC, I was told:

the problem is here: http://people.apache.org/repo/m2-snapshot-repository/org/apache/activemq/activemq-parent/4.1-incubator-SNAPSHOT/activemq-parent-4.1-incubator-20060804.071007-16.pom
In the dependencyManagement they're using, they have expressions for the versions.  Those resolve to the current POM's (the one specifying the dependencies) version, instead of resolving them as snapshots.  It's a common problem when using that expression for shortcuts.


It would be great if this could be fixed so that I could build jencks.  Thanks!",Bug
AMQ-1374,12482776,,"I am making a connection with activemq while running a test case of mule on Eclipse.  But when trying to connect with mule i am getting   the following error.

Exception in thread ""ActiveMQ Transport: tcp://localhost/127.0.0.1:61616"" java.lang.ClassCastException: org.apache.activemq.transport.InactivityMonitor$1
	at edu.emory.mathcs.backport.java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.compareTo(ScheduledThreadPoolExecutor.java:189)
	at edu.emory.mathcs.backport.java.util.PriorityQueue.remove(PriorityQueue.java:507)
	at edu.emory.mathcs.backport.java.util.concurrent.DelayQueue.remove(DelayQueue.java:379)
	at edu.emory.mathcs.backport.java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.remove(ScheduledThreadPoolExecutor.java:707)
	at edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor.remove(ThreadPoolExecutor.java:1582)
	at org.apache.activemq.thread.Scheduler.cancel(Scheduler.java:55)
	at org.apache.activemq.transport.InactivityMonitor.stopMonitorThreads(InactivityMonitor.java:176)
	at org.apache.activemq.transport.InactivityMonitor.onException(InactivityMonitor.java:149)
	at org.apache.activemq.transport.TransportSupport.onException(TransportSupport.java:97)
	at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:150)
	at java.lang.Thread.run(Unknown Source)

The backport utility used is version3.

Can you please help?",Bug
AMQ-1365,12482042,,"When using org.apache.activemq.pool.PooledConnection createConnection(username, password), the username and password fields are swapped.

I think the problem could be the following, based in 4.1.1 source code, 

PooledConnection.java line 77

    public synchronized Connection createConnection(String userName, String password) throws JMSException {
        ConnectionKey key = new ConnectionKey(userName, password);

ConnectionKey.java line 30

    public ConnectionKey(String password, String userName) {
        this.password = password;
        this.userName = userName;

",Bug
AMQ-1369,12482086,,"I developed another discovery agent and received Exception that cannot find aget ""discovery"".
Threre is wrong URI set to DiscoveryAgentFactory.
My configurartion 

<networkConnectors>
     
      <networkConnector name=""default-nc"" uri=""discovery:dns://mq1:61616"" failover=""true""/>
      
    </networkConnectors>

Right URI is dns://mq1:61616, but it set full URI whith ""discovery"" prefix

Workaround is add file ""discovery"" to META-INF and URI change to discovery://mq1:61616",Bug
AMQ-1316,12482188,,"There are no getter/setter in apache-activemq-4.1.1/src/activemq-ra/src/main/java/org/apache/activemq/ra/ActiveMQManagedConnectionFactory.java for the ServerURL
 
   public String getServerUrl() {
        return info.getServerUrl();
    }

  public void setServerUrl(String url) {
        info.setServerUrl(url);
    }

",Bug
AMQ-1329,12482211,,"Closing session twice leads to a closed session in a pool.
Found using spring JmsInvokerClientInterceptor.executeRequest() where session is closed both by QueueRequestor and explicitly:
   JmsUtils.closeQueueRequestor(requestor);
   JmsUtils.closeSession(session);",Bug
AMQ-1289,12481754,,"There is a spelling error inside ""example/src"" directory. The file ""CommnadLineSupport.java "" should be ""CommandLineSupport.java"" and inside the file, ""public class CommnadLineSupport"" should be changed to ""public class CommandLineSupport""",Bug
AMQ-1283,12482376,,"Messages aren't always delivered in a clustered environment.

If you have a cluster of three ActiveMQ nodes, and you send the cluster a constant stream of messages, and randomly restart individual ActiveMQ nodes, you can enter a state whereby an ActiveMQ node has undelivered messages sitting in the message store. These messages will not be delivered, unless that ActiveMQ node is restarted.

This appears to be a consequence of the fact that a Queue immediately dispatches a message received to any available subscribers, but ignores any exceptions that result from the actual send.",Bug
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
AMQ-1582,12482505,,"Since it is mantory to use a provider URL like this:

tcp://localhost:61616?wireFormat.maxInactivityDuration=0

In order to avoid the problem described on these issues AMQ-1146 and AMQ-1482 we are starting all our jvm with that maxInactivityDuration value. 
But the problem that appears using this configuration is that when the InactivityMonitor is inactive every exception on the connection is not reported to the jms exception listener. So, it is not posible detecting the lost of the conection. Event if our ActiveMQ broker is dead, our clients are not notified.

We have compile the activemq source code using the pom you provide but using the branch activemq-4.1 (from the branches folder). As your development people has solve this problem in this branch patching the class InactivyMonitor, the version we generated is working properly. Even if we are using the maxInactivityDuraction with the zero value, the exception are reported in the proper way.

The actual issue is tha since Activemq 5.x is not supported by the last version of Geronimo AS 2.0.2 it should be needed an ActiveMQ 4.1 manteniance realese including at least the patch.


",Bug
AMQ-2679,12483570,,"setup in Geronimo deployment plan with 
{quote}
<config-property-setting name=""ServerUrl"">vm://localhost?async=true&jms.asyncDispatch=false&jms.copyMessageOnSend=false&jms.watchTopicAdvisories=false</config-property-setting> 
{quote}

I use only JMS send/reply pattern:
{quote}
connection = factory.createQueueConnection(); 
connection.start(); 
session = connection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE); 
sender = session.createSender(requestQueue); 
replyQueue = session.createTemporaryQueue(); 
jmsRequestMessage = session.createTextMessage(); 
sender.send(jmsRequestMessage, DeliveryMode.NON_PERSISTENT, Message.DEFAULT_PRIORITY, timeToLive); 
receiver = session.createReceiver(replyQueue); 
jmsReplyMessage = receiver.receive(); 
connection.close();
{quote}

When the message traffic get huge (or the server is under intensive computing), I would got such NPE 
{quote}
 Exception in thread ""VMTransport"" java.lang.NullPointerException 
 at  org.apache.activemq.ActiveMQSessionExecutor.wakeup(ActiveMQSessionExecutor.java:76) 
 at  org.apache.activemq.ActiveMQSessionExecutor.execute(ActiveMQSessionExecutor.java:61) 
 at org.apache.activemq.ActiveMQSession.dispatch(ActiveMQSession.java:1344) 
 at  org.apache.activemq.ActiveMQConnection.onCommand(ActiveMQConnection.java:1485) 
 at  org.apache.activemq.transport.ResponseCorrelator.onCommand(ResponseCorrelator.java:95) 
 at  org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:65) 
 at  org.apache.activemq.transport.vm.VMTransport.iterate(VMTransport.java:201) 
 at  org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:120) 
 at  org.apache.activemq.thread.PooledTaskRunner.access$100(PooledTaskRunner.java:26) 
 at  org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:47) 
 at  edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:665) 
 at  edu.emory.mathcs.backport.java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:690) 
 at java.lang.Thread.run(Thread.java:619) 
{quote}

setting _jms.asyncDispatch=false_ may ease the problem, but the NPE still happens..

as comment from kevan http://n3.nabble.com/sudden-NullPointerException-from-ActiveMQSessionExecutor-wakeup-tt676485.html#a676966
It could be a timing hole in ActiveMQSessionExecutor.
possible fix from kevan
{quote}
Index: activemq-core/src/main/java/org/apache/activemq/ActiveMQSessionExecutor.java 
=================================================================== 
--- activemq-core/src/main/java/org/apache/activemq/ActiveMQSessionExecutor.java	(revision 663068) 
+++ activemq-core/src/main/java/org/apache/activemq/ActiveMQSessionExecutor.java	(working copy) 
@@ -118,10 +118,14 @@ 
         try { 
             if (messageQueue.isRunning()) { 
                 messageQueue.stop(); 
-                if (taskRunner != null) { 
-                    taskRunner.shutdown(); 
-                    taskRunner = null; 
+                TaskRunner tempTaskRunner; 
+                synchronized (this) { 
+                    tempTaskRunner = this.taskRunner; 
+                    this.taskRunner = null; 
                 } 
+                if (tempTaskRunner != null) { 
+                    tempTaskRunner.shutdown(); 
+                } 
             } 
         } catch (InterruptedException e) { 
             Thread.currentThread().interrupt(); 
{quote}


",Bug
AMQ-1759,12482993,,"4.1.2 is build/delivered with geronimo-jms_1.1_spec-1.1.1.jar is build with 1.5 (Java 5) This version is not 1.4 compatible, using ActiveMQ 4.1.2 on a 1.4 JVM throws exception:

[ERROR] java.lang.UnsupportedClassVersionError: javax/jms/Message (Unsupported major.minor version 49.0)

4.1.1 used geronimo-jms_1.1_spec-1.0.jar that is compiled with 1.4

As I understand JVM 1.4 support is dropped in 5.x, not 4.x",Bug
AMQ-1606,12483386,,,Bug
AMQ-1741,12483353,,"When Web Console is deployed in container with a resource adapter configured there is a bug with SessionPool Class:

When you browse a first queue, the QueueBrowserQuery works, but when you browse a queue a second time, an exception is thrown saying Session is closed (Because managed by Resource Adapter).

One workAround is to create a NullSessionPool that do not pool and that implements a ISessionPool interface! (To change a minimum the WebConsole):

The implements is based on SessionPool class implementation. It may be surely enhanced !



package org.apache.activemq.web;

import javax.jms.Connection;
import javax.jms.ConnectionFactory;
import javax.jms.JMSException;
import javax.jms.Session;

public class NullSessionPool implements ISessionPool {

    private ConnectionFactory connectionFactory;
    private Connection connection;

    public Connection getConnection() throws JMSException {
        if (checkConnection()) {
            return connection;
        }

        synchronized (this) {
            connection = getConnectionFactory().createConnection();
            connection.start();
            return connection;
        }
    }

    private boolean checkConnection() {
        if (connection == null) {
            return false;
        }

        try {
            connection.getMetaData();
            return true;
        } catch (JMSException e) {
            return false;
        }
    }

    public void setConnection(Connection connection) {
        this.connection = connection;
    }

    public ConnectionFactory getConnectionFactory() {
        if (connectionFactory == null) {
            throw new IllegalStateException(""No ConnectionFactory has been set for the session pool"");
        }
        return connectionFactory;
    }

    public void setConnectionFactory(ConnectionFactory connectionFactory) {
        this.connectionFactory = connectionFactory;
    }

    public Session borrowSession() throws JMSException {
        return createSession();
    }

    public void returnSession(Session session) throws JMSException {
    	session.close();
    	connection.close();
    }

    protected Session createSession() throws JMSException {
        return getConnection().createSession(false, Session.AUTO_ACKNOWLEDGE);
    }

}



ISessionPool.java:

package org.apache.activemq.web;

import javax.jms.JMSException;
import javax.jms.Session;

public interface ISessionPool {

	public abstract Session borrowSession() throws JMSException;

	public abstract void returnSession(Session session) throws JMSException;

}



The Spring config becomes: 

  
  <bean id=""sessionPool"" class=""org.apache.activemq.web.NullSessionPool"">
  	<property name=""connectionFactory"" ref=""connectionFactory""/>
  </bean>



It works great, no more bug with this workaround in a container with a resource adapter that manage connections and sessions.",Bug
AMQ-1245,12482023,,"need to add</script> to the end of main.jsp decorator in the admin app like this below, IE shows a blank page otherwise

<SCRIPT type='text/javascript' src='/admin/js/common.js'/></script>
<script type='text/javascript' src='/admin/js/css.js'/></script>
<script type='text/javascript' src='/admin/js/standardista-table-sorting.js'/></script>
",Bug
AMQ-1522,12482162,,The ActiveMQ 5.0.0 release is depending on a SNAPSHOT version of xbean which causes the build not to work properly with the maven release plugin.,Bug
AMQ-1463,12482153,,"Attempted to select RSS or Atom feed for a queue, received following error:

{noformat}
HTTP ERROR: 500

missing ConnectionFactory in QueueBrowserServlet
RequestURI=/admin/queueBrowse/DUMMY.QUEUE

Caused by:

java.lang.IllegalStateException: missing ConnectionFactory in QueueBrowserServlet
	at org.apache.activemq.web.QueueBrowseServlet.getConnectionFactory(QueueBrowseServlet.java:80)
	at org.apache.activemq.web.QueueBrowseServlet.getConnection(QueueBrowseServlet.java:64)
	at org.apache.activemq.web.QueueBrowseServlet.createSession(QueueBrowseServlet.java:158)
	at org.apache.activemq.web.QueueBrowseServlet.borrowSession(QueueBrowseServlet.java:141)
	at org.apache.activemq.web.QueueBrowseServlet.doGet(QueueBrowseServlet.java:95)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:707)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:820)
	at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:487)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1098)
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:63)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:75)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1089)
	at org.apache.activemq.web.SessionFilter.doFilter(SessionFilter.java:46)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1089)
	at org.apache.activemq.web.filter.ApplicationContextFilter.doFilter(ApplicationContextFilter.java:81)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1089)
	at com.opensymphony.module.sitemesh.filter.PageFilter.parsePage(PageFilter.java:118)
	at com.opensymphony.module.sitemesh.filter.PageFilter.doFilter(PageFilter.java:52)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1089)
	at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:365)
	at org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216)
	at org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:181)
	at org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:712)
	at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:405)
	at org.mortbay.jetty.handler.HandlerCollection.handle(HandlerCollection.java:114)
	at org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:139)
	at org.mortbay.jetty.Server.handle(Server.java:295)
	at org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:503)
	at org.mortbay.jetty.HttpConnection$RequestHandler.headerComplete(HttpConnection.java:827)
	at org.mortbay.jetty.HttpParser.parseNext(HttpParser.java:511)
	at org.mortbay.jetty.HttpParser.parseAvailable(HttpParser.java:210)
	at org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:379)
	at org.mortbay.io.nio.SelectChannelEndPoint.run(SelectChannelEndPoint.java:361)
	at org.mortbay.thread.BoundedThreadPool$PoolThread.run(BoundedThreadPool.java:442)
{noformat}

URL used was http://0.0.0.0:8161/admin/queueBrowse/DUMMY.QUEUE?view=rss&ffeedType=rss_2.0

",Bug
AMQ-1280,12482208,,"I have built ActiveMQ from trunk.  Upon starting ActiveMQ, the following INFO messages are displayed in the command window:

INFO  log                            - ActiveMQ Console at http://0.0.0.0:8161/admin
INFO  log                            - ActiveMQ Web Demos at http://0.0.0.0:8161/demo

Notice that the URLs show 0.0.0.0 instead of hostname or IP address.",Bug
AMQ-1505,12483213,,"I noticed a problem where durable/persistent topic messages are not being sent to offline consumers in 5.0 when the consumer is reconnected.

The following test code works in activemq-4.1.1, but does not in 5.0-snapshot (5.0-20071120.092745)

I have the following test perl code using Net::Stomp

  #publisher
  use strict;
  use warnings;
  use Net::Stomp;
  my $stomp = Net::Stomp->new( { hostname => 'localhost', port => '61613' } );
  $stomp->connect( { login => 'hello', passcode => 'there' } );
  $stomp->send( { destination => '/topic/foo', body => 'test message', persist => 'true' } );
  $stomp->disconnect;

And the following consumer:

  # subscribe to messages from the topic 'foo'
  use strict;
  use warnings;
  use Net::Stomp;
  my $stomp = Net::Stomp->new( { hostname => 'localhost', port => '61613' } );
  $stomp->connect (
      {
          login => 'hello',
          passcode => 'there' ,
          'client-id' => 'tango',
      }
  );
  $stomp->subscribe(
      {   destination             => '/topic/foo',
          'ack'                   => 'client',
          'activemq.prefetchSize' => 1,
          'activemq.subscriptionName' => 'tango',
      }
  );
  while (1) {
    my $frame = $stomp->receive_frame;
    warn $frame->body; # do something here
    $stomp->ack( { frame => $frame } );
  }
  $stomp->disconnect;

On activemq 4.1.1, the subscription is durable/persistent (i can disconnect the consumer and any messages sent by the producer will be received by the consumer when the consumer is reconnected).  However, on the 5.0 snapshot, i cannot get any messages that are sent by the producer when the consumer is offline to be received by the consumer when the consumer is reconnected.  ",Bug
AMQ-1428,12483179,,activeio leaks handles by not cleaning up on JournalLockedException when control.dat is attempted to be locked but fails,Bug
AMQ-1535,12482267,,"The bug mentioned in this post:
http://www.nabble.com/wrapper.conf-5.0-SNAPSHOT-td13154884s2354.html#a13154884

was not fixed in the 5.0.0 release.

Please add the two lines to wrapper.conf mentioned in the post:
wrapper.app.parameter.2=start 
wrapper.app.parameter.3=xbean:activemq.xml 

Without these lines, the broker does not work as a Windows Service.

Thanks!",Bug
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
,,,,
AMQ-6230,12956516,,"The new Camel version seems to cause the ActiveMQBrokerNdCamelFeatureTest test to fail.

https://builds.apache.org/view/A/view/ActiveMQ/job/ActiveMQ-Java8/lastBuild/org.apache.activemq$activemq-karaf-itest/testReport/org.apache.activemq.karaf.itest/ActiveMQBrokerNdCamelFeatureTest/test/

It looks like a bunch of work was done with Karaf and to get rid of Spring DM in the new version which is probably the issue as ActiveMQ still has the Spring DM stuff laying around.",Bug
AMQ-6210,12949802,,"SubQueueCacheSelectorPlugin stores selector data on temporary destinations.

I believe this is not necessary, as temporary destinations would cease to exist when their creator disconnects, And the creator is also usually their consumer in request-response scenarios.

This leads to ever growing cache file, and since this is just persisted in-memory map, also to unnecessary memory consumption.",Bug
AMQ-6213,12949994,,"If ActiveMQ is installed in a path with spaces (like: ""C:\Program Files\AMQ""), the batch files activemq.bat and activemq-admin.bat cannot start the service. 

The source of the issue appears to be that the -Djava.security.auth.login.config command line option is getting passed a raw path value that is not properly encoded for spaces in the path. I have a patch available that surrounds this parameter value with quotations.",Bug
AMQ-6268,12963433,,"On karaf 4.x plateform, with camel 2.17.0 and activemq 5.13.2 features, installs feature activemq-camel and then installs activemq-broker-noweb. The broker fails to start with error java.lang.ClassNotFoundException: org.apache.xbean.spring.context.v2.XBeanNamespaceHandler not found by org.apache.activemq.activemq-osgi.
This is not happening with camel 2.16.3
This is not happening either if activemq-camel is not installed.",Bug
AMQ-6338,12983404,,"When I startup activemq with openjdk, it shows
{code}
Java Runtime: Oracle Corporation 1.8.0_92-internal /usr/lib/jvm/java-1.8-openjdk/jre
{code}
but there is no oracle java in this environment. Also notice that the path points to the right vendor/path ""java-1.8-openjdk"". I traced that output down to:
activemq-console/src/main/java/org/apache/activemq/console/Main.java
{code}
buffer.append(System.getProperty(""java.vendor""));
{code}

If my limited maven/java skills are right, it grabs the version from 
activemq-openwire-generator/pom.xml:58
{code}
        <property>
          <name>java.vendor</name>
          <value>Oracle Corporation</value>
        </property>
{code}

That would be a rather static setup. It is irritating to show a wrong vendor, could you please make this more dynamic to reflect the jvm/jre vendor?",Bug
AMQ-6300,12971734,,"Hello,

i tried to use ActiveMQ in Combination with the Wildfly Application Server to establish a centrallogging acrhitecture. Some applications can write logging output through log4j JMSTopicAppender and on the Wildfly is a MDB which shall receive the message. 

BUT i get every time the 

06:45:58,259 ERROR [de.dropletinnovations.centrallogging.centralloggingsystem.LoggingMessageService] (default-threads - 24) Failed to build body from content. Serializable class not available to broker. Reason: java.lang.ClassNotFoundException: Forbidden class org.apache.log4j.spi.LoggingEvent! This class is not trusted to be serialized as ObjectMessage payload. Please take a look at http://activemq.apache.org/objectmessage.html for more information on how to configure trusted classes.

I've see at the page and added 

if [ -z ""$ACTIVEMQ_OPTS"" ] ; then
    ACTIVEMQ_OPTS=""$ACTIVEMQ_OPTS_MEMORY -Djava.util.logging.config.file=logging.properties -Djava.security.auth.login.config=$ACTIVEMQ_CONF/login.config -Dorg.apache.activemq.SERIALIZABLE_PACKAGES='*'""

I try it without quotes too but both didn't work.

thank a lot.

with best regards

Bjoern


",Bug
AMQ-6656,13063726,,"While accessing ActiveMQ Admin Panel section Scheduled I get the following error at web view:
{quote}
Exception occurred while processing this request, check the log for more information!
{quote}

Stacktrace from logs:
{code}
| WARN  |  | org.eclipse.jetty.servlet.ServletHandler | qtp1491860739-8662832
org.apache.jasper.JasperException: An exception occurred processing JSP page /scheduled.jsp at line 45

42:             </tr>
43:     </thead>
44:     <tbody>
45:             <c:forEach items=""${requestContext.brokerQuery.scheduledJobs}""
46:             var=""row"">
47:             <tr>
48:              <td><c:out value=""${row.jobId}""/></td>


Stacktrace:
        at org.apache.jasper.servlet.JspServletWrapper.handleJspException(JspServletWrapper.java:568)[apache-jsp-8.0.9.M3.jar:2.3]
        at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:470)[apache-jsp-8.0.9.M3.jar:2.3]
        at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:405)[apache-jsp-8.0.9.M3.jar:2.3]
        at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:349)[apache-jsp-8.0.9.M3.jar:2.3]
        at org.eclipse.jetty.jsp.JettyJspServlet.service(JettyJspServlet.java:107)[apache-jsp-9.2.13.v20150730.jar:9.2.13.v20150730]
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:729)[tomcat-servlet-api-8.0.24.jar:]
        at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:808)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1669)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)[spring-web-4.1.9.RELEASE.jar:4.1.9.RELEASE]
        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)[spring-web-4.1.9.RELEASE.jar:4.1.9.RELEASE]
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1652)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.apache.activemq.web.SessionFilter.doFilter(SessionFilter.java:45)[activemq-web-5.13.4.jar:5.13.4]
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1652)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.apache.activemq.web.filter.ApplicationContextFilter.doFilter(ApplicationContextFilter.java:102)[file:/opt/apache-activemq-5.13.4/webapps/admin/WEB-INF/classes/:]
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1652)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:585)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:143)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:542)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:223)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1127)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:515)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:185)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1061)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:110)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:542)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:110)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:97)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.server.Server.handle(Server.java:499)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:310)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:257)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.io.AbstractConnection$2.run(AbstractConnection.java:540)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:635)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:555)[jetty-all-9.2.13.v20150730.jar:9.2.13.v20150730]
        at java.lang.Thread.run(Thread.java:745)[:1.8.0_60]
{code}",Bug
AMQ-6523,13024163,,"After upgrading a 4 node cluster from 5.9.1 to 5.14.1 I'm seeing my amq logs spammed with 1000's of the following warnings. This was after shutting down all 4 instances, deleting the db and restarting them. 

It looks like the scheduler is stuck in a loop trying to deal with topics that have been deleted. I'm just wondering where the scheduler has picked up these tasks from given that the db was completely removed.

2016-11-29 15:14:55,555 | WARN  | Failed to browse Topic: my.custom.topic.123 | org.apache.activemq.broker.region.Topic | ActiveMQ Broker[myBrokerName] Scheduler
java.lang.NullPointerException
	at org.apache.activemq.broker.region.policy.FixedCountSubscriptionRecoveryPolicy.browse(FixedCountSubscriptionRecoveryPolicy.java:102)[activemq-broker-5.14.1.jar:5.14.1]
	at org.apache.activemq.broker.region.policy.RetainedMessageSubscriptionRecoveryPolicy.browse(RetainedMessageSubscriptionRecoveryPolicy.java:111)[activemq-broker-5.14.1.jar:5.14.1]
	at org.apache.activemq.broker.region.Topic.doBrowse(Topic.java:674)[activemq-broker-5.14.1.jar:5.14.1]
	at org.apache.activemq.broker.region.Topic.access$100(Topic.java:69)[activemq-broker-5.14.1.jar:5.14.1]
	at org.apache.activemq.broker.region.Topic$6.run(Topic.java:780)[activemq-broker-5.14.1.jar:5.14.1]
	at org.apache.activemq.thread.SchedulerTimerTask.run(SchedulerTimerTask.java:33)[activemq-client-5.14.1.jar:5.14.1]
	at java.util.TimerThread.mainLoop(Timer.java:555)[:1.7.0_101]
	at java.util.TimerThread.run(Timer.java:505)[:1.7.0_101]",Bug
AMQ-6765,13085971,,"In the exception handling in the doStart() method of the HttpClientTransport vital debugging information is lost.

On line 282, for any encountered exception an IOException is thrown with the following message: '""Failed to perform GET on: "" + remoteUrl + "" as response was: "" + e.getMessage()'. Where e.getMessage() usually returns null.

It would be nicer if at least he http status code was logged, and maybe the stacktrace when trace is enabled.",Bug
AMQ-6563,13034654,,"MessageDatabase.load in the kahadb store implementation makes a call to ""IOHelper.mkdirs(directory);"" after acquiring the writeLock, but _outside_ of the try/finally which releases the writeLock.  if that method call fails, the writeLock would be left incorrectly locked.",Bug
AMQ-6710,13081322,,"
please include the tags in the pages in webapps/admin/xml, this somehow got forgotten when implementing AMQ-6620

{noformat}

<%@include file=""../WEB-INF/jspf/headertags.jspf"" %>

{noformat}
",Bug
AMQ-6685,13074542,,"We just upgraded from 5.13.3 to 5.14.5 and now when we try to get queue stats form /admin/xml/queues.jsp we get a page with the following errors: 

-=-=-=-=-=-=-=-=-=-=-=-=-=-
This page contains the following errors: 
error on line 4 at column 666: Namespace prefix c on forEach is not defined 
error on line 5 at column 14: Unescaped '<' not allowed in attributes values 
Below is a rendering of the page up to the first error.
-=-=-=-=-=-=-=-=-=-=-=-=-=-

There is nothing below the error message. I even tried deleting all the queues via the /admin/queues.jsp page then went back to the /admin/xml/queues.jsp page and still got the same error.",Bug
AMQ-6996,13166405,,"ActiveMQ 5.15.4 xercesImpl-2.11.0.jar which has one high severity CVE against it.
Discovered by adding OWASP Dependency check into ActiveMQ pom.xml and running the OWASP report.

CVE-2012-0881 Severity:High  CVSS Score: 7.8 (AV:N/AC:L/Au:N/C:N/I:N/A:C)
CWE: CWE-399 Resource Management Errors
Apache Xerces2 Java allows remote attackers to cause a denial of service (CPU consumption) via a crafted message to an XML service, which triggers hash table collisions.
CONFIRM - https://bugzilla.redhat.com/show_bug.cgi?id=787104
MLIST - [oss-security] 20140708 Summer bug cleaning - some Hash DoS stuff
Vulnerable Software & Versions:
cpe:/a:apache:xerces2_java:2.11.0 and all previous versions",Bug
AMQ-6994,13166402,,"ActiveMQ 5.15.4 tomcat-servlet-api-8.0.24.jar  which has four high severity CVEs against it.
Discovered by adding OWASP Dependency check into ActiveMQ pom.xml and running the OWASP report.

Referenced In Projects/Scopes:
ActiveMQ :: Assembly:compile
ActiveMQ :: Web:provided
ActiveMQ :: Web Console:provided

CVE-2016-3092 Severity:High CVSS Score: 7.8 (AV:N/AC:L/Au:N/C:N/I:N/A:C)
CWE: CWE-20 Improper Input Validation
The MultipartStream class in Apache Commons Fileupload before 1.3.2, as used in Apache Tomcat 7.x before 7.0.70, 8.x before 8.0.36, 8.5.x before 8.5.3, and 9.x before
9.0.0.M7 and other products, allows remote attackers to cause a denial of service (CPU consumption) via a long boundary string.
BID - 91453
CONFIRM - http://svn.apache.org/viewvc?view=revision&revision=1743480
CONFIRM - http://svn.apache.org/viewvc?view=revision&revision=1743722
CONFIRM - http://svn.apache.org/viewvc?view=revision&revision=1743738
CONFIRM - http://svn.apache.org/viewvc?view=revision&revision=1743742
CONFIRM - http://tomcat.apache.org/security-7.html
CONFIRM - http://tomcat.apache.org/security-8.html
CONFIRM - http://tomcat.apache.org/security-9.html
CONFIRM - http://www.oracle.com/technetwork/security-advisory/cpuapr2018-3678067.html
CONFIRM - http://www.oracle.com/technetwork/security-advisory/cpujul2017-3236622.html
CONFIRM - http://www.oracle.com/technetwork/security-advisory/cpuoct2017-3236626.html
CONFIRM - http://www.oracle.com/technetwork/topics/security/bulletinjul2016-3090568.html
CONFIRM - https://bugzilla.redhat.com/show_bug.cgi?id=1349468
CONFIRM - https://h20566.www2.hpe.com/portal/site/hpsc/public/kb/docDisplay?docId=emr_na-c05204371
CONFIRM - https://h20566.www2.hpe.com/portal/site/hpsc/public/kb/docDisplay?docId=emr_na-c05289840
CONFIRM - https://h20566.www2.hpe.com/portal/site/hpsc/public/kb/docDisplay?docId=emr_na-c05324759
DEBIAN - DSA-3609
DEBIAN - DSA-3611
DEBIAN - DSA-3614
GENTOO - GLSA-201705-09
JVN - JVN#89379547
JVNDB - JVNDB-2016-000121
MLIST - [dev] 20160621 CVE-2016-3092: Apache Commons Fileupload information disclosure vulnerability
REDHAT - RHSA-2016:2068
REDHAT - RHSA-2016:2069
REDHAT - RHSA-2016:2070
REDHAT - RHSA-2016:2071
REDHAT - RHSA-2016:2072
REDHAT - RHSA-2016:2599
REDHAT - RHSA-2016:2807
REDHAT - RHSA-2016:2808
REDHAT - RHSA-2017:0455
REDHAT - RHSA-2017:0456
REDHAT - RHSA-2017:0457
SECTRACK - 1036427
SECTRACK - 1036900
SECTRACK - 1037029
SECTRACK - 1039606
SUSE - openSUSE-SU-2016:2252
UBUNTU - USN-3024-1
UBUNTU - USN-3027-1
Vulnerable Software & Versions: (show all)
cpe:/a:apache:tomcat:8.0.24

CVE-2016-5425  Severity:High CVSS Score: 7.2 (AV:L/AC:L/Au:N/C:C/I:C/A:C)
CWE: CWE-264 Permissions, Privileges, and Access Controls
The Tomcat package on Red Hat Enterprise Linux (RHEL) 7, Fedora, CentOS, Oracle Linux, and possibly other Linux distributions uses weak permissions for /usr/lib
/tmpfiles.d/tomcat.conf, which allows local users to gain root privileges by leveraging membership in the tomcat group.
BID - 93472
CONFIRM - http://www.oracle.com/technetwork/topics/security/linuxbulletinoct2016-3090545.html
EXPLOIT-DB - 40488
MISC - http://legalhackers.com/advisories/Tomcat-RedHat-Pkgs-Root-PrivEsc-Exploit-CVE-2016-5425.html
MISC - http://packetstormsecurity.com/files/139041/Apache-Tomcat-8-7-6-Privilege-Escalation.html
MLIST - [oss-security] 20161010 CVE-2016-5425 - Apache Tomcat packaging on RedHat-based distros - Root Privilege Escalation (affecting CentOS, Fedora,
OracleLinux, RedHat etc.)
REDHAT - RHSA-2016:2046
SECTRACK - 1036979
Vulnerable Software & Versions:
cpe:/a:apache:tomcat


CVE-2016-6325   Severity:High  CVSS Score: 7.2 (AV:L/AC:L/Au:N/C:C/I:C/A:C)
CWE: CWE-264 Permissions, Privileges, and Access Controls
The Tomcat package on Red Hat Enterprise Linux (RHEL) 5 through 7, JBoss Web Server 3.0, and JBoss EWS 2 uses weak permissions for (1) /etc/sysconfig/tomcat and
(2) /etc/tomcat/tomcat.conf, which allows local users to gain privileges by leveraging membership in the tomcat group.
BID - 93478
CONFIRM - http://www.oracle.com/technetwork/topics/security/linuxbulletinoct2016-3090545.html
CONFIRM - https://bugzilla.redhat.com/show_bug.cgi?id=1367447
REDHAT - RHSA-2016:2045
REDHAT - RHSA-2016:2046
REDHAT - RHSA-2017:0455
REDHAT - RHSA-2017:0456
REDHAT - RHSA-2017:0457
Vulnerable Software & Versions:
cpe:/a:apache:tomcat:-


CVE-2016-8735 Severity:High CVSS Score: 7.5 (AV:N/AC:L/Au:N/C:P/I:P/A:P)
CWE: CWE-284 Improper Access Control
Remote code execution is possible with Apache Tomcat before 6.0.48, 7.x before 7.0.73, 8.x before 8.0.39, 8.5.x before 8.5.7, and 9.x before 9.0.0.M12 if
JmxRemoteLifecycleListener is used and an attacker can reach JMX ports. The issue exists because this listener wasn't updated for consistency with the CVE-2016-3427
Oracle patch that affected credential types.
BID - 94463
CONFIRM - http://seclists.org/oss-sec/2016/q4/502
CONFIRM - http://svn.apache.org/viewvc?view=revision&revision=1767644
CONFIRM - http://svn.apache.org/viewvc?view=revision&revision=1767656
CONFIRM - http://svn.apache.org/viewvc?view=revision&revision=1767676
CONFIRM - http://svn.apache.org/viewvc?view=revision&revision=1767684
CONFIRM - http://tomcat.apache.org/security-6.html
CONFIRM - http://tomcat.apache.org/security-7.html
CONFIRM - http://tomcat.apache.org/security-8.html
CONFIRM - http://tomcat.apache.org/security-9.html
CONFIRM - http://www.oracle.com/technetwork/security-advisory/cpujan2018-3236628.html
CONFIRM - http://www.oracle.com/technetwork/security-advisory/cpuoct2017-3236626.html
CONFIRM - https://security.netapp.com/advisory/ntap-20180607-0001/
DEBIAN - DSA-3738
REDHAT - RHSA-2017:0455
REDHAT - RHSA-2017:0456
REDHAT - RHSA-2017:0457
SECTRACK - 1037331
Vulnerable Software & Versions: (show all)",Bug
AMQ-7019,13173951,,"ActiveMQ 5.15.4 jolokia.jar which has one high severity CVE against it.
Discovered by adding OWASP Dependency check into ActiveMQ pom.xml and running the OWASP report.

CVE-2015-5182 Severity:High  CVSS Score: 6.8 
allows Cross-site request forgery (CSRF) vulnerability in the jolokia API in A-MQ. 
CONFIRM - https://bugzilla.redhat.com/show_bug.cgi?id=1248809 CONFIRM",Bug
AMQ-7012,13172586,,"From time to time I see the following log line for STOMP: 

 

{{2018-07-17 07:31:22,204 | WARN  | Exception occurred processing: <Unknown> -> org.apache.activemq.transport.stomp.ProtocolException: No subscription matched. | org.apache.activemq.transport.stomp.ProtocolConverter | ActiveMQ NIO Worker 1186}}

 

 

The misleading part is ""<Unknown>"", the unknown is suppose to be the STOMP's action word (SEND, SUBSCRIBE etc). 

The problem seems to be 
{code:java}
 org.apache.activemq.transport.stomp.ProtocolConverter.safeGetAction(){code}
that is comparing the STOMP action word with constants defined in 
{code:java}
org.apache.activemq.transport.stomp.ProtocolConverter.Stomp.Commands{code}
But for subscribe and unsubscribe the constants are defined as ""SUB"" and ""UNSUB"" which does not match the actual STOMP action verbs.

 ",Bug
AMQ-7093,13196926,,AMQ-7082 was implemented to create a concurrent thread to handle the free page recovery.  It was included as a part of 5.15.7.  There was some additional add-on coding that was not a part of that release which had introduced some potential bugs.  This was made to track the additional commits for this.,Bug
AMQ-7089,13195794,,"On my Linux machine I have been running ActiveMQ on a filesystem setup like this:
{noformat}
Filesystem Size Used Avail Use% Mounted on
/dev/nvme0n1p1 407G 299G 88G 78% /
...
/dev/nvme1n1p2 477G 443G 35G 93% /media/sits/DATA
{noformat}
When I call broker.setDataDirectoryFile(""/media/sits/DATA/activemq') after broker initialisation it reports the amount of free temp space usage is the free space on '/', not on '/media/sits/DATA'.

The culprit is BrokerService.checkTmpStorageUsageLimits() calls checkUsageLimit(tmpDir, usage.getTempUsage(), usage.getTempUsage().getPercentLimit()) which ultimately calls this code:
{code}
    protected void checkUsageLimit(File dir, Usage<?> storeUsage, int percentLimit) throws ConfigurationException {
        if (dir != null) {
            dir = StoreUtil.findParentDirectory(dir);
            String storeName = storeUsage instanceof StoreUsage ? ""Store"" : ""Temporary Store"";
            long storeLimit = storeUsage.getLimit();
            long storeCurrent = storeUsage.getUsage();
            long totalSpace = dir.getTotalSpace();
{code}
The problem is StoreUtil is broken on Linux (and probably other OS's) since you can mount a filesystems in non-root locations.  Even on Windows this is possible.
{code}
    public static File findParentDirectory(File dir) {
        if (dir != null) {
            String dirPath = dir.getAbsolutePath();
            if (!dir.isAbsolute()) {
                dir = new File(dirPath);
            }

            while (dir != null && !dir.isDirectory()) {
                dir = dir.getParentFile();
            }
        }
        return dir;
    }
{code}
On Linux this will always go to '/' and use that for reporting free space which is clearly wrong.

There are only a few usages of this method.  My proposal is to nuke this method and instead update the clients to just call Files.getFileStore(Path path) and then FileStore.getTotalSpace() and FileStore.getUsableSpace.

I'm happy to submit a PR if people are happy with the approach?

",Bug
AMQ-6956,13157274,,"When I connect and disconnect from a broker using the activemq-client, sometimes I get the exception below. ssl:// is used. The exception appears when the client is disconnecting.

The broker in this case is the current snapshot of ActiveMQ Artemis.

Good test for reproducing is {{org.apache.activemq.artemis.tests.integration.security.SecurityTest#testJAASSecurityManagerAuthenticationWithCertsAndOpenWire}}.

I saw it in conjunction with the {{flush()}} exception from Netty, discussed on ARTEMIS-1804. It turns out the flush{} exception is probably unrelated to this one, because it appeared in the server log every time and seems harmless.

The exception below appears on the client in about 1 % of runs of the aforementioned tests (so it must be run in a loop to see this happen). For some reason, this error appears to me more often on Travis CI (linked from the Artemis bug)

The exception is

{noformat}
javax.jms.JMSException: Connection closed by remote host
	at org.apache.activemq.util.JMSExceptionSupport.create(JMSExceptionSupport.java:72)
	at org.apache.activemq.ActiveMQConnection.doAsyncSendPacket(ActiveMQConnection.java:1310)
	at org.apache.activemq.ActiveMQConnection.close(ActiveMQConnection.java:696)
	at com.redhat.mqe.lib.CoreClient.close(CoreClient.java:302)
	at com.redhat.mqe.lib.CoreClient.closeConnObjects(CoreClient.java:295)
	at com.redhat.mqe.lib.SenderClient.startClient(SenderClient.java:156)
	at com.redhat.mqe.lib.Main.main(Main.java:50)
	at com.redhat.mqe.aoc.Main.main(Main.java:74)
	at AocMainTest.main(MainTest.kt:113)
	at AbstractMainTest$sendSingleMessageAllTrustingTls$1.invoke(AbstractMainTest.kt:404)
	at AbstractMainTest$sendSingleMessageAllTrustingTls$1.invoke(AbstractMainTest.kt:75)
	at AbstractMainTestKt.assertNoSystemExit(AbstractMainTest.kt:66)
	at AbstractMainTest.sendSingleMessageAllTrustingTls(AbstractMainTest.kt:398)
	at sun.reflect.GeneratedMethodAccessor3.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:436)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:115)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:170)
	at org.junit.jupiter.engine.execution.ThrowableCollector.execute(ThrowableCollector.java:40)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:166)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:113)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:58)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:112)
	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:120)
	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175)
	at java.util.Iterator.forEachRemaining(Iterator.java:116)
	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)
	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)
	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)
	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:120)
	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$2(HierarchicalTestExecutor.java:120)
	at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175)
	at java.util.Iterator.forEachRemaining(Iterator.java:116)
	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)
	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)
	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)
	at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.lambda$executeRecursively$3(HierarchicalTestExecutor.java:120)
	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.executeRecursively(HierarchicalTestExecutor.java:108)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:79)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:55)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90)
	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:74)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:67)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
Caused by: java.net.SocketException: Connection closed by remote host
	at sun.security.ssl.SSLSocketImpl.checkWrite(SSLSocketImpl.java:1565)
	at sun.security.ssl.AppOutputStream.write(AppOutputStream.java:124)
	at org.apache.activemq.transport.tcp.TcpBufferedOutputStream.flush(TcpBufferedOutputStream.java:115)
	at java.io.DataOutputStream.flush(DataOutputStream.java:123)
	at org.apache.activemq.transport.tcp.TcpTransport.oneway(TcpTransport.java:194)
	at org.apache.activemq.transport.AbstractInactivityMonitor.doOnewaySend(AbstractInactivityMonitor.java:335)
	at org.apache.activemq.transport.AbstractInactivityMonitor.oneway(AbstractInactivityMonitor.java:317)
	at org.apache.activemq.transport.TransportFilter.oneway(TransportFilter.java:94)
	at org.apache.activemq.transport.WireFormatNegotiator.oneway(WireFormatNegotiator.java:116)
	at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:68)
	at org.apache.activemq.transport.ResponseCorrelator.oneway(ResponseCorrelator.java:60)
	at org.apache.activemq.ActiveMQConnection.doAsyncSendPacket(ActiveMQConnection.java:1308)
	... 64 more
{noformat}",Bug
AMQ-5784,12831333,,"activemq in combination with jetty9 does not work for websockets + mqtt.
patch: http://pastebin.com/phcsJHR5
I tested with the chat example coming with activemq with all browsers.",Bug
AMQ-6238,12957396,,"To reduce the load on the ASF mirrors, projects are required to delete old releases [1]

Please can you remove all non-current releases?

Thanks!

Note: you can still reference superseded versions from the download page, but the links should be adjusted to point to the archive server.

[1] http://www.apache.org/dev/release.html#when-to-archive",Bug
AMQ-6280,12964748,,"The documentation at http://activemq.apache.org/how-do-i-use-ssl.html uses inconsistent names for the keystore & trustStore files, so a user trying to follow the steps exactly as a tutorial will run into problems.

In particular it alternates between using ""server.keystore"" and ""client.keystore"" vs ""broker.ts"" and ""client.ks"".

The separation between server authentication and client authentication certificates also isn't as clean as it could be. If you're only doing server authentication than is the trustStore configuration required or only the keystore?",Bug
AMQ-5680,12783576,,"The following code is a near-copy of the .getTempTopics() right above - without the change of the ""if (destination.isTopic()..."" to ""if (destination.isQueue()...""

{code}
    /**
     * Retrieve a set of all TemporaryQueues be used by the Broker
     * @return  all TemporaryQueues
     */
    public Set<ActiveMQTempQueue> getTempQueues(){
        Set<ActiveMQTempQueue> result = new HashSet<ActiveMQTempQueue>();
        for (ActiveMQDestination destination:getDestinations()){
            if (destination.isTopic() && destination.isTemporary()){
                result.add((ActiveMQTempQueue) destination);
            }
        }
        return result;
    }
{code}
",Bug
AMQ-5627,12778990,,"The following page contains dead picture links:
http://activemq.apache.org/scaling-the-depth-of-a-queue.html",Bug
AMQ-5929,12856191,,"http://activemq.apache.org/unix-shell-script.html#UnixShellScript-Runningmultipleinstances

in example script change ""2>>&1"" to ""2>&1""",Bug
AMQ-7163,13220055,,"Hi,

This is related to AMQ-7082.

If the broker had an unclean shutdown and the recovery thread didn't find any free pages (newFreePages is empty the recovery), the broker will have a second unclean shutdown - and this will happens to any future restart as long as the number of free pages is = 0 

 

See:

 

[https://github.com/apache/activemq/blob/9e6543551731ef0241967ca545c9a4956876cb86/activemq-kahadb-store/src/main/java/org/apache/activemq/store/kahadb/disk/page/PageFile.java#L484]

 

[https://github.com/apache/activemq/blob/9e6543551731ef0241967ca545c9a4956876cb86/activemq-kahadb-store/src/main/java/org/apache/activemq/store/kahadb/disk/page/PageFile.java#L584]

 

[https://github.com/apache/activemq/blob/9e6543551731ef0241967ca545c9a4956876cb86/activemq-kahadb-store/src/main/java/org/apache/activemq/store/kahadb/disk/page/PageFile.java#L527]

 ",Bug
AMQ-7013,13172927,,"XATransactionID hash function may generate duplicates.

Scenario:

XID formatId, GlobalTransaction, and BranchQualifier values are identical for many entries. We need to use a better hash function to avoid populating a map with many entries in the same bucket (results in bucket having O(n) performance on recovery).

Example using existing Hash Function:
2018-07-18 06:13:29,866 | INFO  | Recovering from the journal @1:28 | org.apache.activemq.store.kahadb.MessageDatabase | main
2018-07-18 06:23:04,070 | INFO  | @2:484592, 100000 entries recovered .. | org.apache.activemq.store.kahadb.MessageDatabase | main
2018-07-18 06:23:04,099 | INFO  | Recovery replayed 100453 operations from the journal in 574.233 seconds. | org.apache.activemq.store.kahadb.MessageDatabase | main 

Using JenkinsHash:
2018-07-18 10:58:43,713 | INFO  | Recovering from the journal @1:28 | org.apache.activemq.store.kahadb.MessageDatabase | main
2018-07-18 10:58:51,302 | INFO  | @2:484592, 100000 entries recovered .. | org.apache.activemq.store.kahadb.MessageDatabase | main
2018-07-18 10:58:51,329 | INFO  | Recovery replayed 100453 operations from the journal in 7.618 seconds. | org.apache.activemq.store.kahadb.MessageDatabase | main",Bug
AMQ-5487,12761325,,"Hi.I'm a tester.I'm not a developer. I used to be able to enter http://localhost:8161/admin on my web browser and see the broker.I'm not able to anymore. I'm following instructions on http://activemq.apache.org/version-5-run-broker.html but I don't understand what it means by 'The binary distribution of ActiveMQ comes with a script called 'activemq' which allows you to run a broker. Typing the following will run an ActiveMQ Broker using the out of the box configuration
activemq
There are a number of different command line options to be able to run a broker. To see them type
activemq -?
For more details regarding the activemq script file and other script files refer to ActiveMQ Command Line Tools Reference
You can then use a Broker Configuration URI to specify how to start and configure your broker using a single URI. For example
activemq broker:(tcp://localhost:61616,network:static:tcp://remotehost:61616)?persistent=false&useJmx=true'",Bug
AMQ-4936,12684704,,"Nightly builds / snapshots which are not formal releases should not be linked from the main download page.
Such builds have not been voted on and should only be used by developers who should be made aware that the code is without any guarantees.
Nightly builds are not formal ASF releases, and must not be promoted to the general public.
See [1] second para. The second sentence states:
""Do not include any links on the project website that might encourage non-developers to download and use nightly builds, snapshots, release candidates, or any other similar package.""

[1] http://www.apache.org/dev/release.html#what
",Bug
AMQ-5100,12701319,,"I have attempted to configure PKCS11/NSS support in ActiveMQ, however, I am receiving the following exception:

Caused by: java.io.FileNotFoundException: class path resource [NONE] cannot be opened because it does not exist
        at org.springframework.core.io.ClassPathResource.getInputStream(ClassPathResource.java:157)
        at org.apache.activemq.spring.SpringSslContext.createKeyManagerKeyStore(SpringSslContext.java:119)
        at org.apache.activemq.spring.SpringSslContext.createKeyManagers(SpringSslContext.java:88)
        at org.apache.activemq.spring.SpringSslContext.afterPropertiesSet(SpringSslContext.java:65)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:622)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1581)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1522)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1452)
        ... 40 more

My configured sslContext for the broker looks like this:

        <sslContext>
                <sslContext
                        keyStore=""NONE"" keyStoreType=""PKCS11"" keyStorePassword=""password""
                        trustStore=""/etc/activemqssl/truststore.jks"" trustStorePassword=""password""
                />
        </sslContext>

AFAIK, setting keyStore to ""NONE"" is the generally accepted way to do with with PKCS11. The code should generate a warning at most for this, but instead I receive the above exception and a failure to load the keystore.

The activemq code looks like this (in org.apache.activemq.spring.SpringSslContext):
    private KeyStore createKeyManagerKeyStore() throws Exception {
        if( keyStore ==null ) {
            return null;
        }

        KeyStore ks = KeyStore.getInstance(keyStoreType);
        InputStream is=Utils.resourceFromString(keyStore).getInputStream();
        try {
            ks.load(is, keyStorePassword==null? null : keyStorePassword.toCharArray());
        } finally {
            is.close();
        }
        return ks;
    }

It looks like this should just be setting ""is"" to null, generating a warning, and then calling ks.load with the null inputstream (the nss library will load the nss files based upon the nss.cfg file).
",Bug
AMQ-4877,12678820,,"This test fails intermittently, usually on slower boxes.  It will get a stack trace like the one shown below.  The root cause can be seen in the log:

2013-11-09 11:04:19,771 [JMX connector  ] - WARN  ManagementContext              - Failed to start JMX connector Cannot bind to URL [rmi://localhost:1099/jmxrmi]: javax.naming.NameAlreadyBoundException: jmxrmi [Root exception is java.rmi.AlreadyBoundException: jmxrmi]. Will restart management to re-create JMX connector, trying to remedy this issue.

This appears to be the result of a quick server shutdown/restart.  I'll add a sleep to the test to avoid this.


java.net.SocketTimeoutException: Read timed out
	at java.net.SocketInputStream.socketRead0(Native Method)
	at java.net.SocketInputStream.read(SocketInputStream.java:129)
	at com.sun.net.ssl.internal.ssl.InputRecord.readFully(InputRecord.java:422)
	at com.sun.net.ssl.internal.ssl.InputRecord.read(InputRecord.java:460)
	at com.sun.net.ssl.internal.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:863)
	at com.sun.net.ssl.internal.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1188)
	at com.sun.net.ssl.internal.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1215)
	at com.sun.net.ssl.internal.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1199)
	at org.apache.activemq.transport.tcp.SslContextNBrokerServiceTest.verifySslCredentials(SslContextNBrokerServiceTest.java:76)
	at org.apache.activemq.transport.tcp.SslContextNBrokerServiceTest.verifyCredentials(SslContextNBrokerServiceTest.java:57)
	at org.apache.activemq.transport.tcp.SslContextNBrokerServiceTest.testConfigurationIsolation(SslContextNBrokerServiceTest.java:47)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at junit.framework.TestCase.runTest(TestCase.java:176)
	at junit.framework.TestCase.runBare(TestCase.java:141)
	at junit.framework.TestResult$1.protect(TestResult.java:122)
	at junit.framework.TestResult.runProtected(TestResult.java:142)
	at junit.framework.TestResult.run(TestResult.java:125)
	at junit.framework.TestCase.run(TestCase.java:129)
	at junit.framework.TestSuite.runTest(TestSuite.java:255)
	at junit.framework.TestSuite.run(TestSuite.java:250)
	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:84)
	at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:53)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:123)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:104)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:164)
	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:110)
	at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:175)
	at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcessWhenForked(SurefireStarter.java:81)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:68)",Bug
AMQ-5360,12741777,,"The wild card mapping table in the following documentation page is wrong:
http://activemq.apache.org/mqtt.html

The correct mapping should be the following:

'.' => '/'
'*' => '+'
'>' => '#'

so in ActiveMQ wildcard '*' should map to single-level wildcard '+' in MQTT while wildcard '>' should map to multi-level wildcard '#' in MQTT.

http://activemq.apache.org/wildcards.html
http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/MQTT_V3.1_Protocol_Specific.pdf
",Bug
AMQ-4810,12674067,,"Trying the LevelDB store on a recent ActiveMQ 5.9 snapshot, it seems that the broker does not remove useless files.

I currently have a broker with no messages at all (all queues are empty and the TotalMessageCount is at 0) but plenty of LevelDB files:

# du -ks leveldb
1388380	leveldb
# find leveldb -type f | wc -l
2419

Maybe this is related to https://issues.apache.org/jira/browse/APLO-245?",Bug
AMQ-4811,12674307,,"Page http://activemq.apache.org/hermes-jms.html
refers to old versions of ActiveMQ.
Can this be updated (perhaps make it version-agnostic).

Also there's a link to http://activemq.apache.org/hermes-screenshot.html
But that page does not actually show a screenshot.
",Bug
AMQ-4726,12669009,,"The ant build.xml file of activemq reports that ""durable option"" will create a durable subscriber

{code}
     [echo]             ant producer <options> - Creates a producer publishing a number of messages
     [echo]
     [echo]             Producer Options:
     [echo]                             url - Used to specify acustom URL for the broker,
     [echo]                                   e.g., tcp://hostname:1234
     [echo]                           topic - A boolean to determine whether to use topics
     [echo] 		                        or queues
     [echo]                         subject - Used to specify a custom destination name,
     [echo]                                   e.g. MyDestination
     [echo]                         durable - A boolean to specify that you want to create
     [echo]                                   a durable topic subscriber?
{code}

Obviously, this is a mistake as the ""durable"" option for the producer allows to change DeliveryMode of the message ('PERSISTENT' or 'NON-PERSISTENT')

Maybe, we should use 'persistent' as property name but then the build.xml file and java class need to be changed",Bug
AMQ-5180,12713573,,"Can the links on page http://activemq.apache.org/security.html be updated?
Much appreciated.

I'm trying to upgrade to 5.9.1 and noticed the jaasAuthenticationPlugin is enabled by default (in activemq-karaf). Need to understand how to modify the client-side to provide the required information.",Bug
AMQ-5199,12716303,,"http://activemq.apache.org/how-can-i-see-what-destinations-are-used.html

The links to the code no longer work. Thanks for adjusting!",Bug
AMQ-4583,12653163,,"The links to the code are no longer working.
For example:

http://svn.apache.org/viewvc/activemq/trunk/activemq-core/src/main/java/org/apache/activemq/RedeliveryPolicy.java?view=markup

Similar problem with code links on page http://activemq.apache.org/message-redelivery-and-dlq-handling.html

Perhaps further pages are affected?",Bug
AMQ-4658,12660365,,"In the link 
http://activemq.apache.org/per-destination-policies.html describing policies advisoryForDelivery policy is called advisoryForDelivered, which should be called  advisoryForDelivery, as specified here 
http://activemq.apache.org/advisory-message.html",Bug
AMQ-4496,12645380,,"Error formatting macro: snippet: java.lang.IndexOutOfBoundsException: Index: 20, Size: 20

http://activemq.apache.org/how-do-i-use-ssl.html",Bug
AMQ-4380,12637437,,"The link to the pdf called 'FUSE Source ActiveMQ Persistence Guide' under the heading 'Other Resources' is dead on the following page http://activemq.apache.org/persistence.html

Hopefully someone has an idea about where the new link should be :)",Bug
AMQ-4329,12632893,,"Note: The KahaDB version of this test (AMQ2149KahaDBTest) is working correctly.

This test has two cases that fail, testQueueTransactionalOrderWithRestart, and testOrderWithRestart.  testQueueTransactionalOrderWithRestart fails after the server is restarted with the following exception


junit.framework.AssertionFailedError: queue://test.dest.0 received 6 expected 5681
        at junit.framework.Assert.fail(Assert.java:57)
        at junit.framework.TestCase.fail(TestCase.java:227)
        at org.apache.activemq.bugs.AMQ2149Test$Receiver.onMessage(AMQ2149Test.java:201)
        at org.apache.activemq.ActiveMQMessageConsumer.dispatch(ActiveMQMessageConsumer.java:1321)
        at org.apache.activemq.ActiveMQSessionExecutor.dispatch(ActiveMQSessionExecutor.java:131)
        at org.apache.activemq.ActiveMQSessionExecutor.iterate(ActiveMQSessionExecutor.java:202)
        at org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:129)
        at org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:47)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
        at java.lang.Thread.run(Thread.java:722)


The testOrderWithRestart case works correctly when run on it's own, and only fails if run after testQueueTransactionalOrderWithRestart with messages like the following:

2013-02-18 15:41:25,528 [ Session Task-1] - WARN  AMQ2149Test                    - queue://test.dest.0 received 6082 in msg: ID:Kevins-MacBook-Pro.local-60920-1361220011508-5:1:1:1:6083 expected 0, l\
astId: null, message:ActiveMQTextMessage {commandId = 6087, responseRequired = true, messageId = ID:Kevins-MacBook-Pro.local-60920-1361220011508-5:1:1:1:6083, originalDestination = null, originalTran\
sactionId = null, producerId = ID:Kevins-MacBook-Pro.local-60920-1361220011508-5:1:1:1, destination = queue://test.dest.0, transactionId = null, expiration = 0, timestamp = 1361220082802, arrival = 0\
, brokerInTime = 1361220085522, brokerOutTime = 1361220085522, correlationId = null, replyTo = null, persistent = true, type = null, priority = 4, groupID = null, groupSequence = 0, targetConsumerId \
= null, compressed = false, userID = null, content = null, marshalledProperties = org.apache.activemq.util.ByteSequence@d3bf5f8, dataStructure = null, redeliveryCounter = 0, size = 0, properties = {s\
eqNum=6082}, readOnlyProperties = true, readOnlyBody = true, droppable = false, text = 186704152740050035096258373992406547145203959...321183574477}
2013-02-18 15:41:25,528 [ Session Task-1] - ERROR AMQ2149Test                    - queue://test.dest.0 onMessage error
junit.framework.AssertionFailedError: queue://test.dest.0 received 6082 expected 0
        at junit.framework.Assert.fail(Assert.java:57)
        at junit.framework.TestCase.fail(TestCase.java:227)
        at org.apache.activemq.bugs.AMQ2149Test$Receiver.onMessage(AMQ2149Test.java:201)
        at org.apache.activemq.ActiveMQMessageConsumer.dispatch(ActiveMQMessageConsumer.java:1321)
        at org.apache.activemq.ActiveMQSessionExecutor.dispatch(ActiveMQSessionExecutor.java:131)
        at org.apache.activemq.ActiveMQSessionExecutor.iterate(ActiveMQSessionExecutor.java:202)
        at org.apache.activemq.thread.PooledTaskRunner.runTask(PooledTaskRunner.java:129)
        at org.apache.activemq.thread.PooledTaskRunner$1.run(PooledTaskRunner.java:47)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
        at java.lang.Thread.run(Thread.java:722)

It looks like messages send by testQueueTransactionalOrderWithRestart are not cleaned up when that test fails.
",Bug
AMQ-5052,12695161,,"DemandForwardingBridgeSupport#serviceRemoteConsumerAdvisory has a code:

            if (info.isBrowser()) {
                LOG.info(""{} Ignoring sub from {}, browsers explicitly suppressed"", configuration.getBrokerName(), remoteBrokerName);
                return;
            }

the original version is:

            if (info.isBrowser()) {
                if (LOG.isDebugEnabled()) {
                    LOG.info(configuration.getBrokerName() + "" Ignoring sub from "" + remoteBrokerName + "", browsers explicitly suppressed"");
                }
                return;
            }

New version code is noisy because broker always show info log when client browse message.
Please change code to:

            if (info.isBrowser()) {
                LOG.debug(""{} Ignoring sub from {}, browsers explicitly suppressed"", configuration.getBrokerName(), remoteBrokerName);
                return;
            }

Thanks",Bug
AMQ-5053,12695224,,"This happens fairly regularly on CI boxes, at least on AWS.  For some reason the producerConnection.close() in sendMessage occasionally takes just over 1000 ms, which means the message expires before the test has a chance to receive it.
",Bug
AMQ-5036,12694257,,"Just need to bump up the timeout.
",Bug
AMQ-4572,12650916,,the link to the config file at http://svn.apache.org/repos/asf/activemq/trunk/activemq-core/src/main/resources/META-INF/services/org/apache/activemq/store/jdbc/ is broken from http://activemq.apache.org/jdbc-support.html,Bug
AMQ-4437,12640769,,"When compiling the ActiveMQ trunk using Java 7, I get:

{quote}
[WARNING] ~activemq/activemq-stomp/src/test/java/org/apache/activemq/transport/stomp/StompVirtualTopicTest.java:[31,22] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-stomp/src/test/java/org/apache/activemq/transport/stomp/StompVirtualTopicTest.java:[133,12] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-stomp/src/test/java/org/apache/activemq/transport/stomp/StompVirtualTopicTest.java:[192,20] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-pool/src/test/java/org/apache/activemq/pool/PooledConnectionFactoryTest.java:[30,22] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-pool/src/test/java/org/apache/activemq/pool/PooledConnectionFactoryMaximumActiveTest.java:[19,22] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-pool/src/test/java/org/apache/activemq/pool/PooledConnectionTest.java:[73,3] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-pool/src/test/java/org/apache/activemq/pool/PooledConnectionTest.java:[84,3] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-pool/src/test/java/org/apache/activemq/pool/PooledConnectionTest.java:[98,2] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-pool/src/test/java/org/apache/activemq/pool/PooledConnectionFactoryTest.java:[216,12] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-pool/src/test/java/org/apache/activemq/pool/PooledConnectionFactoryTest.java:[251,20] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-pool/src/test/java/org/apache/activemq/pool/PooledConnectionFactoryMaximumActiveTest.java:[112,8] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-pool/src/test/java/org/apache/activemq/pool/PooledConnectionFactoryMaximumActiveTest.java:[115,8] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-spring/src/test/java/org/apache/activemq/usecases/AMQDeadlockTest3.java:[37,22] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-spring/src/test/java/org/apache/activemq/usecases/AMQFailoverIssue.java:[95,12] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-spring/src/test/java/org/apache/activemq/usecases/AMQDeadlockTest3.java:[114,12] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-spring/src/test/java/org/apache/activemq/usecases/AMQDeadlockTest3.java:[165,12] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-spring/src/test/java/org/apache/activemq/usecases/AMQDeadlockTest3.java:[217,12] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-unit-tests/src/test/java/org/apache/activemq/network/NetworkLoopBackTest.java:[26,29] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-fileserver/src/test/java/org/apache/activemq/util/HttpBlobTest.java:[57,8] [deprecation] Assert in junit.framework has been deprecated
[WARNING] ~activemq/activemq-fileserver/src/test/java/org/apache/activemq/util/HttpBlobTest.java:[68,8] [deprecation] Assert in junit.framework has been deprecated
{quote}

This is probably something worth fixing...",Bug
AMQ-3302,12505925,,"http://camel.apache.org/maven/current/camel-activemq/apidocs/org/apache/camel/component/activemq/ActiveMQComponent.html#activeMQComponent(java.lang.String)

gives a 404,

link is on: http://camel.apache.org/activemq.html",Bug
AMQ-3311,12506650,,,Bug
AMQ-3783,12547929,,"The download page(s) fail to include any MD5 or SHA1 hashes.
One or both of these should be provided.

The page says:

bq. It is essential that you verify the integrity of the downloaded files using the PGP or MD5 signatures. 

This is slightly inaccurate. PGP is a signature whereas MD5 and SHA1 are hashes.
",Bug
AMQ-3943,12600164,,"Code follow.I connect to an ActiveMQ server's jmx feature.I confirm the jmx feature is enable,because the same code work well on orther blades.
    public static void main(String args[]) throws UnknownHostException, IOException
    {
        JMXServiceURL url = new JMXServiceURL(""service:jmx:rmi:///jndi/rmi://128.128.17.1:2011/jmxrmi"");
        String username = ""guest"";

        String password = ""guest"";

        Map env = new HashMap();
        String[] credentials = new String[] { username, password };
        env.put(JMXConnector.CREDENTIALS, credentials);
        JMXConnector connector = JMXConnectorFactory.connect(url, env);
        connector.connect();
        connector.close();
    }
But in a blade,it throws exception :
Exception in thread ""main"" java.rmi.ConnectException: Connection refused to host: 127.0.0.1; nested exception is: 
	java.net.ConnectException: Connection refused
	at sun.rmi.transport.tcp.TCPEndpoint.newSocket(TCPEndpoint.java:601)
	at sun.rmi.transport.tcp.TCPChannel.createConnection(TCPChannel.java:198)
	at sun.rmi.transport.tcp.TCPChannel.newConnection(TCPChannel.java:184)
	at sun.rmi.server.UnicastRef.invoke(UnicastRef.java:110)
	at javax.management.remote.rmi.RMIServerImpl_Stub.newClient(Unknown Source)
	at javax.management.remote.rmi.RMIConnector.getConnection(RMIConnector.java:2327)
	at javax.management.remote.rmi.RMIConnector.connect(RMIConnector.java:277)
	at javax.management.remote.JMXConnectorFactory.connect(JMXConnectorFactory.java:248)
	at SyntaxMain.main(SyntaxMain.java:24)
Caused by: java.net.ConnectException: Connection refused
	at java.net.PlainSocketImpl.socketConnect(Native Method)
	at java.net.PlainSocketImpl.doConnect(PlainSocketImpl.java:351)
	at java.net.PlainSocketImpl.connectToAddress(PlainSocketImpl.java:213)
	at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:200)
	at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:366)
	at java.net.Socket.connect(Socket.java:529)
	at java.net.Socket.connect(Socket.java:478)
	at java.net.Socket.<init>(Socket.java:375)
	at java.net.Socket.<init>(Socket.java:189)
	at sun.rmi.transport.proxy.RMIDirectSocketFactory.createSocket(RMIDirectSocketFactory.java:22)
	at sun.rmi.transport.proxy.RMIMasterSocketFactory.createSocket(RMIMasterSocketFactory.java:128)
	at sun.rmi.transport.tcp.TCPEndpoint.newSocket(TCPEndpoint.java:595)
	... 8 more
In fact,I connect to the 128.128.17.1 ActiveMQ server's jmx feature,but it point me that refusing by 127.0.0.1.Have to say this make me blues.",Bug
AMQ-3763,12546117,,"The Failover Transport guide, http://activemq.apache.org/failover-transport-reference.html, has two api links in the middle which are broken.  It looks like the version is missing from them and I assume should be:

http://activemq.apache.org/maven/5.5.0/activemq-core/apidocs/org/apache/activemq/transport/TransportListener.html
http://activemq.apache.org/maven/5.5.0/activemq-core/apidocs/org/apache/activemq/spring/ActiveMQConnectionFactory.html

accordingly. 

Kindest regards, 
Susan
",Bug
AMQ-4525,12646623,,"There is a broken link on the How can I monitor the connection with the broker documentation page [1].  The link references addTransportListener() method on the ActiveMQConnection and points to http://activemq.apache.org/maven/activemq-core/apidocs/org/apache/activemq/ActiveMQConnection.html#addTransportListener(org.apache.activemq.transport.TransportListener) which returns a 404 Not Found Error. 

Can this link be updated to: http://activemq.apache.org/maven/apidocs/org/apache/activemq/ActiveMQConnection.html#addTransportListener(org.apache.activemq.transport.TransportListener)


[1] http://activemq.apache.org/how-can-i-monitor-the-connection-with-the-broker.html",Bug
AMQ-3584,12530906,,"I was looking at http://activemq.apache.org/activemq-performance-module-users-manual.html to see how well (or poorly) the http transport was over the tcp transport and I've run into some issues just following the instructions.

svn co http://svn.apache.org/repos/asf/activemq/sandbox/activemq-perftest/
cd activemq-perftest
mvn activemq-perf:broker -Durl=broker:tcp://localhost:61616

{noformat}
[INFO] Scanning for projects...
[ERROR] The build could not read 1 project -> [Help 1]
[ERROR]   
[ERROR]   The project org.apache.activemq:activemq-perftest:5.2-SNAPSHOT (/Users/jason/ws/reference/activemq-perftest/pom.xml) has 1 error
[ERROR]     Non-resolvable parent POM: Could not find artifact org.apache.activemq:activemq-parent:pom:5.2-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 22, column 13 -> [Help 2]
[ERROR] 
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR] 
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/ProjectBuildingException
[ERROR] [Help 2] http://cwiki.apache.org/confluence/display/MAVEN/UnresolvableModelException
{noformat}

If I change the version to 5.5.1:

{noformat}
Index: pom.xml
===================================================================
--- pom.xml	(revision 1199413)
+++ pom.xml	(working copy)
@@ -22,7 +22,7 @@
    <parent>
        <artifactId>activemq-parent</artifactId>
        <groupId>org.apache.activemq</groupId>
-        <version>5.2-SNAPSHOT</version>
+        <version>5.5.1</version>
    </parent>

    <artifactId>activemq-perftest</artifactId>
{noformat}

mvn activemq-perf:broker -Durl=broker:tcp://localhost:61616

{noformat}
[INFO] Scanning for projects...
[WARNING] 
[WARNING] Some problems were encountered while building the effective model for org.apache.activemq:activemq-perftest:jar:5.5.1
[WARNING] 'build.plugins.plugin.version' for org.apache.activemq.tooling:maven-activemq-perf-plugin is missing. @ line 35, column 21
[WARNING] 'build.plugins.plugin.version' for org.apache.activemq.tooling:maven-activemq-memtest-plugin is missing. @ line 39, column 21
[WARNING] 
[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.
[WARNING] 
[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.
[WARNING] 
[INFO]                                                                         
[INFO] ------------------------------------------------------------------------
[INFO] Building ActiveMQ :: Performance Test 5.5.1
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-activemq-perf-plugin:5.5.1:broker (default-cli) @ activemq-perftest ---
Java Runtime: Apple Inc. 1.6.0_26 /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home
 Heap sizes: current=83008k  free=60712k  max=517760k
   JVM args: -Xmx512m -XX:MaxPermSize=128m -Dclassworlds.conf=/Users/jason/tools/maven/maven3/bin/m2.conf -Dmaven.home=/Users/jason/tools/maven/maven3
ACTIVEMQ_HOME: /Users/jason/.m2/repository/org/apache/activemq/activemq-console
ACTIVEMQ_BASE: /Users/jason/.m2/repository/org/apache/activemq/activemq-console
Loading message broker from: broker:tcp://localhost:61616
SLF4J: Failed to load class ""org.slf4j.impl.StaticLoggerBinder"".
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
Failed to execute main task. Reason: java.lang.NoClassDefFoundError: org/slf4j/impl/StaticLoggerBinder
{noformat}

So I configured logback & upgraded slf4j:

{noformat}
Index: pom.xml
===================================================================
--- pom.xml	(revision 1199413)
+++ pom.xml	(working copy)
@@ -22,7 +22,7 @@
    <parent>
        <artifactId>activemq-parent</artifactId>
        <groupId>org.apache.activemq</groupId>
-        <version>5.2-SNAPSHOT</version>
+        <version>5.5.1</version>
    </parent>

    <artifactId>activemq-perftest</artifactId>
@@ -35,6 +35,18 @@
            <plugin>
                <groupId>org.apache.activemq.tooling</groupId>
                <artifactId>maven-activemq-perf-plugin</artifactId>
+                <dependencies>
+                    <dependency>
+                        <groupId>org.slf4j</groupId>
+                        <artifactId>slf4j-api</artifactId>
+                        <version>1.6.2</version>
+                    </dependency>
+                    <dependency>
+                        <groupId>ch.qos.logback</groupId>
+                        <artifactId>logback-classic</artifactId>
+                        <version>1.0.0</version>
+                    </dependency>
+                </dependencies>
            </plugin>
            <plugin>
                <groupId>org.apache.activemq.tooling</groupId>
{noformat}

... and now it seems to function.",Bug
AMQ-2855,12482552,,"Sending message to composite destination increment only CursorMemoryUsage on last destination

Consuming message from first destination decrease CursorMemoryUser on last destination.

",Bug
AMQ-977,12482021,,"in activemq-web/src/main/java/org/apache/activemq/web/MessageServletSupport.java, the following method is used to create a JMS Topic or Queue Destination. However, note that the topic:// and channel:// blocks both set is_topic=true, so effectively those two blocks do exactly the same thing:

protected Destination getDestination(WebClient client, HttpServletRequest request, String destinationName) throws JMSException {

        // TODO cache destinations ???
       
        boolean is_topic=defaultTopicFlag;
        if (destinationName.startsWith(""topic://""))
        {
            is_topic=true;
            destinationName=destinationName.substring(8);
        }
        else if (destinationName.startsWith(""channel://""))
        {
            is_topic=true;
            destinationName=destinationName.substring(10);
        }
        else
            is_topic=isTopic(request);
       
        if( destinationOptions!=null ) {
            destinationName += ""?"" + destinationOptions;
        }
       
        if (is_topic) {
            return client.getSession().createTopic(destinationName);
        }
        else {
            return client.getSession().createQueue(destinationName);
        }
    }
",Bug
AMQ-772,12481715,,"Build ships without activemq-web-4.0.jar, so WAR generated by ant task incomplete.  I had to add this myself.  Can you please add it to the release?",Bug
AMQ-2805,12482892,,"The page http://activemq.apache.org/javadocs.html links to the bad URL http://activemq.apache.org/cms/html/.

It should instead point to http://activemq.apache.org/cms/.

The page served by the erroneous URL looks like it's actually the target of a bad redirect within the CMS sub-pages.  You'll notice that any of the relative URL links keep returning the same page (as they are all bad URLs), whereas the page returned by the correct URL contains correct links for those pages.

See related issue https://issues.apache.org/activemq/browse/AMQCPP-299",Bug
AMQ-2404,12482882,,Perhaps the log level of these should be changed to warn?,Bug
AMQ-215,12481225,,"The method CompositeTransportChannel.start() should fire off a connected status event after completing the call to establishConnection().

need to change from:

    public void start() throws JMSException {
        if (started.commit(false, true)) {
            establishConnection(establishConnectionTimeout);
        }
    }

to

    public void start() throws JMSException {
        if (started.commit(false, true)) {
            establishConnection(establishConnectionTimeout);
            fireStatusEvent(new TransportStatusEvent(this,TransportStatusEvent.CONNECTED));
        }
    }
",Bug
AMQ-212,12481222,,"I found that the useAsyncSend parameter was being ignored if defined on the client connection.  The problem is that the PooledExecutor is only created if the the useAsyncSend member is true at construction time (default is false).  However the client library sets this parameter after construction.  To fix the problem modified  setUseAsyncSend() method from:

    public void setUseAsyncSend(boolean useAsyncSend) {
    	this.useAsyncSend = useAsyncSend;
    }

to

    public void setUseAsyncSend(boolean useAsyncSend) {
    	this.useAsyncSend = useAsyncSend;
        try {
            if (useAsyncSend) {
                executor = new PooledExecutor(new BoundedBuffer(1000), 1);
            } else if (executor != null) {
                stopExecutor(executor);
            }
        } catch (Exception e) {
            log.warn(""problem closing executor"", e);
        }
    }",Bug
AMQ-2586,12483224,,"The queue size metric for topics is currently not accurate.  It is also throwing off the broker total message count metric.  In the queue case this metric is always going up but never comes down.  Since there is no ""queue"" for topics it would be better if this metrics just reported 0.

An alternative solution would be to sum the number of messages in all the subscriptions attached to the topic.",Bug
AMQ-1613,12482359,,The net affect of this is that clients don't get reconnected within the inactivity monitor configured time.  They have to wait for the OS socket to notice the connection failure to reconnect.  This in effect is making the inactivity monitor in-effective for heavily used connections.,Bug
AMQ-1216,12481945,,"
 <bean id=""oracle-ds"" class=""org.apache.commons.dbcp.BasicDataSource""
destroy-method=""close"">
   <property name=""driverClassName""
value=""oracle.jdbc.driver.OracleDriver""/>
   <property name=""url"" value=""jdbc:oracle:thin:@dev.abc.com:1521:dev10g""/>
   <property name=""username"" value=""abc""/>
   <property name=""password"" value=""abc""/>
   <property name=""poolPreparedStatements"" value=""true""/>
 </bean>


org.springframework.jms.UncategorizedJmsException: Uncategorized exception
occured during JMS processing; nested exception is javax.jms.JMSException:
Failed to broker message: ID:abc2-2257-1175204828244-0:8:1:1:1 in container:
java.sql.SQLException: Data size bigger than max size for this type: 63268
Caused by:
javax.jms.JMSException: Failed to broker message:
ID:abc2-2257-1175204828244-0:8:1:1:1 in container: java.sql.SQLException:
Data size bigger than max size for this type: 63268
       at
org.apache.activemq.util.JMSExceptionSupport.create(JMSExceptionSupport.java:46)
       at
org.apache.activemq.ActiveMQConnection.syncSendPacket(ActiveMQConnection.java:1177)
       at org.apache.activemq.ActiveMQSession.send(ActiveMQSession.java:1548)
       at
org.apache.activemq.ActiveMQMessageProducer.send(ActiveMQMessageProducer.java:465)
       at
org.apache.activemq.ActiveMQMessageProducer.send(ActiveMQMessageProducer.java:356)
       at org.springframework.jms.core.JmsTemplate.doSend(JmsTemplate.java:537)
       at org.springframework.jms.core.JmsTemplate.doSend(JmsTemplate.java:513)
       at org.springframework.jms.core.JmsTemplate$2.doInJms(JmsTemplate.java:479)
       at org.springframework.jms.core.JmsTemplate.execute(JmsTemplate.java:430)
       at org.springframework.jms.core.JmsTemplate.send(JmsTemplate.java:477)
       at org.springframework.jms.core.JmsTemplate.send(JmsTemplate.java:469)
       at
com.abc.jump.jdm.service.jms.AsynchronousTaskManagerImpl.createDeploymentTasks(AsynchronousTaskManagerImpl.java:67)
       at
com.abc.jump.process.view.plan.wizard.DeploymentTasksWizard.createDeploymentTasksAsynchronously(DeploymentTasksWizard.java:465)
       at
com.abc.jump.process.view.plan.wizard.DeploymentTasksWizard.onFinish(DeploymentTasksWizard.java:424)
       at
com.abc.jump.process.view.wizard.WizardScreen.onNavigation(WizardScreen.java:504)
       at echopoint.WizardPane.fireOnNavigation(WizardPane.java:416)
       at echopoint.WizardPane.actionPerformed(WizardPane.java:292)
       at nextapp.echo.AbstractButton.fireActionPerformed(AbstractButton.java:256)
       at
nextapp.echo.AbstractButton$EventForwarder.actionPerformed(AbstractButton.java:135)
       at
nextapp.echo.DefaultButtonModel.fireActionPerformed(DefaultButtonModel.java:98)
       at nextapp.echo.DefaultButtonModel.doAction(DefaultButtonModel.java:87)
       at nextapp.echo.AbstractButton.doAction(AbstractButton.java:245)
       at
nextapp.echoservlet.ui.AbstractButtonUI.clientAction(AbstractButtonUI.java:86)
       at echopoint.ui.PushButtonUI.clientAction(PushButtonUI.java:86)
       at
nextapp.echoservlet.ControllerInputProcessor.doAction(ControllerInputProcessor.java:157)
       at
nextapp.echoservlet.ControllerInputProcessor.<init>(ControllerInputProcessor.java:126)
       at
nextapp.echoservlet.ControllerInputProcessor.process(ControllerInputProcessor.java:54)
       at nextapp.echoservlet.Controller.service(Controller.java:609)
       at nextapp.echoservlet.Connection.process(Connection.java:459)
       at nextapp.echoservlet.EchoServer.process(EchoServer.java:314)
       at com.abc.jump.process.view.PortalServlet.process(PortalServlet.java:162)
       at nextapp.echoservlet.EchoServer.doPost(EchoServer.java:234)
       at javax.servlet.http.HttpServlet.service(HttpServlet.java:709)
       at javax.servlet.http.HttpServlet.service(HttpServlet.java:802)
       at
org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:252)
       at
org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173)
       at
com.abc.jump.process.view.web.filter.TemporaryAssetContentIntegrationFilter.doFilter(TemporaryAssetContentIntegrationFilter.java:76)
       at
org.acegisecurity.util.FilterToBeanProxy.doFilter(FilterToBeanProxy.java:90)
       at
org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:202)
       at
org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173)
       at
com.abc.common.view.util.ThreadLocalResourceFilter.doFilter(ThreadLocalResourceFilter.java:58)
       at
org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:202)
       at
org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173)
       at
org.springframework.orm.hibernate3.support.OpenSessionInViewFilter.doFilterInternal(OpenSessionInViewFilter.java:174)
       at
org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:77)
       at
org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:202)
       at
org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173)
       at
com.abc.common.util.filter.AuditUserDetailsFilter.doFilter(AuditUserDetailsFilter.java:64)
       at
org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:202)
       at
org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173)
       at
org.acegisecurity.context.HttpSessionContextIntegrationFilter.doFilter(HttpSessionContextIntegrationFilter.java:195)
       at
org.acegisecurity.util.FilterToBeanProxy.doFilter(FilterToBeanProxy.java:90)
       at
org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:202)
       at
org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173)
       at
org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:213)
       at
org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:178)
       at
org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:126)
       at
org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:105)
       at
org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:107)
       at
org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:148)
       at
org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:869)
       at
org.apache.coyote.http11.Http11BaseProtocol$Http11ConnectionHandler.processConnection(Http11BaseProtocol.java:664)
       at
org.apache.tomcat.util.net.PoolTcpEndpoint.processSocket(PoolTcpEndpoint.java:527)
       at
org.apache.tomcat.util.net.LeaderFollowerWorkerThread.runIt(LeaderFollowerWorkerThread.java:80)
       at
org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:684)
       at java.lang.Thread.run(Thread.java:595)
Caused by: java.io.IOException: Failed to broker message:
ID:abc2-2257-1175204828244-0:8:1:1:1 in container: java.sql.SQLException:
Data size bigger than max size for this type: 63268
       at
org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:31)
       at
org.apache.activemq.store.jdbc.JDBCMessageStore.addMessage(JDBCMessageStore.java:74)
       at
org.apache.activemq.store.memory.MemoryTransactionStore.addMessage(MemoryTransactionStore.java:224)
       at
org.apache.activemq.store.memory.MemoryTransactionStore$1.addMessage(MemoryTransactionStore.java:117)
       at org.apache.activemq.broker.region.Queue.send(Queue.java:345)
       at
org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:305)
       at
org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:378)
       at
org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:197)
       at org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:126)
       at
org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:98)
       at
org.apache.activemq.broker.MutableBrokerFilter.send(MutableBrokerFilter.java:136)
       at
org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:449)
       at
org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:604)
       at
org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:258)
       at
org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:164)
       at
org.apache.activemq.transport.TransportFilter.onCommand(TransportFilter.java:65)
       at
org.apache.activemq.transport.WireFormatNegotiator.onCommand(WireFormatNegotiator.java:133)
       at
org.apache.activemq.transport.InactivityMonitor.onCommand(InactivityMonitor.java:122)
       at
org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:84)
       at
org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:137)
       ... 1 more
Caused by: java.sql.SQLException: Data size bigger than max size for this
type: 63268
       at oracle.jdbc.dbaccess.DBError.throwSqlException(DBError.java:134)
       at oracle.jdbc.dbaccess.DBError.throwSqlException(DBError.java:179)
       at oracle.jdbc.ttc7.TTCItem.setArrayData(TTCItem.java:95)
       at
oracle.jdbc.dbaccess.DBDataSetImpl.setBytesBindItem(DBDataSetImpl.java:2413)
       at
oracle.jdbc.driver.OraclePreparedStatement.setItem(OraclePreparedStatement.java:1166)
       at
oracle.jdbc.driver.OraclePreparedStatement.setBytes(OraclePreparedStatement.java:2208)
       at
org.apache.commons.dbcp.DelegatingPreparedStatement.setBytes(DelegatingPreparedStatement.java:105)
       at
org.apache.commons.dbcp.DelegatingPreparedStatement.setBytes(DelegatingPreparedStatement.java:105)
       at
org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.setBinaryData(DefaultJDBCAdapter.java:56)
       at
org.apache.activemq.store.jdbc.adapter.DefaultJDBCAdapter.doAddMessage(DefaultJDBCAdapter.java:175)
       at
org.apache.activemq.store.jdbc.JDBCMessageStore.addMessage(JDBCMessageStore.java:71)
       ... 19 more
--
View this message in context: http://www.nabble.com/Data-size-bigger-than-max-size-for-this-type-tf3489299s2354.html#a9744357",Bug
AMQ-651,12481600,,"Need to check to see if this is still valid against 4.x
See:
http://issues.apache.org/jira/browse/GERONIMO-1493",Bug
AMQ-289,12481133,,"org.activemq.test.RollbackTest has the test case from Deepak Nayal.

",Bug
AMQ-211,12481144,,"I found a problem with the use of the Reliable protocol.  If you list multiple servers and the connection to the initial fails, the reconnect process will not complete properly.  This is cause because of the firing order of status events.  In the TcpTransportChannel.doClose() method the call to onAsyncException() will cause the Reliable class to fire a status event for disconnected, then after establishing the connection to the next server it will fire a status event for reconnected.  Finally after control returns to the doClose() method another status event for disconnected is fired.  All of these events are received by the ActiveMQConnection.statusChanged() method and are interpreted to set the ActiveMQConnection.isTransportOK member.  With the series of events as listed above:

disconnected
reconnected
disconnected

you can see why the state of ActiveMQConnection.isTransportOK is incorrect after a reconnect.

I did not know if it were safe to actually remove the final fireStatusEvent() call from the TcpTransportChannel.doClose(), so did the next best thing.  I moved it up before the the call to onAsyncException() .  This changed the order of the events to:

disconnected
disconnected
reconnected

This fixed my problem, but I am not sure it is the proper fix.
",Bug
AMQ-2893,12483464,,"When installing FUSE HQ,  it was said in instructions that no DB is needed (built in included in HQ), but anyways, there is no such option:

Choose which software to install:
1: FUSE HQ Server
2: FUSE HQ Agent
You may enter multiple choices, separated by commas.
1
HQ server installation path [default '/opt/iona/fusehq-4.2.0.0-fuse']:

Enter the fully qualified domain name of the SMTP server that HQ will use to send email messages [default 'saenafuq20.europe.nokia.com']:

Choices:
        1: Oracle 10g/11g
        2: PostgreSQL
        3: MySQL Enterprise / Community Server 5.x*

        *Sign up for a MySQL Enterprise Trial subscription at http://www.mysql.com/trials/partner1569.

What backend database should the HQ server use? [default '1']:
",Bug
AMQ-2890,12483460,,"To reproduce: in webconsole, go to 'Queues', select a queue, then click on 'printable version':

javax.el.ELException: java.lang.IllegalArgumentException: No JMSDestination parameter specified
        at javax.el.BeanELResolver.getValue(BeanELResolver.java:298)
        at javax.el.CompositeELResolver.getValue(CompositeELResolver.java:175)
        at com.sun.el.parser.AstValue.getValue(AstValue.java:138)
        at com.sun.el.ValueExpressionImpl.getValue(ValueExpressionImpl.java:206)
        at org.apache.jasper.runtime.PageContextImpl.evaluateExpression(PageContextImpl.java:1001)
        at org.apache.jsp.browse_jsp._jspx_meth_jms_forEachMessage_0(org.apache.jsp.browse_jsp:167)
        at org.apache.jsp.browse_jsp._jspService(org.apache.jsp.browse_jsp:100)
        at org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:109)
...
Caused by: java.lang.IllegalArgumentException: No JMSDestination parameter specified
        at org.apache.activemq.web.DestinationFacade.getValidDestination(DestinationFacade.java:109)
        at org.apache.activemq.web.QueueBrowseQuery.getQueue(QueueBrowseQuery.java:65)
        at org.apache.activemq.web.QueueBrowseQuery.createBrowser(QueueBrowseQuery.java:91)
        at org.apache.activemq.web.QueueBrowseQuery.getBrowser(QueueBrowseQuery.java:54)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
",Bug
AMQ-1531,12482246,,"On this page[1], the hyperlink to the technical presentation at the top is dead, also the two hyperlinks that are aliased ""this example"" are also broken.  I can't fix it  because I don't know they should be replaced with.

[1] http://activemq.apache.org/visualisation.html",Bug
AMQ-1558,12482272,,See this thread for the patch : http://www.nabble.com/ActiveMQ-5%3A-install-as-windows-service-does-not-work-tp14947392s2354p14988331.html,Bug
AMQ-1261,12482000,,"I get this from the demo app when I go to the queue browser pages ...

java.lang.IllegalStateException: missing ConnectionFactory in QueueBrowserServlet
	at org.apache.activemq.web.QueueBrowseServlet.getConnectionFactory(QueueBrowseServlet.java:75)
	at org.apache.activemq.web.QueueBrowseServlet.getConnection(QueueBrowseServlet.java:63)
	at org.apache.activemq.web.QueueBrowseServlet.createSession(QueueBrowseServlet.java:158)
	at org.apache.activemq.web.QueueBrowseServlet.borrowSession(QueueBrowseServlet.java:140)
	at org.apache.activemq.web.QueueBrowseServlet.doGet(QueueBrowseServlet.java:89)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:707)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:820)
	at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:467)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1075)
	at org.apache.activemq.web.SessionFilter.doFilter(SessionFilter.java:47)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1066)
	at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:365)
	at org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:185)
	at org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:181)
	at org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:715)
	at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:402)
	at org.mortbay.jetty.handler.HandlerCollection.handle(HandlerCollection.java:114)
	at org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:139)
	at org.mortbay.jetty.Server.handle(Server.java:285)
	at org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:469)
	at org.mortbay.jetty.HttpConnection$RequestHandler.headerComplete(HttpConnection.java:791)
	at org.mortbay.jetty.HttpParser.parseNext(HttpParser.java:500)
	at org.mortbay.jetty.HttpParser.parseAvailable(HttpParser.java:209)
	at org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:358)
	at org.mortbay.io.nio.SelectChannelEndPoint.run(SelectChannelEndPoint.java:365)
	at org.mortbay.thread.BoundedThreadPool$PoolThread.run(BoundedThreadPool.java:442)",Bug
AMQ-334,12481572,,"A message consumer will not receive message that matches its message selector definition, until all other messages with higher priority have been consumerd from the queue.  

For example, say our messages have a property which can have one of two values - 'S' and 'N'. We have a queue where, at the moment, there is only one consumer, who is set up to consume only 'S' messages.  We've tested
this with two scenarios: 
1)       Place an 'N' message in the queue, followed by an 'S'.  No
priority is assigned to the messages.  The consumer is able to receive
the 'S' message, even though the 'N' message is ahead of it in the
queue.  This is the behavior that we find logical.

2)       Place an 'N' message in the queue with a priority of 4,
 followed by an 'S' with a priority of 2.  Only difference from
scenario 1 is that priorities have been assigned to messages.  Now the
consumer cannot receive any messages ¡V it blocks until we add a
consumer that consumes the 'N' type message.  This behavior seems to be a bug. 
",Bug
AMQ-712,12481563,,"investigate possible bug on byte selector.   A test case would be helpful

http://www.nabble.com/Byte-selector-does-not-work-t1637922.html

",Bug
AMQ-299,12481038,,There seems to be memory leak regarding JMSStatsImpl class. It holds references to all connections (opened and closed). And because of following asociations - the reference tree grows huge. Simple test code just opening and closing connection causes memory usage to grow up to out of memory error.,Bug
AMQ-2701,12483429,,"I'm not sure if this issue should be reported here or in the Apache-Camel project.  Please let me know if I've logged it in the wrong place.  I have a drop folder used for testing called ""c:\esb\aaa"".  I have the route in the apache-activemq-5.3.0\webapps\camel\WEB-INF\applicationContext.xml file set up to route files from ""c:\esb\aaa"" to ""activemq:testQ"".  When I drop a file in the folder it appears to make it into the queue.  I see a camelLock file appear in the drop folder temporarily, but when it disappears the original file that I dropped remains and was not moved to the "".camel"" subfolder.  I can do the samething from my WindowsXP Laptop and it works, so I'm not sure what the problem is or how to track it down.  Here's my stacktrace:

org.apache.camel.component.file.GenericFileOperationFailedException: Cannot rename file: GenericFile[c:\esb\aaa\Test4.txt] to: GenericFile[c:\esb\aaa\.camel\Test4.txt]
	at org.apache.camel.component.file.strategy.GenericFileRenameProcessStrategy.renameFile(GenericFileRenameProcessStrategy.java:96)
	at org.apache.camel.component.file.strategy.GenericFileRenameProcessStrategy.commit(GenericFileRenameProcessStrategy.java:72)
	at org.apache.camel.component.file.GenericFileOnCompletion.processStrategyCommit(GenericFileOnCompletion.java:120)
	at org.apache.camel.component.file.GenericFileOnCompletion.onCompletion(GenericFileOnCompletion.java:82)
	at org.apache.camel.component.file.GenericFileOnCompletion.onComplete(GenericFileOnCompletion.java:50)
	at org.apache.camel.impl.DefaultUnitOfWork.done(DefaultUnitOfWork.java:115)
	at org.apache.camel.processor.UnitOfWorkProcessor.processNext(UnitOfWorkProcessor.java:60)
	at org.apache.camel.processor.DelegateProcessor.process(DelegateProcessor.java:48)
	at org.apache.camel.component.file.GenericFileConsumer.processExchange(GenericFileConsumer.java:198)
	at org.apache.camel.component.file.GenericFileConsumer.processBatch(GenericFileConsumer.java:120)
	at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:93)
	at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:99)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)
	at java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:317)
	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:150)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:98)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.runPeriodic(ScheduledThreadPoolExecutor.java:181)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:205)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.Thread.run(Thread.java:619)",Bug
AMQ-1496,12483439,,"Testing  ActiveMQ integrated in JBoss I found that the following doesn't work anymore:

<config-property-value>failover://(tcp://192.168.8.101:65001)?jms.prefetchPolicy.all=1000</config-property-value>

I got the following exception:

2007-11-16 15:08:50,734 ERROR [org.apache.activemq.ra.ActiveMQEndpointWorker] Endpoint connection to JMS broker failed: Could not create Transport. Reason: java.lang.IllegalArgumentException: Invalid connect parameters: {jms.prefetchPolicy.all=1000}
2007-11-16 15:08:50,734 ERROR [org.apache.activemq.ra.ActiveMQEndpointWorker] Endpoint will try to reconnect to the JMS broker in 30 seconds
",Bug
AMQ-752,12481653,,"all the various LICENSEs need to be appended into a single LICENSE and the notices consolidated.

Also we might want to...

* the MANIFEST lacks a Implementation-Vendor-Id. not reported harmful but is
in the spec. suggested value: org.apache.

* the MANIFEST lacks a Specification-Version but has an
Implementation-Version. suggested value 4.0.

* better if the source extracts into a directory with a different name from
the binary distribution. for example, incubator-activemq-src for the source
and incubator-activemq for the binary (say.

* i would prefer the binaries and distributions names to contain apache. for
example apache-incubator-activemq.",Bug
AMQ-587,12481626,,"Sometimes when creating a temporary topic I get:

Exception in thread ""tcp:///127.0.0.1:39442"" java.lang.ClassCastException: org.apache.activemq.command.ActiveMQTempTopic
        at org.apache.activemq.openwire.v1.DestinationInfoMarshaller.unmarshal(DestinationInfoMarshaller.java:67)
        at org.apache.activemq.openwire.OpenWireFormat.doUnmarshal(OpenWireFormat.java:214)
        at org.apache.activemq.openwire.OpenWireFormat.unmarshal(OpenWireFormat.java:181)
        at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:135)
        at java.lang.Thread.run(Thread.java:595)

This only seems to happen if I try to create a lot of temp topics in a lot of different threads at the same time.",Bug
AMQ-654,12481624,,"The organization url needs to be corrected as it is currently invalid.

The values for the siteAddress siteDirectory distributionSite and distributionDirectory need to be reviewed.

The mailing list information to need to be updated to point to the apache mailing lists

The mailing list archives could be updated to point to archives that Hiram has requested to be setup on Nabble.",Bug
AMQ-166,12481114,,"TransportChannelSupport have concurrent problem. Sometimes activemq warnning this message. --> ""No Packet found to match Receipt correlationId"". TransportChannelSupport's member field ""sessionList"" does not thread safe. How about change the field type from java.util.HashMap to java.util.Hashtable. 

And I have a question. 
How to know the pending message count in Queue or Topic in jms client application. How to use JMS management function.",Bug
AMQ-2689,12483109,,"After reading through ActiveMQ in Action and talking with bsnyder It appears that 

http://activemq.apache.org/connection-configuration-uri.html

and

http://activemq.apache.org/version-5-performance-tuning.html

have the wrongdefinition for alwaysSessionAsync. 

They say that by setting it to true a separate thread would NOT be used but the OPPOSITE is true.",Bug
AMQ-1697,12482469,,"I'm trying to set a redelivery policy in my activemq.xml config

       <policyEntry queue=""ABC.Queue1"">
               <redeliveryPolicy maximumRedeliveries=""-1"">
               </redeliveryPolicy>
            </policyEntry>

Unfortunately, activemq is complaining about the configuraiton

Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'policyEntry#c943d1' defined in class path resource [activemq.xml]: Initialization of bean failed; nested exception is org.springframework.beans.InvalidPropertyException: Invalid property 'redeliveryPolicy' of bean class [org.apache.activemq.broker.region.policy.PolicyEntry]: No property 'redeliveryPolicy' found
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:445)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$1.run(AbstractAutowireCapableBeanFactory.java:383)
        at java.security.AccessController.doPrivileged(Native Method)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:353)
        at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveInnerBean(BeanDefinitionValueResolver.java:219)
        ... 42 more
Caused by: org.springframework.beans.InvalidPropertyException: Invalid property 'redeliveryPolicy' of bean class [org.apache.activemq.broker.region.policy.PolicyEntry]: No property 'redeliveryPolicy' found
        at org.springframework.beans.BeanWrapperImpl.convertForProperty(BeanWrapperImpl.java:377)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.convertForProperty(AbstractAutowireCapableBeanFactory.java:1211)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1177)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:940)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:437)
        ... 46 more
",Bug
AMQ-110,12481250,,"I am using a not transacted and auto-acknowledge queue.

I am using the <berkeleyDbPersistence/> adapter

The error message that I a reveiving is :

Could not delete sequenece number for: org.codehaus.activemq.service.MessageIdentity@7a86771e[id=ID:ev1.drivenow.com.au-50147-1097167695356-16132:0; sequenceNo=<DatabaseEntry dlen=0 doff=0 doff=0 offset=0 size=8>] status: OperationStatus.NOTFOUND

Any pointers on how serious this error is - i.e. is the queue performing normally even though this message is being logged ?",Bug
AMQ-176,12481061,,,Bug
AMQ-2797,12482928,,"The KEYS file does not include A2F9E313 which was used to sign the 5.3.2 release.

Furthermore, the key A2F9E313 does not appear to be available from the pgp.mit.edu server.

This means that it is impossible to check the integrity of the release.

",Bug
AMQ-337,12481504,,"This is re-submission of bug AMQ-334, since the link to AMQ-334 is broken on Jira.
 
A message consumer will not receive message that matches its message selector definition, until all other messages with higher priority have been consumerd from the queue.

For example, say our messages have a property which can have one of two values - 'S' and 'N'. We have a queue where, at the moment, there is only one consumer, who is set up to consume only 'S' messages.  We've tested
this with two scenarios:
1)       Place an 'N' message in the queue, followed by an 'S'.  No
priority is assigned to the messages.  The consumer is able to receive
the 'S' message, even though the 'N' message is ahead of it in the
queue.  This is the behavior that we find logical.

2)       Place an 'N' message in the queue with a priority of 4,
 followed by an 'S' with a priority of 2.  Only difference from
scenario 1 is that priorities have been assigned to messages.  Now the
consumer cannot receive any messages ¡V it blocks until we add a
consumer that consumes the 'N' type message.  This behavior seems to be a bug.


--
This message is automatica",Bug
AMQ-2066,12481356,,"Hi,

I am doing a add in to atach to an application wich is runing in java 1.4.

The problem is that i can't compile my source becouse all bitecodes i found

wich has ActiveMQConnectionFactory is compiled in java 5.

Can you help?

thank you.",Bug
AMQ-193,12481174,,"In the class org.codehaus.activemq.management.JMSEndpointStatsImpl the following getter should be exposed to provide access to the throughput statistic as is possible for the others.

public TimeStatistic getMessageRateTime() {
    return messageRateTime;
}",Bug
AMQ-173,12481170,,"I am testing a setup where two brokers are networked in a site. This is done to provided but load balancing and high availablity.  However I have found a bug that prevents this configuration for both purposes.  In short if one of the broker fails for any length of time, the remain broker can never re-establish a proper link back to the restored broker.  The following steps to duplicate this problem.


Topology: 2 brokers
               broker1 port=61616, network channel=62626
               broker2 port=62626, network channel=61616
          1 consumer connects to 61616
			 1 producer connects to 62626
			 

Test procedure:

1) start broker1 and broker2
   log shows that both brokers establish network channels to the other
	
2) start consumer
	log for broker1 show client connection and forward of destination registration to broker2
	log for broker2 show receipt of destination registration
	 
3) start producer
   log for broker2 shows client connection and discconection when producer terminates
	log for broker1 shows forwarded messages for consumer received from broker2
	
4) stop broker2
   log for broker2 shows shutdown
	log for broker1 show broker2 disconnect, but also errors when trying to send keepalive
	
5) stop consumer

6) wait 2+ minutes, wait for ""NetworkChannel - stopped MetworkMessageBridge for destination:"" in broker1 log

7) start broker2
   log for broker1 shows establishment of network channel for broker2, but broker2 log does not corresponding broker1 network channel registration
	
8) start consumer
   log for broker 1 show error in attempt to establish NetworkMessageBridge for destination
	
9) start producter
   log for broker2 shows client connection and discconection when producer terminates
	log for broker1 shows NO forwarded messages",Bug
AMQ-226,12481185,,"Given the broker setup where:

1. A reliable/tcp NetworkChannel is defined with an extremely large value establishConnectionTimeout (allowing a never timeout case)
2. The target of the NetworkChannel is not available, so the channel never completes the initial setup.

Then attempt to stop the broker with a kill command.  (should be better way, maybe admin function)

The broker vm does not shutdown cleanly on linux as there is monitor lock conflict between the shutdown thread and the unfinished network channel thread.",Bug
AMQ-213,12481191,,"The TransportStatusEvent.toString() sometimes prints null for the connection information.  This happens when the remoteURI was provided to the event rather than a TransportChannel object.  The following replacement method will print a better message in these cases.

public String toString() {
    return ""Channel: "" + (transportChannel == null ? remoteURI.toString() : transportChannel.toString()) + "" has "" + getStatusAsString(channelStatus);
}
",Bug
AMQ-5562,12772074,,"If I send to a producer with:

        MessageProducer producer = session.createProducer( dest );
        producer.send( message );

That works and I receive the advisory.

However, if send like this:

        MessageProducer producer = session.createProducer( null );
        producer.send( dest, message );

The advisory isn’t raised.  I have a unit test to confirm that the message was delivered to the queue and that it fails to raise the advisory.

The problem is that the second method is about 5x faster than the first.  

I can certainly rewrite my code, but this could lead to bugs where code expects to receive the advisory notice but now there’s a back door to send messages without the advisory message meaning that you could break production code.

On the list, Timothy Bish noted:

> This is by design as the second case creates an anonymous producer that can send to any destination that it has permission to write to.  Sending that advisory every time an anonymous producer sent a message to a given destination would create a flood of advisories which would not really be of help.

However:

> I mean I can create the flood of advisories now anyway. I just have to manually create a non-anonymous producer and it would then send the same number of advisories.

> Now it’s just slower and you’ve put a burden on me to maintain an LRU cache and expiry so that I can have reasonable performance :-(

I think this is a bug.  If you're experiencing floods you can always turn off advisories or be more specific in which queues you would like notifications about.",Bug
AMQ-7011,13172266,,"Activemq 5.15.4 Stomp protocol allowed to enter deadlock via dispatch sync.

Scenario:

Stomp client setting the following:
header.put(""id"", subId);
header.put(""activemq.dispatchAsync"", ""false"");

The setup of locks between TopicSubscription and MutexTransport while using Stomp in sync mode can result in a Deadlock as found below (Add and Destroy calls processing), each lock is identified by a + or * to show lock order in each stack trace.

  Found one Java-level deadlock:
=============================
""ActiveMQ Transport: tcp:///127.0.0.1:58303@61613"":
  waiting to lock monitor 0x00007f9c565d4d28 (object 0x00000007acc44708, a java.lang.Object),
  which is held by ""ActiveMQ Transport: tcp:///127.0.0.1:58302@61613""
""ActiveMQ Transport: tcp:///127.0.0.1:58302@61613"":
  waiting for ownable synchronizer 0x00000007ac872730, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),
  which is held by ""ActiveMQ Transport: tcp:///127.0.0.1:58303@61613""
Java stack information for the threads listed above:
===================================================
""ActiveMQ Transport: tcp:///127.0.0.1:58303@61613"":
++++++  at org.apache.activemq.broker.region.TopicSubscription.destroy(TopicSubscription.java:757)
    - waiting to lock <0x00000007acc44708> (a java.lang.Object)
    at org.apache.activemq.broker.region.AbstractRegion.destroySubscription(AbstractRegion.java:488)
    at org.apache.activemq.broker.jmx.ManagedTopicRegion.destroySubscription(ManagedTopicRegion.java:52)
    at org.apache.activemq.broker.region.AbstractRegion.removeConsumer(AbstractRegion.java:480)
    at org.apache.activemq.broker.region.TopicRegion.removeConsumer(TopicRegion.java:206)
    at org.apache.activemq.broker.region.RegionBroker.removeConsumer(RegionBroker.java:429)
    at org.apache.activemq.broker.jmx.ManagedRegionBroker.removeConsumer(ManagedRegionBroker.java:258)
    at org.apache.activemq.broker.BrokerFilter.removeConsumer(BrokerFilter.java:139)
    at org.apache.activemq.advisory.AdvisoryBroker.removeConsumer(AdvisoryBroker.java:352)
    at org.apache.activemq.broker.BrokerFilter.removeConsumer(BrokerFilter.java:139)
    at org.apache.activemq.broker.BrokerFilter.removeConsumer(BrokerFilter.java:139)
    at org.apache.activemq.broker.BrokerFilter.removeConsumer(BrokerFilter.java:139)
    at org.apache.activemq.broker.TransportConnection.processRemoveConsumer(TransportConnection.java:729)
    at org.apache.activemq.broker.TransportConnection.processRemoveSession(TransportConnection.java:768)
    at org.apache.activemq.broker.TransportConnection.processRemoveConnection(TransportConnection.java:879)
    - locked <0x00000007ac999f00> (a org.apache.activemq.broker.jmx.ManagedTransportConnection)
    at org.apache.activemq.command.RemoveInfo.visit(RemoveInfo.java:73)
    at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:330)
    at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:194)
*****   at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:45)
    at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:301)
    at org.apache.activemq.transport.stomp.StompTransportFilter.sendToActiveMQ(StompTransportFilter.java:97)
    at org.apache.activemq.transport.stomp.ProtocolConverter.sendToActiveMQ(ProtocolConverter.java:202)
    at org.apache.activemq.transport.stomp.ProtocolConverter.onStompDisconnect(ProtocolConverter.java:838)
    at org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommand(ProtocolConverter.java:267)
    at org.apache.activemq.transport.stomp.StompTransportFilter.onCommand(StompTransportFilter.java:85)
    at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)
    at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:233)
    at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:215)
    at java.lang.Thread.run(Thread.java:748)
""ActiveMQ Transport: tcp:///127.0.0.1:58302@61613"":
    at sun.misc.Unsafe.park(Native Method)
    - parking to wait for  <0x00000007ac872730> (a java.util.concurrent.locks.ReentrantLock$NonfairSync)
    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:870)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1199)
    at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLock.java:209)
    at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:285)
*****   at org.apache.activemq.transport.MutexTransport.oneway(MutexTransport.java:66)
    at org.apache.activemq.broker.TransportConnection.dispatch(TransportConnection.java:1486)
    at org.apache.activemq.broker.TransportConnection.processDispatch(TransportConnection.java:971)
    at org.apache.activemq.broker.TransportConnection.dispatchSync(TransportConnection.java:927)
    at org.apache.activemq.broker.region.TopicSubscription.dispatch(TopicSubscription.java:715)
+++++   at org.apache.activemq.broker.region.TopicSubscription.add(TopicSubscription.java:121)
    - locked <0x00000007acc44708> (a java.lang.Object)
    at org.apache.activemq.broker.region.policy.SimpleDispatchPolicy.dispatch(SimpleDispatchPolicy.java:48)
    at org.apache.activemq.broker.region.Topic.dispatch(Topic.java:775)
    at org.apache.activemq.broker.region.Topic.doMessageSend(Topic.java:556)
    - locked <0x00000007acbd4e08> (a org.apache.activemq.broker.region.Topic)
    at org.apache.activemq.broker.region.Topic.send(Topic.java:484)
    at org.apache.activemq.broker.region.AbstractRegion.send(AbstractRegion.java:505)
    at org.apache.activemq.broker.region.RegionBroker.send(RegionBroker.java:459)
    at org.apache.activemq.broker.jmx.ManagedRegionBroker.send(ManagedRegionBroker.java:293)
    at org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:154)
    at org.apache.activemq.broker.CompositeDestinationBroker.send(CompositeDestinationBroker.java:96)
    at org.apache.activemq.broker.TransactionBroker.send(TransactionBroker.java:293)
    at org.apache.activemq.broker.BrokerFilter.send(BrokerFilter.java:154)
    at org.apache.activemq.broker.TransportConnection.processMessage(TransportConnection.java:572)
    at org.apache.activemq.command.ActiveMQMessage.visit(ActiveMQMessage.java:768)
    at org.apache.activemq.broker.TransportConnection.service(TransportConnection.java:330)
    at org.apache.activemq.broker.TransportConnection$1.onCommand(TransportConnection.java:194)
    at org.apache.activemq.transport.MutexTransport.onCommand(MutexTransport.java:45)
    at org.apache.activemq.transport.AbstractInactivityMonitor.onCommand(AbstractInactivityMonitor.java:301)
    at org.apache.activemq.transport.stomp.StompTransportFilter.sendToActiveMQ(StompTransportFilter.java:97)
    at org.apache.activemq.transport.stomp.ProtocolConverter.sendToActiveMQ(ProtocolConverter.java:202)
    at org.apache.activemq.transport.stomp.ProtocolConverter.onStompSend(ProtocolConverter.java:345)
    at org.apache.activemq.transport.stomp.ProtocolConverter.onStompCommand(ProtocolConverter.java:248)
    at org.apache.activemq.transport.stomp.StompTransportFilter.onCommand(StompTransportFilter.java:85)
    at org.apache.activemq.transport.TransportSupport.doConsume(TransportSupport.java:83)
    at org.apache.activemq.transport.tcp.TcpTransport.doRun(TcpTransport.java:233)
    at org.apache.activemq.transport.tcp.TcpTransport.run(TcpTransport.java:215)
    at java.lang.Thread.run(Thread.java:748)


In reviewing how MQTT and AMQP were handled, both set ""consumerInfo.setDispatchAsync(true);""

AMQPSession line 376
MQTTDefualtSubscriptionStrategy line 61

For MQTT fix see the below cards:

ENTMQ-1504
https://issues.jboss.org/browse/ENTMQ-1504?_sscc=t

AMQ-5290
https://issues.apache.org/jira/browse/AMQ-5290 https://github.com/apache/activemq/blame/master/activemq-mqtt/src/main/java/org/apache/activemq/transport/mqtt/strategy/MQTTDefaultSubscriptionStrategy.java#L61 

I believe we can fix this for Stomp in ProtocolConverter, line 614, by also setting consumerInfo.setDispatchAsync(true); This would bring Stomp into alignment with the other protocols and how they were fixed.

I'll be providing a patch with the above change shortly.",Bug
AMQ-3767,12546464,,"The following typos should be corrected at the following link: http://activemq.apache.org/activemq-message-properties.html

JMSType description should contain the value ""user defined""
JMSMessageID description should contain the value ""unique identifier for the message""
JMSRedelivered has the values shift over a column



",Bug
